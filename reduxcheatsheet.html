<!DOCTYPE html>
<html>
    <head>
        <title>Redux Cheat Sheet</title>
        <link href="./resources/css/index.css" type="text/css" rel="stylesheet">
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link rel="preconnect" href="https://fonts.googleapis.com">
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
    </head>
    <body>
        <header>
            <nav>
                <ul>
                    <li><a href="./htmlcheatsheet.html">HTML</a></li>
                    <li><a href="./csscheatsheet.html">CSS</a></li>
                    <li><a href="./commandlinecheatsheet.html">Command Line</a></li>
                    <li><a href="./javascriptcheatsheet.html">JavaScript</a></li>
                    <li><a href="./reactcheatsheet.html">React</a></li>
                    <li><a href="./reduxcheatsheet.html">Redux</a></li>
                    <li><a href="./markdowncheatsheet.html">Markdown</a></li>
                    <li><a href="./styleguide.html">Style Guide</a></li>
                </ul>
            </nav>
        </header>
        <div class="content">
            <h1>Redux Cheat Sheet</h1>
            <p>Below is a brief list of fundamental Redux tags/expressions and syntax including a brief description of what they do and any notes on correct syntax.</p>
            <div class="container" id="redux_introduction">
                <h2>Redux Introduction</h2>
                <p>This section describes the Javascript library Redux, how to use it and the core principles it embodies including notes on usages and correct syntax.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Redux</td>
                            <td>Core principles</td>
                            <td>Redux is a method of managing state throughout web apps. It is perhaps best thought of as the main HQ for the state in your entire web app.<br/><br/>Before implementing Redux, a React web app can be built from numerous different components, some may have their own states and some may be stateless, however there is no centralised HQ for state.<br/>This is what Redux provides.<br/><br/>In addition to this Redux insists on a system based on a pure separation of concerns when it comes to state. This means that functions that process elements of state should be written to have no additional effect on the input. This ensures that the results are always consistent and the function has no additional logic to change the result other than calculation of its input.<br/>The best analogy for this is that of a cassette player. The player is consistent and will only play the songs present on the inserted cassette.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Importing Redux elements</td>
                            <td>The Redux library must be imported like other methods and components before using in our app. Example syntax is shown below;<br/><br/><span class="attribute">import {  } from 'redux';</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">action</span></td>
                            <td>Action keyword</td>
                            <td>In Redux state is managed through actions.<br/><br/>If we follow on with our cassette player analogy, the player itself is a function that we will describe later however, actions are best thought of as different tapes that can be inserted into the player to tell it what song to play.<br/><br/>An action is written as a plain Javacsript object.<br/>Every action has a <span class="attribute">type</span> property with a string value. This string is a description of the action.<br/>Actions can also have a secondary key-value called <span class="attribute">payload</span>. This contains any additional information related to the action.<br/><br/>In the examples below we are interacting with an array that represents the state for a spotify playlist.<br/><br/><span class="attribute">const action = {<br/>type: 'playlist/addSong',<br/>payload: 'Carrion'<br/>};</span><br/><br/>In the above action we are adding a song to the array so our action description is <span class="attribute">'playlist/addSong'</span>. It tells us in very simple terms <span class="attribute">playlist</span> is the state target and <span class="attribute">addSong</span> is the action. It then also tells us what song to add in the <span class="attribute">payload</span>, we are adding a song called <span class="attribute">Carrion</span>.<br/><br/><span class="attribute">const action = {<br/>type: 'playlist/removeSong',<br/>payload: 'Thriller'<br/>}</span><br/><br/>In this action we are removing the song <span class="attribute">Thriller</span> from the playlist<br/><br/><span class="attribute">const action = {<br/>type: 'playlist/removeAll'<br/>}</span><br/><br/>Finally, notice how this action does not have a <span class="attribute">payload</span> because its purpose it to remove everything from the state in contrast to the previous removal action where it is removing a specific item described in the <span class="attribute">payload</span>.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">reducer</span></td>
                            <td>Reducer function</td>
                            <td>The reducer function is the cassette player in Redux.<br/><br/>Due to the way i operates and the intentions behind its operation, there are a few additional notes that apply to all reducers that need to be explained before moving on any further.<br/><br/>It is a plain javascript function that defines how the current state and an action are used in combination to create a new state.<br/>It defines the applications next state, given a current state and a specific action.<br/>It returns a default initial state if no action is provided.<br/>It returns the current state if the action is not recognized.<br/><br/>A reducer function accepts 2 arguments these are <span class="attribute">state</span> and <span class="attribute">action</span>.<br/>The rest of the function looks very similar to a <span class="attribute">switch</span> and <span class="attribute">case</span> conditional expression.<br/>The <span class="attribute">state</span> argument is written in an unusual way, although it is an argument it is written as though its a variable declaration.<br/>A couple of different options of how this could be written are shown below to give this some context;<br/><br/><span class="attribute">const someOtherState = [];<br/><br/>const reducer = (state = someOtherState, action) => {<br/>//function body<br/>}</span><br/>OR<br/><span class="attribute">const reducer = (state = [], action) => {<br/>//function body<br/>}</span><br/><br/>The reason for writing the function in this way is that it initialises the state parameter of the function with a default value. So based on the added notes above about how reducer functions work, we need to give the state a default value in the event that the action is not recognized or no action is provided so that a state can, and will, be provided no matter what.<br/>The rest of the function body is written in an almost identical fashion to a <span class="attribute">switch</span> and <span class="attribute">case</span> expression.<br/><br/>An example using the playlist actions from above is shown below, in this example we have declared an initial state called <span class="attribute">playlistState</span> as an array containing 1 item.<br/><br/><span class="attribute">const playlistState = ['Thriller'];<br/><br/>const action = {<br/>type: 'playlist/addSong',<br/>payload: 'Carrion'<br/>}<br/><br/>const action = {<br/>type: 'playlist/removeSong',<br/>payload: 'Thriller'<br/>}<br/><br/>const reducer = (state = playlistState, action) => {<br/>switch (action.type) {<br/>case 'playlist/addSong': {<br/>return [...state, action.payload];<br/>}<br/>case 'playlist/removeSong': {<br/>return state.filter(song => song !== action.payload);<br/>}<br/>}<br/>default: {<br/>return state;<br/>}<br/>};</span><br/><br/>In the above example we establish the state as our <span class="attribute">playlistState</span>. The function body then sets out the cases, in this reducer we use the actions to add a song to the playlist and then remove a song from the playlist.<br/>Once this runs our <span class="attribute">playlistState</span> should have a song called Carrion added and then another one called Thriller removed.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Immutable and Pure functions</td>
                            <td>The reducer function has some strict requirements to abide by within the Redux framework.<br/><br/>It is required to be immutable and pure.<br/><br/>This means that these functions should only calculate new states based on the arguments put into them and they should not alter the original arguments. They work by copying the state fed into it as an argument and returning the calculated new state, the original stays unaltered.<br/><br/>There should also not be any logic within the function that would randomly modify any of these input parameters nor skew the results in an uncontrolled/unexpected way. They are intended to provide pure and consistent results.<br/>This does not mean that random inputs cannot be put into them as arguments but any value that is processed through the function cannot be calculated within the function in an uncontrolled way.<br/>These functions are also not to be asynchronous. There should be no logging to the console, saving files, setting timers or fetch requests.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>The Store</td>
                            <td>The Store is a special Redux object that serves as a container for the state.<br/>It is in charge of facilitating the dispatching of actions and triggering reducer functions when actions are dispatched.<br/>In most Redux applications there is typically only one store.<br/><br/>Some important things to note about how the store works with all the other elements explainer are;<br/><br/>1 - The store initialises the state with a default value.<br/>2 - The view displays the state to the user (The view is best thought of as the UI on screen)<br/>3 - When a user interacts with the view, such as clicking a butto, an action is dispatched to the store.<br/>4 - The store's reducer combines the disptached action and the current state to determine the next stte.<br/>5 - The view is updated to display the new state.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Targetting state objects when returning</td>
                            <td>The example below shows how a state object can be copied and then individual values of that copied object can be targetted.<br/><br/><span class="attribute">const initialWagonState = {<br/>supplies: 100,<br/>distance: 0,<br/>days: 0<br/>};<br/><br/>const reducer = (state = initialWagonState, action) => {<br/>switch (action.type) {<br/>case 'gather': {<br/>return {...state,<br/>supplies: state.supplies + 15,<br/>days: state.days + 1<br/>};<br/>}<br/>case 'travel': {<br/>if (state.supplies &lt; (20 * action.payload)) {<br/>return state;<br/>}<br/>return {...state,<br/>supplies: state.supplies - (20 * action.payload),<br/>distance: state.distance + (10 * action.payload),<br/>days: state.days + action.payload<br/>};<br/>}<br/>case 'tippedWagon': {<br/>return {...state,<br/>supplies: state.supplies - 30,<br/>days: state.days + 1<br/>}<br/>}<br/>default: {<br/>return state;<br/>}<br/>}<br/>};</span><br/><br/>In the example above we copy the original state and then target individual key-value pairs and apply controlled logic to each one.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="container" id="redux_store">
                <h2>Redux Store</h2>
                <p>This section describes additional entities of the the Javascript library Redux, including notes on usages and correct syntax.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">createStore()</span></td>
                            <td>Creating a Store</td>
                            <td><span class="attribute">createStore</span> must be imported before using in our app. Example syntax is shown below;<br/><br/><span class="attribute">import { createStore } from 'redux';</span><br/><br/>The <span class="attribute">store</span> is an object within Redux that enforces one-way data flow.<br/>Its purpose is to hold the current state.<br/>It acts as the central HQ for the state of our web app by receiving actions to then execute through the reducer functions that will update the state.<br/>Its purpose can be carried out without the additional code however its best thought of as a way to control the complexity of state by providing a centralised point of contact to then look to for debugging etc.<br/><br/>With this in mind we declare a store using the <span class="attribute">createStore()</span> method imported from the redux library.<br/>The syntax for this is shown below;<br/><br/><span class="attribute">const store = createStore(reducerFunction);</span><br/><br/>Notice in the above code we declare <span class="attribute">createStore()</span> and pass in the reducer function as the argument. This is so we link the function to the store which will eventually give us the state updating functionality we're looking for.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.dispatch()</span></td>
                            <td>Dispatching actions</td>
                            <td>Once declared with <span class="attribute">createStore()</span>, the <span class="attribute">store</span> has a number of useful methods that we can make use of.<br/>The first is the <span class="attribute">.dispatch()</span> method.<br/><br/>In order to interact with the state and have it update we need to be able to dispatch actions to it.<br/>We can dispatch actions using this method appended to the store object, an example of syntax is shown below;<br/><br/><span class="attribute">store.dispatch({ type: 'some action' });</span><br/><br/>If we have actions declared within our code we can also simply enter the variable name directly as the argument, an example is shown below;<br/><br/><span class="attribute">const action = {<br/>type: 'some action'<br/>}<br/><br/>store.dispatch(action);</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.getState()</span></td>
                            <td>Getting the current state</td>
                            <td>Another method available to us once we declare <span class="attribute">createStore()</span> is the <span class="attribute">.getState()</span> method.<br/>This is called on the <span class="attribute">store</span> object and returns the state.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">store.getState();</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">actionCreator()</span></td>
                            <td>Action Creator functions</td>
                            <td>Action creator functions are essentially action objects turned into functions. The point of them is to reduce the potential for errors.<br/><br/>The way this works is that an action is declared in the function body and then when an action needs to be dispatched the function is called which in turn will return the action to the caller.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const actionCreatorFunction = () => {<br/>return { type: 'some action' };<br/>}<br/><br/>store.dispatch(actionCreatorFunction());</span><br/><br/>This reduces the amount of times an action needs to be individually typed which in turn lowers the potential for spelling mistakes and general syntax errors.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.subscribe()</span></td>
                            <td>Event listeners in Redux</td>
                            <td>In Redux actions dispatched to the <span class="attribute">store</span> can be listened for and responded to using the <span class="attribute">.subscribe()</span> method.<br/>This method only has 1 argument which is a function. This is also the "listener" that is executed in response to changes to the <span class="attribute">state</span>.<br/>A simple example of how this could work is shown below;<br/><br/><span class="attribute">const reactToChange = () => console.log('Change detected!');<br/>store.subscribe(reactToChange);</span><br/><br/>In the above example every time an action is disptached to the <span class="attribute">store</span> and a change to the <span class="attribute">state</span> happens, the function <span class="attribute">reactToChange</span> will be executed.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">unsubscribe()</span></td>
                            <td>Removing event listeners in Redux</td>
                            <td>Following on from the <span class="attribute">.subscribe()</span> method described above, this can also be removed if necessary using its own in built <span class="attribute">unsubscribe</span> function.<br/><br/>When <span class="attribute">store.subscribe(function)</span> is declared it returns an <span class="attribute">unsubscribe()</span> function as part of its declaration. We can assign this function to a variable like a normal variable to then be able to use this unsubscribe functionality if we wanted to.<br/>The syntax for this is a little confusing in terms of the declaration so an example is given below;<br/><br/><span class="attribute">const unsubscribe = store.subscribe(reactToChange);</span><br/><br/>In the above declaration we have both created the listener using the <span class="attribute">.subscribe()</span> method and in the same declaration we have assigned the returned <span class="attribute">unsubscribe()</span> function to its own variable.<br/><br/>In this example every time our state is updated we print 'Change detected!' to the console as that is the purpose of the <span class="attribute">reactToChange</span> function that is fed into the <span class="attribute">.subscribe()</span> method.<br/>Lets say we have made a number of changes and we no longer want to print to the console we can unsubscribe by calling <span class="attribute">unsubscribe();</span> this will remove the function <span class="attribute">reactToChange</span> from the <span class="attribute">store.subscribe()</span>.<br/><br/>This example is quite simple but if our subscribe function is doing something a bit more interesting or interactive, the ability to stop this and change it to something else could be quite useful.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Connecting a Redux store to a UI</td>
                            <td>Connecting a Redux store with any UI requires a few consistent steps, regardless of how the UI is implemented:<br/><br/>1 - Create a Redux store<br/>2 - Render the initial state of the application.<br/>3 - Subscribe to updates. Inside the subscription callback:<br/>4 - Get the current store state<br/>5 - Select the data needed by this piece of UI<br/>6 - Update the UI with the data<br/>7 - Respond to UI events by dispatching Redux actions<br/><br/>An example of a very simple App showing the syntax is described below;<br/><br/>The below is located in index.js<br/><br/><span class="attribute">import React from "react";<br/>import { createRoot } from "react-dom/client";<br/>import App from "./App.js"<br/>import { store } from "./store.js"<br/><br/>const root = createRoot(document.getElementById("app"));<br/><br/>const render = () => {<br/>root.render(&lt;App state={store.getState()} dispatch={store.dispatch} />&gt;;<br/>}<br/><br/>store.subscribe(render);<br/><br/>render();</span><br/><br/>The below is Located in App.js<br/><br/><span class="attribute">import React from "react";<br/>import { increment, decrement } from "./store";<br/><br/>function App({ state, dispatch}) {<br/><br/>const incrementerClicked = () => {<br/>dispatch(increment());<br/>}<br/><br/>const decrementerClicked = () => {<br/>dispatch(decrement());<br/>}<br/><br/>return(<br/>&lt;main&gt;<br/>&lt;p id='counter'&gt;{state}&lt;/p&gt;<br/>&lt;button id='incrementer' onClick={incrementerClicked}&gt;+&lt;/button&gt;<br/>&lt;button id='decrementer' onClick={decrementerClicked}&gt;-&lt;/button&gt;<br/>&lt;/main&gt;<br/>)<br/>}<br/><br/>export default App;</span><br/><br/>The below is located in store.js<br/><br/><span class="attribute">import { createStore } from 'redux';<br/><br/>export function increment() {<br/>return {type: 'increment'}<br/>}<br/><br/>export function decrement() {<br/>return {type: 'decrement'}<br/>}<br/><br/>const initialState = 0;<br/>const countReducer = (state = initialState, action) => {<br/>switch (action.type) {<br/>case 'increment':<br/>return state + 1;<br/>case 'decrement':<br/>return state - 1; <br/>default:<br/>return state;<br/>}<br/>};<br/><br/>export const store = createStore(countReducer);</span><br/><br/></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="container" id="redux_slices">
                <h2>Redux Slices</h2>
                <p>This section describes additional entities of the the Javascript library Redux, including notes on usages and correct syntax.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td></td>
                            <td>Slices</td>
                            <td>In previous examples of Redux syntax we have been managing state within a single object. There would be various key-value pairings which each could have their own nested key-value pairings containing values, objects and arrays.<br/>An example of a fairly simple state hierarchy with nesting is shown below;<br/><br/><span class="attribute">state = {<br/>todos: [<br/>{<br/>id: 0,<br/>text: 'Complete the Learn Redux course',<br/>isCompleted: false<br/>},<br/>{<br/>id: 1,<br/>text: 'Build a counter app',<br/>isCompleted: true<br/>},<br/>],<br/>visibilityFilter: 'SHOW_INCOMPLETE'<br/>};</span><br/><br/>Redux is good for managing complex states but in order to do this it works on a similar principle to that of components when building Apps in React.<br/>Each different state can be broken down into its own component, separated out, managed and then recombined later on to provide easier management and debugging.<br/><br/>When these states are separated out, each individual one is called a <span class="attribute">slice</span> and typically a <span class="attribute">slice</span> represents a different feature of the app.<br/>With this in mind, our example above shows that we potentially have 2 different slices contained within our <span class="attribute">state</span> object;<br/>We have the <span class="attribute">todos</span> array that contains 2 separate objects.<br/>We also have the <span class="attribute">visibilityFilter</span> which is a string value.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Best practice for slices</td>
                            <td>When separating out slices it is best practice to establish an initial state for each slice. Each slice will have its own reducer and as such the reducer will need a default state to use when being updated.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Naming conventions for actions</td>
                            <td>When an application state has multiple slices, individual actions typically only change one slice at a time. Therefore, it is recommended that each actionâ€™s <span class="attribute">type</span> follows the pattern <span class="attribute">'sliceName/actionDescriptor'</span>, to clarify which slice of state should be updated.<br/><br/>An example of this is shown below;<br/><br/><span class="attribute">export const setSearchTerm = (term) => {<br/>return {<br/>type: 'searchTerm/setSearchTerm',<br/>payload: term<br/>};<br/>}<br/><br/>export const loadData = () => {<br/>return {<br/>type: 'allRecipes/loadData',<br/>payload: allRecipesData<br/>}<br/>}</span><br/><br/>In the above examples we have 2 different action creator functions that are dispatching actions to separate slices. Notice how each action <span class="attribute">type</span> follows the naming convention of what slice it is for and then what the action is doing.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Creating individual reducers for each slice</td>
                            <td>In complex Apps that require numerous different states, all the states created for the App are seperate individual slices. These are then managed by their own reducer functions to provide updates to each individual state.<br/><br/>So for example if we use the 2 actions above as a guide we can see that we have 2 seperate slices (<span class="attribute">searchTerm</span> & <span class="attribute">allRecipes</span>) due to Redux naming conventions.<br/><br/>In complex Apps with a number of states each state may be seperated out into individual files (much like components in React) and then imported back into the Store file later one.<br/>Within each of those files we would need to have a separate reducer function that manages that particular state.<br/>So using <span class="attribute">searchTerm</span> as an example we might have a file called <span class="code">searchTermSlice.js</span> and in that file we could have the following;<br/><br/><span class="attribute">const initialSearchTerm = '';<br/><br/>export const searchTermReducer = (searchTerm = initialSearchTerm, action) => {<br/>switch(action.type) {<br/>case 'searchTerm/setSearchTerm':<br/>return action.payload;<br/>case 'searchTerm/clearSearchTerm':<br/>return '';<br/>default:<br/>return searchTerm;<br/>}<br/>}</span><br/><br/>So in the example above we have an <span class="attribute">initialState</span> defined to give our reducer function a default state. Then we have a reducer function that handles the logic for updating/amending the state.<br/><br/>This convention provides a greater level of clarity to code readability and simplicity when debugging specifically concerning state because we know that we only have 1 state to worry about in this instance and when we encounter bugs we can deal with them individually.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">rootReducer</span></td>
                            <td>Combining seperate states into one object</td>
                            <td>At its core a <span class="attribute">rootReducer</span> function is not a special additional method created as part of the Redux library, it is simply a plain Javascript function that combines all the other states back into a single object.<br/><br/>Having all states seperate means they need to be combined into a single object so they can be fed into the <span class="attribute">store</span> as this only accepts a single object as state.<br/>This is where we use the <span class="attribute">rootReducer</span> function.<br/><br/>So within our file system we may have numerous slice files (e.g. <span class="code">searchTermSlice.js</span> & <span class="code">allRecipesSlice.js</span>), each with a separate slice and its related reducer function (These are usually bundled into the same file folder as the React component they are managing).<br/><br/>We then must have a <span class="code">store.js</span> file that is our <span class="attribute">store</span>. Within this file we import all of our states, so again using the 2 examples above we will import <span class="attribute">searchTermReducer</span> from <span class="code">searchTermSlice.js</span> & <span class="attribute">allRecipesReducer</span> from <span class="code">allRecipesSlice.js</span>.<br/>We then define our <span class="attribute">rootReducer</span> function to combine them all into a single object and feed that into the store.<br/>Example syntax is shown below;<br/><br/><span class="attribute">const rootReducer = (state = {}, action) => {<br/>const nextState = {<br/>allRecipes: allRecipesReducer(state.allRecipes, action),<br/>searchTerm: searchTermReducer(state.searchTerm, action),<br/>}<br/>return nextState;<br/>}<br/><br/>export const store = createStore(rootReducer);</span><br/><br/>Notice how <span class="attribute">rootReducer</span> returns a <span class="attribute">nextState</span> object.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">combineReducers()</span></td>
                            <td>Combining seperate states into one object</td>
                            <td><span class="attribute">combineReducers()</span> is basically a utility function in the Redux library that does everything a <span class="attribute">rootReducer</span> function would do but with simpler syntax.<br/>It should be imported into the file in the usual way;<br/><br/><span class="attribute">import { combineReducers } from 'redux';</span><br/><br/>It can be declared as a const variable if needed but it can also be passed directly in the <span class="attribute">createStore()</span> method.<br/>Both syntax variations are shown below;<br/><br/><span class="attribute">const reducers = {<br/>searchTerm: searchTermReducer,<br/>allRecipes: allRecipesReducer<br/>};<br/><br/>const rootReducer = combineReducers(reducers);<br/>const store = createStore(rootReducer);</span><br/><br/>The above example is the long hand version.<br/><br/><span class="attribute">const reducers = {<br/>searchTerm: searchTermReducer,<br/>allRecipes: allRecipesReducer<br/>};<br/><br/>const store = createStore(combineReducers(reducers));</span><br/><br/>The code above shows how the syntax can be reformatted to remove the additional declaration of <span class="attribute">rootReducer</span>.<br/><br/><span class="attribute">const store = createStore(combineReducers({<br/>searchTerm: searchTermReducer,<br/>allRecipes: allRecipesReducer<br/>}));</span><br/><br/>This final block shows how it can be formatted to the minimal amount of code.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Passing Store data as props</td>
                            <td>The store is managing the state of our app therefore we need to pass its information down every relevant level of our app through props so it can effectively communicate up and down the tree.<br/>Example syntax showing how the boilerplate for how this is down is shown below in example <span class="code">index.js</span> and <span class="code">app.js</span> files.<br/><br/><span class="attribute">import React from 'react';<br/>import { createRoot } from 'react-dom/client';<br/>import {store} from './app/store.js';<br/>import { App } from './app/App.js';<br/><br/>const root = createRoot(document.getElementById('root'));<br/>const render = () => {<br/>root.render(<br/></span><span class="code">&lt;App<br/>state=</span><span class="attribute">{store.getState()}</span><span class="code"><br/>dispatch=</span><span class="attribute">{store.dispatch}</span><span class="code"><br/>/&gt;</span><span class="attribute">,<br/>)<br/>}<br/><br/>store.subscribe(render);<br/>render();</span><br/><br/>The code above shows the <span class="code">index.js</span> file.<br/>In this file we import the <span class="attribute">store</span> and then use it within the attributes we are passing down to <span class="code">&lt;App /&gt;</span> so that we get the functionality of getting the current state as well as the ability to dispatch actions down the tree.<br/>Notice that at the bottom we also <span class="attribute">subscribe</span> the <span class="attribute">render</span> action so that everytime the state changes the entire <span class="code">&lt;App /&gt;</span> will be re-rendered<br/><br/><span class="attribute">import React from 'react';<br/><br/>import { AllRecipes } from '../features/allRecipes/AllRecipes.js';<br/>import { SearchTerm } from '../features/searchTerm/SearchTerm.js';<br/><br/>export function App(props) {<br/>const {state, dispatch} = props;<br/><br/>const visibleAllRecipes = getFilteredRecipes(state.allRecipes, state.searchTerm);<br/><br/>return (</span><span class="code"><br/>&lt;main&gt;<br/>&lt;section&gt;<br/>&lt;SearchTerm<br/>searchTerm=</span><span class="attribute">{state.searchTerm}</span><span class="code"><br/>dispatch=</span><span class="attribute">{dispatch}</span><span class="code"><br/>/&gt;<br/>&lt;/section&gt;<br/>&lt;section&gt;<br/>&lt;h2&gt;All Recipes&lt;/h2&gt;<br/>&lt;AllRecipes<br/>allRecipes=</span><span class="attribute">{visibleAllRecipes}</span><span class="code"><br/>dispatch=</span><span class="attribute">{dispatch}</span><span class="code"><br/>/&gt;<br/>&lt;/section&gt;<br/>&lt;/main&gt;</span><span class="attribute"><br/>)<br/>}<br/><br/>/* Utility Helpers */<br/>function getFilteredRecipes(recipes, searchTerm) {<br/>return recipes.filter(recipe => recipe.name.toLowerCase().includes(searchTerm.toLowerCase()));<br/>}</span><br/><br/>The code above shows the <span class="code">app.js</span> file.<br/>In this file we extract the <span class="attribute">state</span> object & <span class="attribute">dispatch</span> method from the <span class="attribute">props</span> being sent down from <span class="code">index.js</span>.<br/>(The <span class="attribute">dispatch</span> method in-built to <span class="attribute">store</span> allows us to send actions to the reducers to update/amend state. Now that its extracted, <span class="attribute">dispatch</span> is the same as <span class="attribute">store.dispatch()</span> and can have arguments passed into it i.e. actions so in the next file we use it as a prefix to handleSubmit or handleChange type functions to dispatch whatever action they're doing to the state.)<br/><br/><span class="attribute">import React from 'react';<br/>const searchIconUrl = './search.svg'<br/>const clearIconUrl = './clear.svg'<br/><br/>import { setSearchTerm, clearSearchTerm } from './searchTermSlice.js';<br/><br/>export const SearchTerm = (props) => {<br/><br/>const { searchTerm, dispatch } = props;<br/><br/>const onSearchTermChangeHandler = (e) => {<br/>const userInput = e.target.value;<br/>dispatch(setSearchTerm(userInput));<br/>};<br/><br/>const onClearSearchTermHandler = () => {<br/>dispatch(clearSearchTerm());<br/>};<br/><br/>return (<br/></span><span class="code">&lt;div id="search-container"&gt;<br/>&lt;img id="search-icon" alt="" src=</span><span class="attribute">{searchIconUrl}</span><span class="code"> /&gt;<br/>&lt;input<br/>id="search"<br/>type="text"<br/>value=</span><span class="attribute">{searchTerm}</span><span class="code"><br/>onChange=</span><span class="attribute">{onSearchTermChangeHandler}</span><span class="code"><br/>placeholder="Search recipes"<br/>/&gt;<br/></span><span class="attribute">{searchTerm.length > 0 && (<br/>&lt;button<br/>onClick={onClearSearchTermHandler}<br/>type="button"<br/>id="search-clear-button"<br/>&gt;<br/>&lt;img src={clearIconUrl} alt="" /&gt;<br/>&lt;/button&gt;<br/>)}</span><span class="code"><br/>&lt;/div&gt;</span><span class="attribute"><br/>);<br/>};</span><br/><br/>The code above shows the <span class="code">searchTerm.js</span> file.<br/>Notice how in this file we're importing <span class="attribute">setSearchTerm</span>, which is a <span class="attribute">setState()</span> style functions from <span class="code">searchTermSlice.js</span> instead of using the actual <span class="attribute">useState()</span> from React. This is because now that we're managing state through Redux conventions we have reformatted some of the code for such complex state management and the equivalent <span class="attribute">setState()</span> functions are now <span class="attribute">actionCreatorFunctions</span> that are kept in <span class="code">searchTermSlice.js</span>.<br/><br/>Another thing to notice is that now in the handler functions we're prefixing each main function body call with the <span class="attribute">dispatch</span> method that we have extracted after its been passed down via <span class="attribute">props</span>. This is because using <span class="attribute">dispatch</span> sends information back up the tree into the <span class="attribute">store</span> and updates the <span class="attribute">state</span>.<br/>This works in basically the same way as a similar <span class="attribute">handleSubmit</span> style function in React. In Redux however we need to add in this communication due to how state is being managed now.<br/><br/><span class="attribute">const initialState = ''<br/><br/>export const searchTermReducer = (state = initialState, action) => {<br/>switch (action.type) {<br/>case 'searchTerm/setSearchTerm':<br/>return action.payload;<br/>case 'searchTerm/clearSearchTerm':<br/>return '';<br/>default:<br/>return state;<br/>}<br/>}<br/><br/>export function setSearchTerm(term) {<br/>return {<br/>type: 'searchTerm/setSearchTerm',<br/>payload: term<br/>}<br/>}<br/><br/>export function clearSearchTerm() {<br/>return {<br/>type: 'searchTerm/clearSearchTerm'<br/>}<br/>}</span><br/><br/>The above code shows the <span class="code">searchTermSlice.js</span> file.<br/>Instead of the React style <span class="attribute">useState()</span> you can see in this file we define and ultimately use <span class="attribute">actionCreatorFunctions</span> to set state by dispatching actions.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>For additional tags and examples see the <a href="https://redux.js.org/" target="_blank">Redux Website</a> for more info.</p>
        </div>
    </body>
    <footer>

    </footer>
</html>