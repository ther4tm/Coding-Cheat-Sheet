<!DOCTYPE html>
<html>
    <head>
        <title>Redux Cheat Sheet</title>
        <link href="./resources/css/index.css" type="text/css" rel="stylesheet">
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link rel="preconnect" href="https://fonts.googleapis.com">
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
    </head>
    <body>
        <header>
            <nav>
                <ul>
                    <li><a href="./htmlcheatsheet.html">HTML</a></li>
                    <li><a href="./csscheatsheet.html">CSS</a></li>
                    <li><a href="./commandlinecheatsheet.html">Command Line</a></li>
                    <li><a href="./javascriptcheatsheet.html">JavaScript</a></li>
                    <li><a href="./reactcheatsheet.html">React</a></li>
                    <li><a href="./reduxcheatsheet.html">Redux</a></li>
                    <li><a href="./markdowncheatsheet.html">Markdown</a></li>
                    <li><a href="./styleguide.html">Style Guide</a></li>
                </ul>
            </nav>
        </header>
        <div class="content">
            <h1>Redux Cheat Sheet</h1>
            <p>Below is a brief list of fundamental Redux tags/expressions and syntax including a brief description of what they do and any notes on correct syntax.</p>
            <div class="container" id="redux_introduction">
                <h2>Redux Introduction</h2>
                <p>This section describes the Javascript library Redux, how to use it and the core principles it embodies including notes on usages and correct syntax.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Redux</td>
                            <td>Core principles</td>
                            <td>Redux is a method of managing state throughout web apps. It is perhaps best thought of as the main HQ for the state in your entire web app.<br/><br/>Before implementing Redux, a React web app can be built from numerous different components, some may have their own states and some may be stateless, however there is no centralised HQ for state.<br/>This is what Redux provides.<br/><br/>In addition to this Redux insists on a system based on a pure separation of concerns when it comes to state. This means that functions that process elements of state should be written to have no additional effect on the input. This ensures that the results are always consistent and the function has no additional logic to change the result other than calculation of its input.<br/>The best analogy for this is that of a cassette player. The player is consistent and will only play the songs present on the inserted cassette.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Importing Redux elements</td>
                            <td>The Redux library must be imported like other methods and components before using in our app. Example syntax is shown below;<br/><br/><span class="attribute">import {  } from 'redux';</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">action</span></td>
                            <td>Action keyword</td>
                            <td>In Redux state is managed through actions.<br/><br/>If we follow on with our cassette player analogy, the player itself is a function that we will describe later however, actions are best thought of as different tapes that can be inserted into the player to tell it what song to play.<br/><br/>An action is written as a plain Javacsript object.<br/>Every action has a <span class="attribute">type</span> property with a string value. This string is a description of the action.<br/>Actions can also have a secondary key-value called <span class="attribute">payload</span>. This contains any additional information related to the action.<br/><br/>In the examples below we are interacting with an array that represents the state for a spotify playlist.<br/><br/><span class="attribute">const action = {<br/>type: 'playlist/addSong',<br/>payload: 'Carrion'<br/>};</span><br/><br/>In the above action we are adding a song to the array so our action description is <span class="attribute">'playlist/addSong'</span>. It tells us in very simple terms <span class="attribute">playlist</span> is the state target and <span class="attribute">addSong</span> is the action. It then also tells us what song to add in the <span class="attribute">payload</span>, we are adding a song called <span class="attribute">Carrion</span>.<br/><br/><span class="attribute">const action = {<br/>type: 'playlist/removeSong',<br/>payload: 'Thriller'<br/>}</span><br/><br/>In this action we are removing the song <span class="attribute">Thriller</span> from the playlist<br/><br/><span class="attribute">const action = {<br/>type: 'playlist/removeAll'<br/>}</span><br/><br/>Finally, notice how this action does not have a <span class="attribute">payload</span> because its purpose it to remove everything from the state in contrast to the previous removal action where it is removing a specific item described in the <span class="attribute">payload</span>.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">reducer</span></td>
                            <td>Reducer function</td>
                            <td>The reducer function is the cassette player in Redux.<br/><br/>Due to the way i operates and the intentions behind its operation, there are a few additional notes that apply to all reducers that need to be explained before moving on any further.<br/><br/>It is a plain javascript function that defines how the current state and an action are used in combination to create a new state.<br/>It defines the applications next state, given a current state and a specific action.<br/>It returns a default initial state if no action is provided.<br/>It returns the current state if the action is not recognized.<br/><br/>A reducer function accepts 2 arguments these are <span class="attribute">state</span> and <span class="attribute">action</span>.<br/>The rest of the function looks very similar to a <span class="attribute">switch</span> and <span class="attribute">case</span> conditional expression.<br/>The <span class="attribute">state</span> argument is written in an unusual way, although it is an argument it is written as though its a variable declaration.<br/>A couple of different options of how this could be written are shown below to give this some context;<br/><br/><span class="attribute">const someOtherState = [];<br/><br/>const reducer = (state = someOtherState, action) => {<br/></span><span class="code">//function body</span><span class="attribute"><br/>}</span><br/>OR<br/><span class="attribute">const reducer = (state = [], action) => {<br/></span><span class="code">//function body</span><span class="attribute"><br/>}</span><br/><br/>The reason for writing the function in this way is that it initialises the state parameter of the function with a default value. So based on the added notes above about how reducer functions work, we need to give the state a default value in the event that the action is not recognized or no action is provided so that a state can, and will, be provided no matter what.<br/>The rest of the function body is written in an almost identical fashion to a <span class="attribute">switch</span> and <span class="attribute">case</span> expression.<br/><br/>An example using the playlist actions from above is shown below, in this example we have declared an initial state called <span class="attribute">playlistState</span> as an array containing 1 item.<br/><br/><span class="attribute">const playlistState = ['Thriller'];<br/><br/>const action = {<br/>type: 'playlist/addSong',<br/>payload: 'Carrion'<br/>}<br/><br/>const action = {<br/>type: 'playlist/removeSong',<br/>payload: 'Thriller'<br/>}<br/><br/>const reducer = (state = playlistState, action) => {<br/>switch (action.type) {<br/>case 'playlist/addSong': {<br/>return [...state, action.payload];<br/>}<br/>case 'playlist/removeSong': {<br/>return state.filter(song => song !== action.payload);<br/>}<br/>}<br/>default: {<br/>return state;<br/>}<br/>};</span><br/><br/>In the above example we establish the state as our <span class="attribute">playlistState</span>. The function body then sets out the cases, in this reducer we use the actions to add a song to the playlist and then remove a song from the playlist.<br/>Once this runs our <span class="attribute">playlistState</span> should have a song called Carrion added and then another one called Thriller removed.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Immutable and Pure functions</td>
                            <td>The reducer function has some strict requirements to abide by within the Redux framework.<br/><br/>It is required to be immutable and pure.<br/><br/>This means that these functions should only calculate new states based on the arguments put into them and they should not alter the original arguments. They work by copying the state fed into it as an argument and returning the calculated new state, the original stays unaltered.<br/><br/>There should also not be any logic within the function that would randomly modify any of these input parameters nor skew the results in an uncontrolled/unexpected way. They are intended to provide pure and consistent results.<br/>This does not mean that random inputs cannot be put into them as arguments but any value that is processed through the function cannot be calculated within the function in an uncontrolled way.<br/>These functions are also not to be asynchronous. There should be no logging to the console, saving files, setting timers or fetch requests.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>The Store</td>
                            <td>The Store is a special Redux object that serves as a container for the state.<br/>It is in charge of facilitating the dispatching of actions and triggering reducer functions when actions are dispatched.<br/>In most Redux applications there is typically only one store.<br/><br/>Some important things to note about how the store works with all the other elements explainer are;<br/><br/>1 - The store initialises the state with a default value.<br/>2 - The view displays the state to the user (The view is best thought of as the UI on screen)<br/>3 - When a user interacts with the view, such as clicking a butto, an action is dispatched to the store.<br/>4 - The store's reducer combines the disptached action and the current state to determine the next stte.<br/>5 - The view is updated to display the new state.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Targetting state objects when returning</td>
                            <td>The example below shows how a state object can be copied and then individual values of that copied object can be targetted.<br/><br/><span class="attribute">const initialWagonState = {<br/>supplies: 100,<br/>distance: 0,<br/>days: 0<br/>};<br/><br/>const reducer = (state = initialWagonState, action) => {<br/>switch (action.type) {<br/>case 'gather': {<br/>return {...state,<br/>supplies: state.supplies + 15,<br/>days: state.days + 1<br/>};<br/>}<br/>case 'travel': {<br/>if (state.supplies &lt; (20 * action.payload)) {<br/>return state;<br/>}<br/>return {...state,<br/>supplies: state.supplies - (20 * action.payload),<br/>distance: state.distance + (10 * action.payload),<br/>days: state.days + action.payload<br/>};<br/>}<br/>case 'tippedWagon': {<br/>return {...state,<br/>supplies: state.supplies - 30,<br/>days: state.days + 1<br/>}<br/>}<br/>default: {<br/>return state;<br/>}<br/>}<br/>};</span><br/><br/>In the example above we copy the original state and then target individual key-value pairs and apply controlled logic to each one.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="container" id="store">
                <h2>Store</h2>
                <p>This section describes principles of the Store within Redux, including notes on usages and correct syntax.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">createStore()</span></td>
                            <td>Creating a Store</td>
                            <td><span class="attribute">createStore</span> must be imported before using in our app. Example syntax is shown below;<br/><br/><span class="attribute">import { createStore } from 'redux';</span><br/><br/>The <span class="attribute">store</span> is an object within Redux that enforces one-way data flow.<br/>Its purpose is to hold the current state.<br/>It acts as the central HQ for the state of our web app by receiving actions to then execute through the reducer functions that will update the state.<br/>Its purpose can be carried out without the additional code however its best thought of as a way to control the complexity of state by providing a centralised point of contact to then look to for debugging etc.<br/><br/>With this in mind we declare a store using the <span class="attribute">createStore()</span> method imported from the redux library.<br/>The syntax for this is shown below;<br/><br/><span class="attribute">const store = createStore(reducerFunction);</span><br/><br/>Notice in the above code we declare <span class="attribute">createStore()</span> and pass in the reducer function as the argument. This is so we link the function to the store which will eventually give us the state updating functionality we're looking for.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.dispatch()</span></td>
                            <td>Dispatching actions</td>
                            <td>Once declared with <span class="attribute">createStore()</span>, the <span class="attribute">store</span> has a number of useful methods that we can make use of.<br/>The first is the <span class="attribute">.dispatch()</span> method.<br/><br/>In order to interact with the state and have it update we need to be able to dispatch actions to it.<br/>We can dispatch actions using this method appended to the store object, an example of syntax is shown below;<br/><br/><span class="attribute">store.dispatch({ type: 'some action' });</span><br/><br/>If we have actions declared within our code we can also simply enter the variable name directly as the argument, an example is shown below;<br/><br/><span class="attribute">const action = {<br/>type: 'some action'<br/>}<br/><br/>store.dispatch(action);</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.getState()</span></td>
                            <td>Getting the current state</td>
                            <td>Another method available to us once we declare <span class="attribute">createStore()</span> is the <span class="attribute">.getState()</span> method.<br/>This is called on the <span class="attribute">store</span> object and returns the state.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">store.getState();</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">actionCreator()</span></td>
                            <td>Action Creator functions</td>
                            <td>Action creator functions are essentially action objects turned into functions. The point of them is to reduce the potential for errors.<br/><br/>The way this works is that an action is declared in the function body and then when an action needs to be dispatched the function is called which in turn will return the action to the caller.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const actionCreatorFunction = () => {<br/>return { type: 'some action' };<br/>}<br/><br/>store.dispatch(actionCreatorFunction());</span><br/><br/>This reduces the amount of times an action needs to be individually typed which in turn lowers the potential for spelling mistakes and general syntax errors.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.subscribe()</span></td>
                            <td>Event listeners in Redux</td>
                            <td>In Redux actions dispatched to the <span class="attribute">store</span> can be listened for and responded to using the <span class="attribute">.subscribe()</span> method.<br/>This method only has 1 argument which is a function. This is also the "listener" that is executed in response to changes to the <span class="attribute">state</span>.<br/>A simple example of how this could work is shown below;<br/><br/><span class="attribute">const reactToChange = () => console.log('Change detected!');<br/>store.subscribe(reactToChange);</span><br/><br/>In the above example every time an action is disptached to the <span class="attribute">store</span> and a change to the <span class="attribute">state</span> happens, the function <span class="attribute">reactToChange</span> will be executed.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">unsubscribe()</span></td>
                            <td>Removing event listeners in Redux</td>
                            <td>Following on from the <span class="attribute">.subscribe()</span> method described above, this can also be removed if necessary using its own in built <span class="attribute">unsubscribe</span> function.<br/><br/>When <span class="attribute">store.subscribe(function)</span> is declared it returns an <span class="attribute">unsubscribe()</span> function as part of its declaration. We can assign this function to a variable like a normal variable to then be able to use this unsubscribe functionality if we wanted to.<br/>The syntax for this is a little confusing in terms of the declaration so an example is given below;<br/><br/><span class="attribute">const unsubscribe = store.subscribe(reactToChange);</span><br/><br/>In the above declaration we have both created the listener using the <span class="attribute">.subscribe()</span> method and in the same declaration we have assigned the returned <span class="attribute">unsubscribe()</span> function to its own variable.<br/><br/>In this example every time our state is updated we print 'Change detected!' to the console as that is the purpose of the <span class="attribute">reactToChange</span> function that is fed into the <span class="attribute">.subscribe()</span> method.<br/>Lets say we have made a number of changes and we no longer want to print to the console we can unsubscribe by calling <span class="attribute">unsubscribe();</span> this will remove the function <span class="attribute">reactToChange</span> from the <span class="attribute">store.subscribe()</span>.<br/><br/>This example is quite simple but if our subscribe function is doing something a bit more interesting or interactive, the ability to stop this and change it to something else could be quite useful.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Connecting a Redux store to a UI</td>
                            <td>Connecting a Redux store with any UI requires a few consistent steps, regardless of how the UI is implemented:<br/><br/>1 - Create a Redux store<br/>2 - Render the initial state of the application.<br/>3 - Subscribe to updates. Inside the subscription callback:<br/>4 - Get the current store state<br/>5 - Select the data needed by this piece of UI<br/>6 - Update the UI with the data<br/>7 - Respond to UI events by dispatching Redux actions<br/><br/>An example of a very simple App showing the syntax is described below;<br/><br/>The below is located in index.js<br/><br/><span class="attribute">import React from "react";<br/>import { createRoot } from "react-dom/client";<br/>import App from "./App.js"<br/>import { store } from "./store.js"<br/><br/>const root = createRoot(document.getElementById("app"));<br/><br/>const render = () => {<br/>root.render(&lt;App state={store.getState()} dispatch={store.dispatch} />&gt;;<br/>}<br/><br/>store.subscribe(render);<br/><br/>render();</span><br/><br/>The below is Located in App.js<br/><br/><span class="attribute">import React from "react";<br/>import { increment, decrement } from "./store";<br/><br/>function App({ state, dispatch}) {<br/><br/>const incrementerClicked = () => {<br/>dispatch(increment());<br/>}<br/><br/>const decrementerClicked = () => {<br/>dispatch(decrement());<br/>}<br/><br/>return(<br/>&lt;main&gt;<br/>&lt;p id='counter'&gt;{state}&lt;/p&gt;<br/>&lt;button id='incrementer' onClick={incrementerClicked}&gt;+&lt;/button&gt;<br/>&lt;button id='decrementer' onClick={decrementerClicked}&gt;-&lt;/button&gt;<br/>&lt;/main&gt;<br/>)<br/>}<br/><br/>export default App;</span><br/><br/>The below is located in store.js<br/><br/><span class="attribute">import { createStore } from 'redux';<br/><br/>export function increment() {<br/>return {type: 'increment'}<br/>}<br/><br/>export function decrement() {<br/>return {type: 'decrement'}<br/>}<br/><br/>const initialState = 0;<br/>const countReducer = (state = initialState, action) => {<br/>switch (action.type) {<br/>case 'increment':<br/>return state + 1;<br/>case 'decrement':<br/>return state - 1; <br/>default:<br/>return state;<br/>}<br/>};<br/><br/>export const store = createStore(countReducer);</span><br/><br/></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="container" id="slices">
                <h2>Slices</h2>
                <p>This section describes principles of Slices within Redux, including notes on usages and correct syntax.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td></td>
                            <td>Slices</td>
                            <td>In previous examples of Redux syntax we have been managing state within a single object. There would be various key-value pairings which each could have their own nested key-value pairings containing values, objects and arrays.<br/>An example of a fairly simple state hierarchy with nesting is shown below;<br/><br/><span class="attribute">state = {<br/>todos: [<br/>{<br/>id: 0,<br/>text: 'Complete the Learn Redux course',<br/>isCompleted: false<br/>},<br/>{<br/>id: 1,<br/>text: 'Build a counter app',<br/>isCompleted: true<br/>},<br/>],<br/>visibilityFilter: 'SHOW_INCOMPLETE'<br/>};</span><br/><br/>Redux is good for managing complex states but in order to do this it works on a similar principle to that of components when building Apps in React.<br/>Each different state can be broken down into its own component, separated out, managed and then recombined later on to provide easier management and debugging.<br/><br/>When these states are separated out, each individual one is called a <span class="attribute">slice</span> and typically a <span class="attribute">slice</span> represents a different feature of the app.<br/>With this in mind, our example above shows that we potentially have 2 different slices contained within our <span class="attribute">state</span> object;<br/>We have the <span class="attribute">todos</span> array that contains 2 separate objects.<br/>We also have the <span class="attribute">visibilityFilter</span> which is a string value.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Best practice for slices</td>
                            <td>When separating out slices it is best practice to establish an initial state for each slice. Each slice will have its own reducer and as such the reducer will need a default state to use when being updated.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Naming conventions for actions</td>
                            <td>When an application state has multiple slices, individual actions typically only change one slice at a time. Therefore, it is recommended that each action’s <span class="attribute">type</span> follows the pattern <span class="attribute">'sliceName/actionDescriptor'</span>, to clarify which slice of state should be updated.<br/><br/>An example of this is shown below;<br/><br/><span class="attribute">export const setSearchTerm = (term) => {<br/>return {<br/>type: 'searchTerm/setSearchTerm',<br/>payload: term<br/>};<br/>}<br/><br/>export const loadData = () => {<br/>return {<br/>type: 'allRecipes/loadData',<br/>payload: allRecipesData<br/>}<br/>}</span><br/><br/>In the above examples we have 2 different action creator functions that are dispatching actions to separate slices. Notice how each action <span class="attribute">type</span> follows the naming convention of what slice it is for and then what the action is doing.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Creating individual reducers for each slice</td>
                            <td>In complex Apps that require numerous different states, all the states created for the App are seperate individual slices. These are then managed by their own reducer functions to provide updates to each individual state.<br/><br/>So for example if we use the 2 actions above as a guide we can see that we have 2 seperate slices (<span class="attribute">searchTerm</span> & <span class="attribute">allRecipes</span>) due to Redux naming conventions.<br/><br/>In complex Apps with a number of states each state may be seperated out into individual files (much like components in React) and then imported back into the Store file later one.<br/>Within each of those files we would need to have a separate reducer function that manages that particular state.<br/>So using <span class="attribute">searchTerm</span> as an example we might have a file called <span class="code">searchTermSlice.js</span> and in that file we could have the following;<br/><br/><span class="attribute">const initialSearchTerm = '';<br/><br/>export const searchTermReducer = (searchTerm = initialSearchTerm, action) => {<br/>switch(action.type) {<br/>case 'searchTerm/setSearchTerm':<br/>return action.payload;<br/>case 'searchTerm/clearSearchTerm':<br/>return '';<br/>default:<br/>return searchTerm;<br/>}<br/>}</span><br/><br/>So in the example above we have an <span class="attribute">initialState</span> defined to give our reducer function a default state. Then we have a reducer function that handles the logic for updating/amending the state.<br/><br/>This convention provides a greater level of clarity to code readability and simplicity when debugging specifically concerning state because we know that we only have 1 state to worry about in this instance and when we encounter bugs we can deal with them individually.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">rootReducer</span></td>
                            <td>Combining seperate states into one object</td>
                            <td>At its core a <span class="attribute">rootReducer</span> function is not a special additional method created as part of the Redux library, it is simply a plain Javascript function that combines all the other states back into a single object.<br/><br/>Having all states seperate means they need to be combined into a single object so they can be fed into the <span class="attribute">store</span> as this only accepts a single object as state.<br/>This is where we use the <span class="attribute">rootReducer</span> function.<br/><br/>So within our file system we may have numerous slice files (e.g. <span class="code">searchTermSlice.js</span> & <span class="code">allRecipesSlice.js</span>), each with a separate slice and its related reducer function (These are usually bundled into the same file folder as the React component they are managing).<br/><br/>We then must have a <span class="code">store.js</span> file that is our <span class="attribute">store</span>. Within this file we import all of our states, so again using the 2 examples above we will import <span class="attribute">searchTermReducer</span> from <span class="code">searchTermSlice.js</span> & <span class="attribute">allRecipesReducer</span> from <span class="code">allRecipesSlice.js</span>.<br/>We then define our <span class="attribute">rootReducer</span> function to combine them all into a single object and feed that into the store.<br/>Example syntax is shown below;<br/><br/><span class="attribute">const rootReducer = (state = {}, action) => {<br/>const nextState = {<br/>allRecipes: allRecipesReducer(state.allRecipes, action),<br/>searchTerm: searchTermReducer(state.searchTerm, action),<br/>}<br/>return nextState;<br/>}<br/><br/>export const store = createStore(rootReducer);</span><br/><br/>Notice how <span class="attribute">rootReducer</span> returns a <span class="attribute">nextState</span> object.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">combineReducers()</span></td>
                            <td>Combining seperate states into one object</td>
                            <td><span class="attribute">combineReducers()</span> is basically a utility function in the Redux library that does everything a <span class="attribute">rootReducer</span> function would do but with simpler syntax.<br/>It should be imported into the file in the usual way;<br/><br/><span class="attribute">import { combineReducers } from 'redux';</span><br/><br/>It can be declared as a const variable if needed but it can also be passed directly in the <span class="attribute">createStore()</span> method.<br/>Both syntax variations are shown below;<br/><br/><span class="attribute">const reducers = {<br/>searchTerm: searchTermReducer,<br/>allRecipes: allRecipesReducer<br/>};<br/><br/>const rootReducer = combineReducers(reducers);<br/>const store = createStore(rootReducer);</span><br/><br/>The above example is the long hand version.<br/><br/><span class="attribute">const reducers = {<br/>searchTerm: searchTermReducer,<br/>allRecipes: allRecipesReducer<br/>};<br/><br/>const store = createStore(combineReducers(reducers));</span><br/><br/>The code above shows how the syntax can be reformatted to remove the additional declaration of <span class="attribute">rootReducer</span>.<br/><br/><span class="attribute">const store = createStore(combineReducers({<br/>searchTerm: searchTermReducer,<br/>allRecipes: allRecipesReducer<br/>}));</span><br/><br/>This final block shows how it can be formatted to the minimal amount of code.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Passing Store data as props</td>
                            <td>The store is managing the state of our app therefore we need to pass its information down every relevant level of our app through props so it can effectively communicate up and down the tree.<br/>Example syntax showing how the boilerplate for how this is down is shown below in example <span class="code">index.js</span> and <span class="code">app.js</span> files.<br/><br/><span class="attribute">import React from 'react';<br/>import { createRoot } from 'react-dom/client';<br/>import {store} from './app/store.js';<br/>import { App } from './app/App.js';<br/><br/>const root = createRoot(document.getElementById('root'));<br/>const render = () => {<br/>root.render(<br/></span><span class="code">&lt;App<br/>state=</span><span class="attribute">{store.getState()}</span><span class="code"><br/>dispatch=</span><span class="attribute">{store.dispatch}</span><span class="code"><br/>/&gt;</span><span class="attribute">,<br/>)<br/>}<br/><br/>store.subscribe(render);<br/>render();</span><br/><br/>The code above shows the <span class="code">index.js</span> file.<br/>In this file we import the <span class="attribute">store</span> and then use it within the attributes we are passing down to <span class="code">&lt;App /&gt;</span> so that we get the functionality of getting the current state as well as the ability to dispatch actions down the tree.<br/>Notice that at the bottom we also <span class="attribute">subscribe</span> the <span class="attribute">render</span> action so that everytime the state changes the entire <span class="code">&lt;App /&gt;</span> will be re-rendered<br/><br/><span class="attribute">import React from 'react';<br/><br/>import { AllRecipes } from '../features/allRecipes/AllRecipes.js';<br/>import { SearchTerm } from '../features/searchTerm/SearchTerm.js';<br/><br/>export function App(props) {<br/>const {state, dispatch} = props;<br/><br/>const visibleAllRecipes = getFilteredRecipes(state.allRecipes, state.searchTerm);<br/><br/>return (</span><span class="code"><br/>&lt;main&gt;<br/>&lt;section&gt;<br/>&lt;SearchTerm<br/>searchTerm=</span><span class="attribute">{state.searchTerm}</span><span class="code"><br/>dispatch=</span><span class="attribute">{dispatch}</span><span class="code"><br/>/&gt;<br/>&lt;/section&gt;<br/>&lt;section&gt;<br/>&lt;h2&gt;All Recipes&lt;/h2&gt;<br/>&lt;AllRecipes<br/>allRecipes=</span><span class="attribute">{visibleAllRecipes}</span><span class="code"><br/>dispatch=</span><span class="attribute">{dispatch}</span><span class="code"><br/>/&gt;<br/>&lt;/section&gt;<br/>&lt;/main&gt;</span><span class="attribute"><br/>)<br/>}<br/><br/>/* Utility Helpers */<br/>function getFilteredRecipes(recipes, searchTerm) {<br/>return recipes.filter(recipe => recipe.name.toLowerCase().includes(searchTerm.toLowerCase()));<br/>}</span><br/><br/>The code above shows the <span class="code">app.js</span> file.<br/>In this file we extract the <span class="attribute">state</span> object & <span class="attribute">dispatch</span> method from the <span class="attribute">props</span> being sent down from <span class="code">index.js</span>.<br/>(The <span class="attribute">dispatch</span> method in-built to <span class="attribute">store</span> allows us to send actions to the reducers to update/amend state. Now that its extracted, <span class="attribute">dispatch</span> is the same as <span class="attribute">store.dispatch()</span> and can have arguments passed into it i.e. actions so in the next file we use it as a prefix to handleSubmit or handleChange type functions to dispatch whatever action they're doing to the state.)<br/><br/><span class="attribute">import React from 'react';<br/>const searchIconUrl = './search.svg'<br/>const clearIconUrl = './clear.svg'<br/><br/>import { setSearchTerm, clearSearchTerm } from './searchTermSlice.js';<br/><br/>export const SearchTerm = (props) => {<br/><br/>const { searchTerm, dispatch } = props;<br/><br/>const onSearchTermChangeHandler = (e) => {<br/>const userInput = e.target.value;<br/>dispatch(setSearchTerm(userInput));<br/>};<br/><br/>const onClearSearchTermHandler = () => {<br/>dispatch(clearSearchTerm());<br/>};<br/><br/>return (<br/></span><span class="code">&lt;div id="search-container"&gt;<br/>&lt;img id="search-icon" alt="" src=</span><span class="attribute">{searchIconUrl}</span><span class="code"> /&gt;<br/>&lt;input<br/>id="search"<br/>type="text"<br/>value=</span><span class="attribute">{searchTerm}</span><span class="code"><br/>onChange=</span><span class="attribute">{onSearchTermChangeHandler}</span><span class="code"><br/>placeholder="Search recipes"<br/>/&gt;<br/></span><span class="attribute">{searchTerm.length > 0 && (<br/>&lt;button<br/>onClick={onClearSearchTermHandler}<br/>type="button"<br/>id="search-clear-button"<br/>&gt;<br/>&lt;img src={clearIconUrl} alt="" /&gt;<br/>&lt;/button&gt;<br/>)}</span><span class="code"><br/>&lt;/div&gt;</span><span class="attribute"><br/>);<br/>};</span><br/><br/>The code above shows the <span class="code">searchTerm.js</span> file.<br/>Notice how in this file we're importing <span class="attribute">setSearchTerm</span>, which is a <span class="attribute">setState()</span> style functions from <span class="code">searchTermSlice.js</span> instead of using the actual <span class="attribute">useState()</span> from React. This is because now that we're managing state through Redux conventions we have reformatted some of the code for such complex state management and the equivalent <span class="attribute">setState()</span> functions are now <span class="attribute">actionCreatorFunctions</span> that are kept in <span class="code">searchTermSlice.js</span>.<br/><br/>Another thing to notice is that now in the handler functions we're prefixing each main function body call with the <span class="attribute">dispatch</span> method that we have extracted after its been passed down via <span class="attribute">props</span>. This is because using <span class="attribute">dispatch</span> sends information back up the tree into the <span class="attribute">store</span> and updates the <span class="attribute">state</span>.<br/>This works in basically the same way as a similar <span class="attribute">handleSubmit</span> style function in React. In Redux however we need to add in this communication due to how state is being managed now.<br/><br/><span class="attribute">const initialState = ''<br/><br/>export const searchTermReducer = (state = initialState, action) => {<br/>switch (action.type) {<br/>case 'searchTerm/setSearchTerm':<br/>return action.payload;<br/>case 'searchTerm/clearSearchTerm':<br/>return '';<br/>default:<br/>return state;<br/>}<br/>}<br/><br/>export function setSearchTerm(term) {<br/>return {<br/>type: 'searchTerm/setSearchTerm',<br/>payload: term<br/>}<br/>}<br/><br/>export function clearSearchTerm() {<br/>return {<br/>type: 'searchTerm/clearSearchTerm'<br/>}<br/>}</span><br/><br/>The above code shows the <span class="code">searchTermSlice.js</span> file.<br/>Instead of the React style <span class="attribute">useState()</span> you can see in this file we define and ultimately use <span class="attribute">actionCreatorFunctions</span> to set state by dispatching actions.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="container" id="redux_toolkit">
                <h2>Redux Toolkit</h2>
                <p>This section describes entities of the Redux toolkit, including notes on usages and correct syntax.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td></td>
                            <td>Installing Redux Toolkit</td>
                            <td>To install Redux Toolkit into an application the below code should be entered into the command line.<br/><br/><span class="code">npm install @reduxjs/toolkit</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">createSlice()</span></td>
                            <td>Slice re-factoring and simplification</td>
                            <td><span class="attribute">createSlice()</span> is a method within the Redux toolkit that allows for a simplification of the code needed to create slices.<br/>It should be imported in the usual manner, example syntax is shown below;<br/><br/><span class="attribute">import { createSlice } from '@reduxjs/toolkit';</span><br/><br/>Currently when creating the elements required for slices we need to create an initial state, a reducer function and several action creator functions.<br/>It involves a lot of general boilerplate code.<br/><br/><span class="attribute">createSlice()</span> is an element of the Redux toolkit that aims to reduce the amount of code that needs to be written.<br/>The method itself accepts a single parameter which is known as a configuration object.<br/>This object is really where the amount code being written is drastically reduced.<br/><br/>The configuration object has its own boilerplate. An example is shown below;<br/><br/><span class="attribute">const options = {<br/>name: 'appSlice',<br/>initialState = [],<br/>reducers: {<br/>reducerFunction01: (state, action) => {<br/><br/></span><span class="code">//reducer function body goes here<br/>e.g. return[...state, action.payload]</span><span class="attribute"><br/><br/>}<br/>}<br/>};</span><br/><br/>In the above code we set out 3 top level properties within the configuration object, these are;<br/><br/><span class="attribute">name</span> - This is a string that identifies the name of the slice. This is later used to generate action types and action creators.<br/><br/><span class="attribute">initialState</span> - This is the initial/default state for the reducer.<br/><br/><span class="attribute">reducers</span> - This is a nested object within the confguration object. Each key represents an action type and serves as a string identifier for the action. The value is basically the reducer code body known as a case reducer. Notice how it requires state and action to be used as initial parameters that are then fed into the code body.<br/><br/>Once the configuration object is written then we need to feed it into the <span class="attribute">createSlice()</span> method to actually create the slice.<br/>Example syntax is shown below;<br/><br/><span class="attribute">const exampleSlice = createSlice(options);</span><br/><br/>This can now be exported for use elsewhere in the application.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Understanding how <span class="attribute">createSlice()</span> works</td>
                            <td>The above section explains what <span class="attribute">createSlice()</span> does and the syntax for it. This sections aims to clarify what it returns and what that information looks like to then be able to work with it.<br/><br/>An example <span class="attribute">createSlice()</span> declaration is shown below;<br/><br/><span class="attribute">const todosSlice = createSlice({<br/>name: 'todos',<br/>initialState: [],<br/>reducers: {<br/>addTodo(state, action) {<br/>const { id, text } = action.payload;<br/>state.push({ id, text, completed: flase })<br/>},<br/>toggleTodo(state, action) {<br/>const todo = state.find(todo => todo.id === action.payload)<br/>if (todo) {<br/>todo.completed = !todo.completed<br/>}<br/>}<br/>}<br/>})</span><br/><br/>The above object returns;<br/><br/><span class="attribute">{<br/>name: 'todos',<br/>reducer: (state, action) => newState,<br/>actions: {<br/>addTodo: (payload) => ({type: 'todos/addTodo', payload}),<br/>toggleTodo: (payload) => ({type: 'todos/toggleTodo', payload})<br/>},<br/>}</span><br/><br/>Which for the most part helps to explain a little of whats coming out of the configuration object once its been run through the <span class="attribute">createSlice()</span> method.<br/><br/>By default each action creator accepts 1 argument which becomes the <span class="attribute">action.payload</span>. The <span class="attribute">action.type</span> string is formed by combining the slice name with the case reducer function name. See an example of this below;<br/><br/><span class="attribute">console.log(todosSlice.actions.addTodo('Walk the dog'))</span><br/><br/>The above code would print;<br/><br/><span class="attribute">{type: 'todos/addTodo', payload: 'Walk the dog'}</span><br/><br/>Rather than having to type out that long line of code each time you wanted to dispatch an action they can be destructured, exported and then used much like any other action creator function. See below for syntax;<br/><br/><span class="attribute">export const { addTodo, toggleTodo } = todosSlice.actions;</span><br/><br/>Now these have been exported, they can imported and used elsewhere in our application.<br/><br/>In the example above the reducer key (<span class="attribute">todosSlice.reducer</span>) is the comprehensive reducer function that represents the collection of case reducers.<br/>When an action type that matches one of the auto generated actions in the reducer is dispatched <span class="attribute">todosSlice</span> uses <span class="attribute">todosSlice.reducer()</span> to check whether the dispatched action matches any of its actions and executes the correct action creator function accordingly if a match is found, if no match is found it simply returns the current state.<br/><br/><span class="attribute">todosSlice.reducer</span> also needs to be exported so that it can be integrated into the global store and used as the <span class="attribute">todos</span> slice of state.<br/>Correct syntax for this is shown below;<br/><br/><span class="attribute">export default todosSlice.reducer</span></td>
                        </tr>
                        <tr>
                            <td>Immer</td>
                            <td>Writing mutable code</td>
                            <td>One of the core principles of Redux is that state objects are not altered directly. Copies are made and changes are applied to the copies therefore all code is effectively written so that any state is copied and then effects are applied to the copy.<br/>When combined with nested elemtns this copying can become quite complex to keep track of.<br/><br/><span class="attribute">createSlice()</span> makes use of a library called <span class="attribute">Immer</span>.<br/><span class="attribute">Immer</span> uses a special JS object called a Proxy to wrap the data provided and enables the writing of code that “mutates” that wrapped data. Immer does this by tracking all the changes made and then uses that list of changes to return an immutably updated value as if written all with immutable update logic.<br/>Immer is used internally automatically, so there are no extra steps that need to be taken, it just means that the thought process of needing to copy state and then write logic to accommodate this is no longer necessary.<br/>An example of before and after logic is shown below;<br/><br/><span class="attribute">const todosSlice = createSlice({<br/>name: 'todos',<br/>initialState: [],<br/>reducers: {<br/>addTodo: (state, action) => {<br/>return [<br/>...state,<br/>{<br/>...action.payload,<br/>completed: false<br/>}<br/>]<br/>},<br/>toggleTodo: (state, action) => {<br/>return state.map(todo =><br/>todo.id === action.payload.id ? { ...todo, completed: !todo.completed } : todo<br/>)<br/>}<br/>}<br/>})</span><br/><br/>The above code is before, the below code is after.<br/><br/><span class="attribute">const todosSlice = createSlice({<br/>name: 'todos',<br/>initialState: [],<br/>reducers: {<br/>addTodo: (state, action) => {<br/>state.push({<br/>...action.payload,<br/>completed: false<br/>})<br/>},<br/>toggleTodo: (state, action) => {<br/>const todo = state.find(todo => todo.id === action.payload.id)<br/>if (todo) {<br/>todo.completed = !todo.completed<br/>}<br/>}<br/>}<br/>})</span><br/><br/>In the above examples <span class="attribute">addTodo</span> is calling <span class="attribute">state.push()</span>, which is normally bad because the <span class="attribute">array.push()</span> function mutates the existing array.<br/>Similarly, <span class="attribute">toggleTodo</span> is simply finding the matching <span class="attribute">todo</span> object, and then mutating it by reassigning its value.<br/>Thanks to Immer, however, this code is automatically being copied and returned as a new immutably updated value.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">configureStore()</span></td>
                            <td>Re-factoring the store setup</td>
                            <td><span class="attribute">configureStore()</span> is a method within the Redux toolkit that allows for a simplification of the code needed to setup a store.<br/>It should be imported in the usual manner, example syntax is shown below;<br/><br/><span class="attribute">import { configureStore } from '@reduxjs/toolkit';</span><br/><br/><span class="attribute">configureStore()</span> wraps around <span class="attribute">createStore()</span> and <span class="attribute">combineReducers()</span> methods to handle store setup. It accepts a single configuration object parameter which should have a reducer property that defines either a function to be used as the root reducer or an object of slice reducers which will be combined to create a root reducer.<br/>So instead of;<br/><br/><span class="attribute">const rootReducer = combineReducers({<br/>todos: todosReducer,<br/>recipes: recipesReducer<br/>})<br/><br/>export const store = createStore(rootReducer);</span><br/><br/>We can can define a store in the following way;<br/><br/><span class="attribute">const configureStore({<br/>reducer: {<br/>todos: todosReducer,<br/>recipes: recipesReducer<br/>}<br/>})<br/><br/>export default store;</span><br/><br/>What this does is;<br/><br/>Reducer - It combines <span class="attribute">todosReducer</span> and <span class="attribute">recipesReducer</span> into the <span class="attribute">rootReducer</span> function which will handle a root state that looks like <span class="attribute">{todos, recipes}</span>. This removes the need to call <span class="attribute">combineReducers()</span>, ultimately lowering the amount of code we need to write.<br/><br/>Store - It creates a Redux store using that <span class="attribute">rootReducer</span>, removing the need to call <span class="attribute">createStore()</span>.<br/><br/>Middleware - It automatically adds middleware to check for common mistakes like accidentally mutating the state. This is something that would need to be done manually without using this method.<br/><br/>DevTools - It automatically sets up Redux DevTools Extension connection. This is something that would need to be done manually without using this method.<br/><br/>Due to how much boilerplate code we’re able to bypass with <span class="attribute">configureStore()</span>, we can just import the individual slice reducers straight into this file instead of creating a separate file for the root reducer and having to export/import it.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="container" id="middleware">
                <h2>Middleware</h2>
                <p>This section describes the principles of middleware within Redux, including notes on usages and correct syntax.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td></td>
                            <td>Importing Middleware</td>
                            <td>To import Middleware into the app it needs to be declared in the usual manner from the Redux library.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">import { applyMiddleware } from 'redux';</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Core ideas behind Middleware</td>
                            <td>In Redux, middleware runs between when an action is dispatched and when that action is passed along to the reducer.<br/><br/>Middleware intercepts actions after they are dispatched and before they are passed along to the reducer. Some common tasks that middleware performs include logging, caching, adding auth tokens to request headers, crash reporting, routing, and making asynchronous requests for data.<br/><br/>One of the more powerful tools that Middleware offers us is the ability to bring asynchronous functionality to our Redux app.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Setting up Middleware basics</td>
                            <td>Once Middleware has been added to a Redux project, <span class="attribute">store.dispatch()</span> calls are actually calls to the middleware pipeline (the chain of all added middlewares). This means that any actions dispatched will be passed from middleware to middleware before they hit an app's reducer functions.<br/><br/>Middlewares must conform to a specific, nested function structure in order to work as part of the pipeline. This nested structure is also called a higher-order function.<br/>An example of the structure is shown below;<br><br/><span class="attribute">const exampleMiddleware = storeAPI => next => action => {<br/></span><span class="code">// do stuff here</span><span class="attribute"><br/>return next(action);  </span><span class="code">// pass the action on to the next middleware in the pipeline</span><span class="attribute"><br/>}</span><br/><br/>Each middleware has access to the <span class="attribute">storeAPI</span> (which consists of the <span class="attribute">dispatch</span> and <span class="attribute">getState()</span> functions), as well as the next middleware in the pipeline, and the action that is to be dispatched. The body of the middleware function performs the middleware’s specific task before calling the next middleware in the pipeline with the current action (note that if the middleware is the last in the pipeline, then <span class="attribute">next()</span> is <span class="attribute">storeAPI.dispatch</span> so calling <span class="attribute">next(action)</span> is the same as dispatching the action to the store).</td>
                        </tr>
                        <tr>
                            <td>Thunks</td>
                            <td>What is a thunk and how it works</td>
                            <td>A thunk is a section code that is wrapped into a function. This function is then assigned to a variable which can be called as a function at another point in time perform the previously declared function.<br/>An example of this is shown below;<br/><br/><span class="attribute">const add = (x,y) => {<br/>return () => {<br/>return x + y;<br/>}<br/>}<br/><br/>console.log(add(2,2));<br/></span><span class="code">//Prints function () { return x + y; }</span><br/><br/>In the code above if we call <span class="attribute">add()</span> with some numbers passed in as arguments, a function will be returned. The top most level of the declaration is carried out, not the full code body.<br/><br/><span class="attribute">const delayedAddition = add(2,2)<br/>console.log(delayedAddition());<br/><br/></span><span class="code">//Prints 4</span><br/><br/>When we assign this to a variable and then call the variable as a function, the whole thing is resolved.<br/><br/>This allows us to declare the variable with a specified function and then call it later on as is necessary in our app.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">createAsyncThunk()</span></td>
                            <td>Create Async Thunk</td>
                            <td><span class="attribute">createAsyncThunk()</span> is a method within the Redux toolkit that allows us to create asynchronous thunk functions.<br/>It should be imported in the usual manner, example syntax is shown below;<br/><br/><span class="attribute">import { createAsyncThunk } from '@reduxjs/toolkit';</span><br/><br/><span class="attribute">createAsyncThunk()</span> is a function with two parameters, an action type string, and an asynchronous callback, that generates a thunk action creator that will run the provided callback and automatically dispatch promise lifecycle actions as appropriate so that you don’t have to dispatch pending/fulfilled/rejected actions by hand.<br/><br/><span class="attribute">createAsyncThunk()</span> accepts 2 arguments. The first is a string representing the asynchronous action’s type. Conventionally, type strings take the form <span class="attribute">"resourceType/actionName"</span>. The second argument is the payload creator: an asynchronous function that returns a promise resolving to the result of an asynchronous operation.<br/><br/>Below is a promise written to include 'Pending', 'Fulfilled' and 'Rejected' outcomes;<br/><br/><span class="attribute">import { fetchUser } from './api'<br/><br/>const fetchUserById = (id) => {<br/></span><span class="code">// Code here to update store to show user data is being requested -> "pending" state</span><span class="attribute"><br/>try {<br/>const payload = await fetchUser(id)<br/></span><span class="code">// Code here to update user data in store with `payload` -> "fulfilled" state</span><span class="attribute"><br/>} catch(err) {<br/></span><span class="code">// Code here to notify store to show user data failed to be fetched -> "rejected" state</span><span class="attribute"><br/>}<br/>}</span><br/><br/>In the above code we have a standard promise written with try and catch statements.<br/>Below is the same function rewritten to use <span class="attribute">createAsyncThunk()</span>. Our action type will be <span class="attribute">users/fetchUserById</span>.<br/><br/><span class="attribute">import { createAsyncThunk } from '@reduxjs/toolkit'<br/>import { fetchUser } from './api'<br/><br/>const fetchUserById = createAsyncThunk(<br/>'users/fetchUserById', </span><span class="code">// action type</span><span class="attribute"><br/>async (arg, thunkAPI) => { </span><span class="code">// payload creator</span><span class="attribute"><br/>const response = await fetchUser(arg);<br/>return response.json();<br/>}<br/>)</span><br/><br/>Notice that the payload creator receives two arguments <span class="attribute">arg</span> and <span class="attribute">thunkAPI</span>. These are further explained later.<br/>Second, note that the payload creator doesn’t dispatch any actions at all. It just returns the result of an asynchronous operation. <span class="attribute">createAsyncThunk()</span> makes defining thunk action creators concise. All you have to write is an asynchronous thunk function; <span class="attribute">createAsyncThunk()</span> takes care of the rest, returning an action creator that will dispatch pending/fulfilled/rejected actions as appropriate.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">arg</span> and <span class="attribute">thunkAPI</span></td>
                            <td>Parameters of <span class="attribute">createAsyncThunk()</span></td>
                            <td><span class="attribute">arg</span> is equal to the first argument passed into the thunk action creator.<br/>So using the <span class="attribute">createAsyncThunk()</span> function we defined in the previous step, if we were to call <span class="attribute">fetchUserById(7)</span>, then inside the payload creator, <span class="attribute">arg</span> will be equal to 7.<br/><br/>The payload creator only receives the first argument passed into the action thunk creator so if multiple arguments are needed to be passed into the thunk then the we need to bundle them up in an object and pass the object.<br/>In our example, if we wanted to fetch multiple users using their Id's we would call <span class="attribute">fetchUserById({user_1: 7, user_2: 8, user_3: 9})</span>.<br/>The object gets passed through and then our logic could deal with the key values to extract what we needed.<br/><br/>We can also use destructuring within the paylod creator if our app called for it.<br/>For example if our Async Thunk function was searching for users we might have it set out like the code below;<br/><br/><span class="attribute">const searchUsers = createAsyncThunk(<br/>'users/searchUsers',<br/>async ({firstName, lastName}, thunkAPI) => {<br/></span><span class="code">// perform whatever search to the user database here</span><span class="attribute"><br/>}<br/>)</span><br/><br/>We could then call the function using the defined key value pairs like so;<br/><br/><span class="attribute">searchUsers({firstName: 'Dave', lastName: 'Jones'})</span><br/><br/>This allows us to be specific within our thunk if its necessary to do so.<br/><br/>When it comes to single parameter thunks best practice is to name the <span class="attribute">arg</span> semantically if possible.<br/> so within our user Id example the boilerplate <span class="attribute">arg</span> would be <span class="attribute">userId</span> and the payload creator would like like;<br/><br/><span class="code">// other code ommitted</span><br/><span class="attribute">async (userId, thunkAPI) => {</span><br/><span class="code">// other code ommitted</span><br/><br/>The payload creator’s second argument, <span class="attribute">thunkAPI</span>, is an object containing several useful methods, including the store’s <span class="attribute">dispatch()</span> and <span class="attribute">getState()</span>.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.pending</span>,<br/><span class="attribute">.fulfilled</span>,<br/><span class="attribute">.rejected</span></td>
                            <td>Actions generated by <span class="attribute">createAsyncThunk()</span></td>
                            <td><span class="attribute">createAsyncThunk()</span> dispatches actions for each of the promise lifecycle states: pending, fulfilled and rejected..<br/><br/><span class="attribute">createAsyncThunk()</span> produces action types for each of the promise lifecycle states built off the action type strings passed to it.<br/>So for example using our <span class="attribute">fetchUserById</span> function, <span class="attribute">createAsyncThunk()</span> would produce;<br/><br/><span class="attribute">'users/fetchUserById/pending'<br/>'users/fetchUserById/fulfilled'<br/>'users/fetchUserById/rejected'</span><br/><br/>These actions can then be accessed using the function name suffixed with the individual state using dot notation;<br/><br/><span class="attribute">fetchUserById.pending<br/>fetchUserById.fulfilled<br/>fetchUserById.rejected</span><br/><br/>We can use these within our app to provide visual updates to the user as to the current state of any request.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Using <span class="attribute">createSlice()</span> with <span class="attribute">createAsyncThunk()</span></td>
                            <td><span class="attribute">createSlice()</span> accepts a single argument (usually defined as a variable named <span class="attribute">options</span>) which is an object containing configuration parameters including a name, an initial state, and reducers.<br/><span class="attribute">createSlice()</span> then uses these configuration parameters to generate a slice of the store, including action creators and action types for updating the state contained in that slice.<br/>An example of this is shown below;<br/><br/><span class="attribute">const usersSlice = createSlice({<br/>name: 'users',<br/>initialState: { users:  [] },<br/>reducers: {<br/>addUser: (state, action) => {<br/>state.users.push(action.payload)<br/>}<br/>},<br/>})</span><br/><br/>The drawback of leaving the options configuration object in this way is that it is a closed environment when it comes to actions. The actions are all created and defined within the <span class="attribute">reducers</span> section.<br/>In the previous step we know that additional actions are being created by <span class="attribute">createAsyncThunk()</span> but at present these actions are not accessible within our slice in its current definition.<br/><br/>We can use <span class="attribute">extraReducers</span> within our <span class="attribute">createSlice()</span> declaration to provide the access we need.<br/><span class="attribute">extraReducers</span> is an optional key that we can include when defining our slice that allows <span class="attribute">createSlice()</span> to respond to actions generated outside of its configuration object.<br/>An example is provided below that refactors the slice shown above to include this functionality.<br/><br/><span class="attribute">const usersSlice = createSlice({<br/>name: 'users',<br/>initialState: {<br/>users:  [],<br/>isLoading: false,<br/>hasError: false<br/>},<br/>reducers: {<br/>addUser: (state, action) => {<br/>state.users.push(action.payload)<br/>}<br/>},<br/>extraReducers: {<br/>[fetchUserById.pending]: (state, action) => {<br/>state.isLoading = true;<br/>state.hasError = false;<br/>},<br/>[fetchUserById.fulfilled]: (state, action) => {<br/>state.users.push(action.payload);<br/>state.isLoading = false;<br/>state.hasError = false;<br/>},<br/>[fetchUserById.rejected]: (state, action) => {<br/>state.isLoading = false;<br/>state.hasError = true;<br/>}<br/>}<br/>})</span><br/><br/>Notice in the above declaration there are a number of changes that have taken place.<br/>In the <span class="attribute">initialState</span> key we have added in some additional utility properties that will allow us to use the promise lifecycle states we are introducing.<br/>We now have <span class="attribute">isLoading</span> and <span class="attribute">hasError</span> keys. These allow us to take advantage of the information our app is generating with regards to the changing states of the promise that is being processed. What this essentially means is that we can keep the user informed by displaying things like loading pages, success or error messages on the resolution of the promise.<br/>We have a new <span class="attribute">extraReducers</span> key that holds the logic allowing us to alter the state parameters introduced.<br/>Notice how each piece of logic is dealing with the 3 new possible states that related to the actions being generated by <span class="attribute">createAsyncThunk()</span>.<br/>They all work in the same way as the <span class="attribute">reducers</span> in that whatever action is fed into it and if there is a change it updates state if not then it returns the current state.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Using destructuring of <span class="attribute">action.payload</span> to assign values</td>
                            <td>When trying to assign values within the promise lifecycle actions generated by <span class="attribute">createAsyncThunk()</span> we can use object destructuring of the <span class="attribute">action.payload</span> to help us assign values in the fulfilled section.<br/>An example is shown below;<br/><br/>In this example we are going to assign some comments to an article on a fictional news website that has a comments section.<br/><br/><span class="attribute">export const commentsSlice = createSlice({<br/>name: 'comments',<br/>initialState: {<br/>byArticleId: {},<br/>isLoadingComments: false,<br/>failedToLoadComments: false<br/>},<br/>extraReducers: {<br/>[loadCommentsForArticleId.pending]: (state, action) => {<br/>state.isLoadingComments = true;<br/>state.failedtoLoadComments = false;<br/>},<br/>[loadCommentsForArticleId.fulfilled]: (state, action) => {<br/>const { articleId, comments } = action.payload;<br/>state.byArticleId[articleId] = comments<br/>state.isLoadingComments = false;<br/>state.failedtoLoadComments = false;<br/>},<br/>[loadCommentsForArticleId.rejected]: (state, action) => {<br/>state.isLoadingComments = false;<br/>state.failedtoLoadComments = true;<br/>}<br/>}<br/>});</span><br/><br/>In this example our <span class="attribute">action.payload</span> is an object that has 2 key value pairs, it looks like the following;<br/><span class="attribute">action.payload = {articledId: 1, comments:'Amazing!'}</span><br/>notice how in the <span class="attribute">[loadCommentsForArticleId.fulfilled]</span> we destructure the <span class="attribute">action.payload</span> so we can then use each of these key-value pairs individually to assign the <span class="attribute">comments</span> value to the state.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>For additional tags and examples see the <a href="https://redux.js.org/" target="_blank">Redux Website</a> for more info.</p>
        </div>
    </body>
    <footer>

    </footer>
</html>