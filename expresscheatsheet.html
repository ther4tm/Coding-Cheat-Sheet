<!DOCTYPE html>
<html>
    <head>
        <title>Express.js Cheat Sheet</title>
        <link href="./resources/css/index.css" type="text/css" rel="stylesheet">
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link rel="preconnect" href="https://fonts.googleapis.com">
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
    </head>
    <body>
        <header>
            <nav>
                <div class="dropdown">
                    <button class="dropdownBtn">Front End</button>
                    <div class="dropdownContent">
                        <a href="./htmlcheatsheet.html">HTML</a>
                        <a href="./csscheatsheet.html">CSS</a>
                        <a href="./javascriptcheatsheet.html">JavaScript</a>
                        <a href="./reactcheatsheet.html">React</a>
                        <a href="./reduxcheatsheet.html">Redux</a>
                    </div>
                </div>
                <div class="dropdown">
                    <button class="dropdownBtn">Back End</button>
                    <div class="dropdownContent">
                        <a href="./nodecheatsheet.html">Node.js</a>
                        <a href="./expresscheatsheet.html">Express.js</a>
                    </div>
                </div>
                <div class="dropdown">
                    <button class="dropdownBtn">Other</button>
                    <div class="dropdownContent">
                        <a href="./commandlinecheatsheet.html">Command Line</a>
                        <a href="./markdowncheatsheet.html">Markdown</a>
                        <a href="./styleguide.html">Style Guide</a>
                    </div>
                </div>
            </nav>
        </header>
        <div class="content">
            <h1>Express.js Cheat Sheet</h1>
            <p>Below is a list of commands, methods and fundamental principles regarding the Express.js server framework including a brief description of what they do and any notes on correct syntax.</p>
            <div id="fundamentals">
                <h2>Fundamentals</h2>
                <p>This section describes some fundamental properties of the Express.js framework.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">express</span></td>
                            <td>Express</td>
                            <td>Express is a node module.<br/>It does not come pre-installed so we need to install it before use. We can do this using <span class="attribute">npm</span> in the terminal.<br/><br/>The correct syntax for this is shown below;<br/><br/><span class="attribute">npm i express</span><br/><br/>Once installed into the project file we can then require it in like any other non-global node module.<br/><br/><span class="attribute">const express = require('express');</span><br/><br/>Once required in we then need to invoke the express method within a variable to then be able to create a server.<br/><br/><span class="attribute">const app = express();</span><br/><br/>With that all now established we can start a server and specify server behavior.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">app.listen()</span></td>
                            <td>Listen method</td>
                            <td>The purpose of a server is to listen for requests, perform whatever action is required to satisfy the request, and then return a response.<br/><br/>In order for our server to start responding, we have to tell the server where to listen for new requests by providing a port number argument to a method called <span class="attribute">app.listen()</span>.<br/>The server will then listen on the specified port and respond to any requests that come into it.<br/>The second argument is a callback function that will be called once the server is running and ready to receive responses.<br/><br/>An example of syntax is shown below;<br/><br/><span class="attribute">const app = express();<br/>const PORT = 4001;<br/><br/>app.listen(PORT, () => {<br/>console.log(`Server is listening on port ${PORT}`);<br/>});</span><br/><br/>In the above example we create a <span class="attribute">PORT</span> variable that contains the port number for our server to listen for instructions on. We then invoke the <span class="attribute">.listen()</span> express method, providing the <span class="attribute">PORT</span> variable as the first argument and a callback function that prints a simple message to the console as the second argument.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Routes</td>
                            <td>Once we have set up the server to listen for any and all requests we then need to establish how it will respond to these requests.<br/>This requires us to create a number of Routes.<br/>Routes in this context are basically like instructions in a similar vein to actions in Redux.<br/><br/>Routes define the control flow for specific requests based on the request's included path and HTTP verb.<br/><br/>So for example, a user on the front end might click a link to look at another page of the website.<br/>This is a get request.<br/>The link clicked by the user triggers a get request to be sent to the back end. The details of how this works will be explained later but our site will have some routes set up to provide appropriate responses to these requests, instructions on what the back end should do next and how it should respond.<br/><br/>There will be many different routes set up to enable different functionality.<br/>They are defined by the specific HTTP verb (GET, POST etc.) and paths.<br/>The path is the part of a request URL after the hostname and port number, so in a request to <span class="code">localhost:4001/monsters</span>, the hostname is <span class="code">localhost</span>, the port the server is listening on is <span class="code">4001</span> and the path is <span class="code">/monsters</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">app.get()</span></td>
                            <td>GET method</td>
                            <td>In express.js the <span class="attribute">.get()</span> method is used to match up any GET requests to the outlined functionality.<br/><br/>The <span class="attribute">.get()</span> method accepts 2 arguments, the first is a path which is usually a string and the second is a callback function that will handle the specific request.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const moods = [{ mood: 'excited about express!'}];<br/>app.get('/moods', (req, res, next) => {<br/>// Here we would send back the moods array in response<br/>});</span><br/><br/>In the above example a route for a GET request with the path of <span class="attribute">/moods</span> has been set up</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.send()</span></td>
                            <td>Send Method</td>
                            <td>Express sends responses using the <span class="attribute">.send()</span> method on the response object. This method will take any input and include it in the response body.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const monsters = [<br/>{ type: 'werewolf' },<br/>{ type: 'hydra' }, <br/>{ type: 'chupacabra' }<br/>];<br/><br/>app.get('/monsters', (req, res, next) => {<br/>res.send(monsters);<br/>});</span><br/><br/>In this example a GET request using the path <span class="code">/monsters</span> will match to a defined route. Express will match this route and call the callback function.<br/>In the response body it shows that the route has been set up to use the <span class="attribute">.send()</span> method on the response object with the argument <span class="attribute">monsters</span>.<br/>Above this route you can see the <span class="attribute">monsters</span> variable contains an array of objects containing various <span class="attribute">key:value</span> pairs of different monsters.<br/><br/>All of this will be sent back as the response because this is what the route has been set up to do.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.json()</span></td>
                            <td>JSON send Method</td>
                            <td>By using <span class="attribute">.json()</span> instead of <span class="attribute">.send()</span> on the response (<span class="attribute">res</span>) object, you can explicitly send JSON formatted responses. It does everything the same as the above <span class="attribute">.send()</span> method but its formatted into JSON.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Matching route paths</td>
                            <td>Express matches requests by route and, as with all javascript code, it works from top to bottom and works methodically until either a match has been found or there is no code left to evaluate.<br/><br/>So if we have a list of 15 routes all set out and our request path matches a route located at number 8, it will run through the first 7 and try to match the path.<br/><br/>It also operates on a first called basis so lets say there is a mistake in your code and there are 2 paths that have the same route then it will call the first one it encounters.<br/><br/>Finally if it reaches the end of the list and no matches have been found it will automatically send back a 404 not found response.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">req</span> & <span class="attribute">res</span></td>
                            <td>Request Object, Response Object</td>
                            <td>In the above examples we've briefly mentioned the 3 arguments that are fed into the callback functions of each method (<span class="attribute">req</span>, <span class="attribute">res</span> & <span class="attribute">next</span>).<br/>For now we'll focus on the <span class="attribute">req</span> & <span class="attribute">res</span> elements.<br/><br/>These are the <span class="attribute">request</span> and <span class="attribute">response</span> objects. Both have a few built in methods that provide tools to deal with requests and responses. The most important thing to keep in mind here is that both are objects containing information about the incoming request and its associated information (<span class="attribute">req</span>) or the outgoing response and its details (<span class="attribute">res</span>).</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">app.get('/monsters/:name')</span></td>
                            <td>Dynamic routes</td>
                            <td>Dynamic routes in express.js are called route parameters. They can be easily identified through the use of the <span class="attribute">:</span> character at the beginning of the path segment.<br/><br/>They work in a very similar way to DOM routing in React, in that you can define a route with a placeholder that allows for the dynamic interaction of unknown content.<br/>For example, if we created a route path of <span class="code">/monsters/:name</span> then both the incoming GET requests of <span class="code">/monsters/hydra</span> and <span class="code">/monsters/dragon</span> would be valid and get matched to our dynamic route.<br/><br/>The next interesting point to note about this is that express extracts the values of those parameters and attaches them as an object to the request object under the key <span class="attribute">req.params</span>.<br/>Within this object it then creates a key:value pair with the key being the dynamic route placeholder and the value being whatever information is extracted from the request.<br/><br/>So for example the GET request of <span class="code">/monsters/hydra</span> would be accepted as a valid request, the <span class="code">hydra</span> part of the path would be extracted and could then be accessed through the <span class="attribute">req</span> object at <span class="attribute">req.params.name</span>.<br/><br/>Below is a visual explanation of the <span class="attribute">req</span> object to show how the dynamic route has extracted and stored the information for use in a response.<br/><br/><span class="attribute">req = {<br/>//example other key,<br/>params: {<br/>{ name: hydra }<br/>},<br/>//example other key<br/>}</span><br/><br/>For a practical example lets say that we have a database on the back end of monster stats. The front end is our website that is displaying various facts about monsters, the user can click different links to load up the different stats.<br/>Whenever the user clicks the link it will send a GET request for each different monster. Each different monster will send its own GET request including its own path. We can use dynamic routing to accept all of these and send back the relevant stats for display on the website.<br/><br/><span class="attribute">const monsters = { <br/>hydra: { height: 3, age: 4 },<br/>dragon: { height: 200, age: 350 } <br/>};<br/><br/>app.get('/monsters/:name', (req, res, next) => {<br/>console.log(req.params); // { name: 'hydra' }<br/>res.send(monsters[req.params.name.height]);<br/>});</span><br/><br/>As you can see above, we have our database of monster facts and underneath we have our dynamic route that accepts the dynamic input of <span class="code">:name</span>.<br/>When the user clicks on <span class="attribute">hydra</span> this will trigger a GET request that will send the path <span class="code">/monsters/hydra</span> to our express server. Our dynamic route will accept this, because it follows the valid pattern we've written in the GET request and as you can see in the response we use the extracted values from <span class="attribute">req.params</span> to access the relevant information from our <span class="attribute">monsters</span> database and we send our <span class="attribute">res</span> object back pinpointing (in this example) the height value of the hydra in our <span class="attribute">monsters</span> database.</td> 
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Longer dynamic routes</td>
                            <td>Route parameters match to their specific part of the path. What this means is that the dynamic portion of the route can be much further along the path than the first section after the root, all you need to bear in mind is that the route should mirror this in order for a request to be successful.<br/><br/>An example of correct syntax is shown below;<br/><br/><span class="code">Request = GET /monster/name/25</span><br/><br/><span class="attribute">app.get('/monster/name')<br/><br/>app.get('/monster/name/:id')</span><br/><br/>In the above example the request would get checked against the first route (because this is how express works, top to bottom), it would fail because the route path isn't the correct length.<br/>It would then move onto the next route, check the path and match because it is of the correct length and it is dynamic meaning that our request would match.</td> 
                        </tr>
                        <tr>
                            <td><span class="attribute">.status()</span></td>
                            <td>Status codes</td>
                            <td>Express has a built in method that allows us to set status codes on any response that we send back. Status codes are automatically sent back on successful (200 OK) or unsuccessful (404 NOT FOUND) responses, however we can include a status method and provide a custom status code.<br/><br/><span class="attribute">const monsterStoreInventory = { fenrirs: 4, banshees: 1, jerseyDevils: 4, krakens: 3 };<br/><br/>app.get('/monsters-inventory/:name', (req, res, next) => {<br/>const monsterInventory = monsterStoreInventory[req.params.name];<br/>if (monsterInventory) {<br/>res.send(monsterInventory);<br/>} else {<br/>res.status(404).send('Monster not found');<br/>}<br/>});</span><br/><br/>In the example above we've set up a route to check an inventory database. If the request finds something, it send back a response with an automatic 200 OK response code.<br/>If the request is for something not contained within the database we send back a 404 code with our custom message 'Monster not found' chained onto the end of the <span class="attribute">.status()</span> method.</td> 
                        </tr>
                        <tr>
                            <td><span class="attribute">?</span></td>
                            <td>Using Queries</td>
                            <td>Query strings appear at the end of the path in URLs and they are indicated with a <span class="attribute">?</span> character.<br/><br/>Query strings do not count as part of the path.<br/><br/>Therefore a request of <span class="code">/monsters/1?name=chimera&age=1</span> can be broken down into the path, which would be <span class="code">/monsters/1</span> and the query which would be <span class="code">name=chimera&age=1</span><br/><br/>Express parses anything after the <span class="attribute">?</span> into a Javascript object that is then automatically attached to the request object as the value of <span class="attribute">req.query</span>.<br/><br/>They key:value relationship of the query string is indicated by the <span class="attribute">=</span> character contained in the query string. Furthermore key:value pairs are further separated by the <span class="attribute">&</span> character.<br/>So in our example above, the object automatically attached to <span class="attribute">req.query</span> would look like;<br/><br/><span class="attribute">{ name: chimera, age: 1 }</span></td> 
                        </tr>
                        <tr>
                            <td><span class="attribute">.put()</span></td>
                            <td>PUT Method</td>
                            <td>PUT requests are used for updating existing resources. Like a user's location or their favourite food within their user profile.<br/><br/>Below is an example of how we can use PUT requests to allow a user to update the details of our monsters.<br/><br/>Let's say that our user decides to change the name and age of the monster at index 1 in our database. The PUT request would look like this;<br/><span class="attribute">/monsters/1?name=chimera&age=1</span><br/><br/>To make this change our code would look like the below;<br/><br/><span class="attribute">const monsters = {<br/>'1': { name: 'cerberus', age: '4'  }<br/>'2': { name: 'dragon', age: '67'  }<br/>};<br/><br/>app.put('/monsters/:id', (req, res, next) => {<br/>const monsterUpdates = req.query;<br/>monsters[req.params.id] = monsterUpdates;<br/>res.send(monsters[req.params.id]);<br/>});</span><br/><br/>At the top we have our existing monster database. It is an object that contains various monsters arranged by ID. The ID's are numbered and within each ID is another object that contains the monster's name and its age.<br/>As with any Javascript object, all of these details can be easily accessed through standard dot notation<br/>(e.g. <span class="attribute">monsters['1'].name</span> would get 'cerberus').<br/><br/>Underneath this we have our route to handle the PUT request.<br/>The path is dynamic which allows us to handle any particular monster selected by the user based on its ID.<br/>Within the callback we have a variable (<span class="attribute">monsterUpdates</span>) set up to extract the query information (<span class="attribute">req.query</span>) received from the request object.<br/>which is <span class="attribute">{ name:'chimera', age: '1'}</span><br/><br/>Underneath this we have the section of code that does the actual update.<br/>It says in the <span class="attribute">monsters</span> variable (our database) we target a specific monster using the <span class="attribute">[req.params.id]</span>. The ID is <span class="code">1</span> because that's the ID contained within the path from request, so this is targetting the object with the key of <span class="code">'1'</span> in the <span class="attribute">monsters</span> object (our database of monsters).<br/>Currently that monster is <span class="attribute">{ name: 'cerberus', age: '4' }</span>.<br/>In our code we are then re-assigning this to be the information we have received from the PUT request and stored in the <span class="attribute">monsterUpdates</span> variable.<br/>Now we know Javascript objects recognise the same keys if they already exist and simply overwrites the values and if the key doesn't exist it will create it for us.<br/>In this example the keys already exist so this piece of code will overwrite<br/><span class="attribute">{ name: 'cerberus', age: '4' }</span><br/>with the value in our PUT request which we know is<br/><span class="attribute">{ name: 'chimera', age: '1' }</span>.<br/><br/>The final part of the code is a simple <span class="attribute">.send()</span> method that sends this back to the front end. This is best thought of as a confirmation that the change has been made and displays this to the front end.</td> 
                        </tr>
                        <tr>
                            <td><span class="attribute">.post()</span></td>
                            <td>POST Method</td>
                            <td>POST requests are slightly different from GET and PUT requests because a POST request is creating new information as opposed to retrieving or editing existing information.<br/><br/>This is an important factor to bear in mind when it comes to adding the information to an existing database. If we are adding new information to an array we can simply add this to the array using various array editing methods like <span class="attribute">.push()</span> however, if we are editing an object it becomes a little more tricky as we are likely to want to give it a key based on either an index or something unique to prevent clashes of information.<br/><br/>An example of this is shown below;<br/><br/>Lets say we want to add a brand new monster to our existing monster database.<br/>It currently looks like the below;<br/><br/><span class="attribute">const monsters = {<br/>'1': { name: 'chimera', age: '1' }<br/>'2': { name: 'dragon', age: '67' }<br/>};</span><br/><br/>Our monsters are arranged within the database using indexes (<span class="attribute">'1'</span>) as the key for each individual monster and the associated records. When we add a new one we need to take this into account in how we handle the request.<br/><br/><span class="attribute">app.post('/monsters', (req, res, next) => {<br/>const newMonster = req.query;<br/>if (newMonster) {<br/>monsters[Object.keys(monsters).length] = newMonster;<br/>res.status(201).send(newMonster);<br/>} else {<br/>res.status(400).send()<br/>}<br/>});</span><br/><br/>Each individual case will handle this differently however in this small example this is how we would use the POST request to add new content to our existing monsters database.<br/>Notice how we also add in a quick sense checking <span class="attribute">if</span> statement that ensures we have valid content and sends back a 201 content created status code if successful or a 400 not valid code if unsuccessful.<br/><br/>So if our POST request looked like this;<br/><span class="code">/monsters?name=cerberus&age=4</span><br/><br/>Then our new database would end up looking like the below;<br/><br/><span class="attribute">const monsters = {<br/>'1': { name: 'chimera', age: '1' },<br/>'2': { name: 'dragon', age: '67' },<br/>'3': { name: 'cerberus', age: '4' }<br/>};</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.delete()</span></td>
                            <td>DELETE Method</td>
                            <td>DELETE requests are used to delete existing data, because these routes are used to delete existing data their paths should usually end with a route parameter to indicate which resource to delete.<br/><br/>As with the POST request, deleting elements from an array can be done with the available array editing methods such as <span class="attribute">.splice()</span> however some thought into how to target the specific item to be deleted should be given when forming the route.<br/><br/>An example of how to delete an entry from our monsters database is shown below;<br/><br/>Lets say our database is as shown below;<br/><br/><span class="attribute">const monsters = {<br/>'1': { name: 'chimera', age: '1' },<br/>'2': { name: 'dragon', age: '67' },<br/>'3': { name: 'cerberus', age: '4' }<br/>};</span><br/><br/>And we receive a DELETE request as follows;<br/><span class="code">/monsters/1</span><br/><br/>Our route might look something like the following;<br/><br/><span class="attribute">app.delete('/monsters/:id', (req, res, next) => {<br/>const id = req.params.id;<br/><br/>if (monsters.hasOwnProperty(id)) {<br/>delete monsters[id];<br/>res.status(204).send('Monster deleted');<br/>} else {<br/>res.status(404).send('Monster not found');<br/>}<br/>});</span><br/><br/>Notice how we have a dynamic route set up to accept any input to delete a monster from the database.<br/>We extract the ID parameter from the request path and then use that to identify which element of our database we intend to delete. A 204 No content code is sent upon successful deletion.<br/>One important point to note here is that when we delete this entry from our database, the existing entries do not get refactored, therefore our database will now look like the following;<br/><br/><span class="attribute">const monsters = {<br/>'2': { name: 'dragon', age: '67' },<br/>'3': { name: 'cerberus', age: '4' }<br/>};</span><br/><br/>As a result the database object might look a little messy and could potentially be difficult to maintain with numbered keys like this example.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="router">
                <h2>Express.Router</h2>
                <p>This section describes the principles of modular routing.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">.Router()</span></td>
                            <td>Router</td>
                            <td>The <span class="attribute">.Router()</span> method provides a subset of express methods. In order to use these we need to invoke the method on the express import itself.<br/><br/>An example of the syntax is shown below;<br/><br/><span class="attribute">const express = require('express');<br/>const app = express();<br/><br/>const monstersRouter = express.Router();</span><br/><br/>In the code above we can see that we still required in <span class="attribute">'express'</span> and we still invoke that onto our <span class="attribute">app</span> variable.<br/>Below that however we invoke the <span class="attribute">.Router()</span> method on a new variable called <span class="attribute">monstersRouter</span>. This gives us access to the subset of express methods that we will use later to create routes and refactor our code to be modular and therefore easier to maintain.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.use()</span></td>
                            <td>Mounting the Router</td>
                            <td>The <span class="attribute">.use()</span> method is used to mount middleware at a specified path. Middleware are functions that have access to the request (<span class="attribute">req</span>), response (<span class="attribute">res</span>) and next (<span class="attribute">next()</span>) function in the applications request-response cycle.<br/>Below is the boilerplate syntax for this method;<br/><br/><span class="attribute">app.use([path], callbackFunction)</span><br/><br/>The path section is optional, but when used this basically tells the method what path the callback function is to be applied to. If this is not included then the callback function will be applied to all routes.<br/>The callback function element is where a callback function will be defined that tells the route what to do when a valid roue has been matched.<br/><br/>Following on on from the example used in the <span class="attribute">.Router()</span> method, once the <span class="attribute">.Router()</span> method is invoked we can mount it at a specified path using the <span class="attribute">.use()</span> method on our <span class="attribute">app</span> variable.<br/><br/>Syntax for this is shown below;<br/><br/><span class="attribute">const monstersRouter = express.Router();<br/><br/>app.use('/monsters', monstersRouter);<br/><br/>monstersRouter.get('/:id', (req, res, next) => {<br/>const monster = monsters[req.params.id];<br/>if (monster) {<br/>res.send(monster);<br/>} else {<br/>res.status(404).send();<br/>}<br/>});</span><br/><br/>In the <span class="attribute">.use()</span> method you can see that we specify the path that we want the <span class="attribute">monstersRouter</span> to be mounted on.<br/>The <span class="attribute">.get()</span> method underneath this then demonstrates how we can invoke things like <span class="attribute">.get()</span> or <span class="attribute">.post()</span> methods on this new route.<br/>The interesting part of this is that on the <span class="attribute">.get()</span> method shown, the path is prepended with the <span class="attribute">'/monsters'</span> path we specified at the point we invoked the <span class="attribute">.Router()</span>.<br/>This means that the <span class="attribute">.get()</span> path is actually parsing requests for <span class="attribute">'/monsters/:id'</span> because of the route we have set up.<br/>So a GET request for <span class="attribute">/monsters/1</span> would be processed by the <span class="attribute">monstersRouter.get()</span> route however a request for <span class="attribute">/animals/1</span> would not.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">module.exports</span></td>
                            <td>Making the routes modular</td>
                            <td>To keep things modular, clean and easily maintainable, the routes are generally kept in separate files with each one containing all of its own related code. These are then required into the main file for use.<br/>The premise is very similar to how we keep things modular within both React and Redux.<br/><br/>In the example below we show how the syntax for this works.<br/><br/>The below code is in the file <span class="code">main.js</span><br/><br/><span class="attribute">const express = require('express');<br/>const app = express();<br/>const monstersRouter = require('./monsters.js');<br/><br/>app.use('/monsters', monstersRouter);</span><br/><br/>The below code is in the file <span class="code">monsters.js</span><br/><br/><span class="attribute">const express = require('express');<br/>const monstersRouter = express.Router();<br/><br/>const monsters = {<br/>'1': {<br/>name: 'godzilla',<br/>age: 250000000<br/>},<br/>'2': {<br/>name: 'manticore',<br/>age: 21<br/>}<br/>}<br/><br/>monstersRouter.get('/:id', (req, res, next) => {<br/>const monster = monsters[req.params.id];<br/>if (monster) {<br/>res.send(monster);<br/>} else {<br/>res.status(404).send();<br/>}<br/>});<br/><br/>module.exports = monstersRouter;</span><br/><br/>Notice how we still have to require in express at the top of the file in order to use express.<br/>In terms of content, we keep the 'database' of monsters in this file along with all the logic for the routes.<br/>In this example we only show a route that deals with GET requests however we would also put PUT, POST and DELETE requests in here too.<br/><br/>At the very bottom of the file we have the <span class="attribute">module.exports</span> keyword that exports the router for use in the <span class="code">main.js</span> file.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Matching routes</td>
                            <td>Its important to remember that in express a full path of a request can be segmented. This means that we can use modular routes to access different databases and then within those modules we can set up multiple routes to do various things like get all information from a database or get specific information from a database.<br/><br/>In the code below we have 2 files, the first is <span class="code">main.js</span> and the second is the module for our monsters database and routes (<span class="code">monsters.js</span>).<br/>In this example we have 2 databases set up, 1 for animals and another for monsters, for this particular example we're not going to show any of the animals module.<br/><br/>The below code is in the file <span class="code">main.js</span><br/><br/><span class="attribute">const express = require('express');<br/>const app = express();<br/><br/>const animalsRouter = require('./animals.js');<br/>const monstersRouter = require('./monsters.js');<br/><br/>app.use('/animals', animalsRouter);<br/>app.use('/monsters', monstersRouter);</span><br/><br/>The below code is in the file <span class="code">monsters.js</span><br/><br/><span class="attribute">const express = require('express');<br/>const monstersRouter = express.Router();<br/><br/>monstersRouter.get('/', (req, res, next) => {<br/>res.send(getAllMonsters());<br/>});<br/><br/>monstersRouter.get('/:id', (req, res, next) => {<br/>const monster = getMonsterById(req.params.id);<br/>if (monster) {<br/>res.status(200).send(monster);<br/>} else {<br/>res.status(404).send('Monster not found');<br/>}<br/>});<br/><br/>module.exports = monstersRouter;</span><br/><br/>Lets say we have a GET request that comes in that looks like the following;<br/><span class="code">GET /monsters/</span><br/><br/>Due to the way we have our server set up to work with modular routes the request will be processed in the following way;<br/><br/>It will analyse the path segment by segment.<br/>It will begin by matching the first segment (<span class="code">/monsters</span>) to the monsters module and then move into the <span class="code">monsters.js</span> module file to carry on matching the rest of the path with any valid routes that might be set up.<br/><br/>Looking at the <span class="code">monsters.js</span> file we can see that the first route matches the next segment of the GET request path which is <span class="code">'/'</span>.<br/>We can see that this route has been set up to send back all of our monsters.<br/><br/>If we had a GET request that looked like the following;<br/><span class="code">GET /monsters/34</span><br/><br/>This would follow the same process however because the second segment of the path is <span class="code">'/34'</span> rather than <span class="code">'/'</span> express would skip the first route it finds in the <span class="code">monsters.js</span> file and match to the second route which has been set up to dynamically accept ID's.<br/>In this case the route would look for a monster in the database with the ID of 34 and then send that back if it exists.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="API_fundamentals">
                <h2>API fundamentals</h2>
                <p>This section explains some of the fundamental principles of REST, RESTful API's and API's in general.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>REST</td>
                            <td>Representational State Transfer (REST) is the architecture behind a specific type of web service. It consists of standards and constraints for sharing data between different systems.<br/>Systems that implement this architecture are known as RESTful.<br/><br/>A simple way of visualising what REST is would be to compare it to physical collections of music, movies or TV programmes against a streaming service.<br/>If you want to listen to a specific track, the entire album must be copied and duplicated and then distributed however with a streaming service a singular track can be shared via a reference to a song title and doesn't require a copy of the entire album to be made. The streaming service is RESTful whereas the physical collection is not.<br/><br/>An Application Programming Interface (API) is an interface that allows software programmes to communicate with one another. A RESTful API is the same but it is constrained by the principles of REST.<br/>In a web API a server receives a request through a URL endpoint and sends a response in return which is often data in JSON format.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>REST Principles</td>
                            <td>There are 6 main constraints that define REST;<br/><br/><span class="attribute">Uniform Interface</span><br/>The interface of components must be the same. URI standards must be used to identify resources which basically means paths should be used that could be entered into the browser location bar.<br/><br/><span class="attribute">Client-Server</span><br/>There is a separation of concerns between the client and the server.<br/><br/><span class="attribute">Stateless Interactions</span><br/>All requests contain all of the information needed for that request. It does not rely on any session state.<br/><br/><span class="attribute">Cacheable</span><br/>The client can cache resources.<br/><br/><span class="attribute">Layered System</span><br/>The client can be connected to the end server or an intermediate layer such as a load balancer.<br/><br/><span class="attribute">Code on Demand</span><br/>This is optional but a client can download code, which reduces visibility from the outside.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Response codes</td>
                            <td>The status codes received back from a server when requests have been made are an easy way to understand, at a high level, what is going on with a request.<br/>There are a 5 categories of status codes and they can be defined as;<br/><br/><span class="attribute">1xx</span> - Information<br/><span class="attribute">2xx</span> - Success<br/><span class="attribute">3xx</span> - Redirection<br/><span class="attribute">4xx</span> - Client error<br/><span class="attribute">5xx</span> - Server error</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>REST API Endpoints</td>
                            <td>API's allow data to be accessed via endpoints. An endpoint is the URL path contained in a request such as GET, PUT, POST or DELETE.<br/><br/>An API URL will consist of 2-3 main elements. these are the root, the path and optional query strings (dependent on what the request is doing).<br/><br/><span class="attribute">Root</span><br/>The root of the API is the domain of the site, sometimes it might also contain the version of the API.<br/><span class="code">https://my.api.com</span> or <span class="code">https://my.api.com/v3</span><br/><br/><span class="attribute">Path</span><br/>The unique location of the specific resource being accessed.<br/>This is usually the part of the path that a route will be written for on the server.<br/><span class="code">/users</span> or <span class="code">/users/25</span><br/><br/><span class="attribute">Query Parameters</span><br/>This is the optional element that will not always be present.<br/>It will hold the key:value pairs for the request but could also contain things like limits to only return a specified number of results.<br/><span class="code">?name=josh&age=35</span> or <span class="code">?limit=10</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Guidelines on creating RESTful API Endpoints</td>
                            <td>There are a few naming conventions with regards to API endpoints.<br/><br/><span class="attribute">Paths should be plural</span><br/>It is likely that databases are for mass information and not singular things therefore the convention is for the endpoint segment to be plural<br/><span class="code">/users/5</span> as opposed to <span class="code">/user/5</span><br/><br/><span class="attribute">Endpoints should not display the file extension</span><br/>The API might be returning JSON data or similar however the URL should not end in .json or.js etc.<br/><br/><span class="attribute">Endpoints should use nouns and not verbs</span><br/>Words like <span class="code">add</span> or <span class="code">delete</span> should not appear in RESTful API URL's. These kind of actions should be handled by the routes written on the server.<br/><br/><span class="attribute">Paths are case sensitive</span><br/>Paths should be written in lowercase with the use of hyphens instead of underscores.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
                        <div id="middleware">
                <h2>Middleware</h2>
                <p>This section explains some of the ideas behind middleware in general.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Middleware and the stack</td>
                            <td>Middleware is code that executes between a server receiving a request and sending a response. It operates on the boundary, so to speak, between those two HTTP actions.<br/><br/>In Express, middleware is a function. (<span class="attribute">app.use()</span> or <span class="attribute">app.get()</span> etc...)<br/>Middleware can perform logic on the request and response objects, such as: inspecting a request, performing some logic based on the request, attaching information to the response, attaching a status to the response, sending the response back to the user, or simply passing the request and response to another middleware. Middleware can do any combination of those things or anything else a Javascript function can do.<br/><br/>Most of Express's functionality lies around chaining middleware together. The chain of middleware is called the middleware stack.<br/><br/>The middleware stack is processed in the order that each middleware appears in the application file.<br/>This happens regardless of method so if an <span class="attribute">app.get()</span> is the first thing in the application followed by an <span class="attribute">app.use()</span> then the get method will still get called first.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>DRY coding</td>
                            <td>Don't Repeat Yourself (DRY) coding is the practice of minimising the amount of similar code in order to reduce the possibility of bugs.<br/>For example the below code demonstrates 3 very similar functions;<br/><br/><span class="attribute">const addFive = number => {<br/>const fiveAdded = number + 5;<br/>console.log(`Your number plus 5 is ${fiveAdded}`);<br/>}<br/><br/>const addTen = number => {<br/>const tenAdded = number + 10;<br/>console.log(`Your number plus 10 is ${tenAdded}`);<br/>}<br/><br/>const addTwenty = number => {<br/>const twentyAdded = number + 20;<br/>console.log(`Your number plus 20 is ${twentyAdded}`);<br/>}</span><br/><br/>These functions could be refactored to something like the function below;<br/><br/><span class="attribute">const addNumber = (number, addend) => {<br/>const numAdded = number + addend;<br/>console.log(`Your number plus ${addend} is ${numAdded}`);<br/>}</span><br/><br/>The new refactored code reduces the amount of code required to carry out the same task. It is less prone to mistakes because there are less things to go wrong with it.<br/>This is the fundamental principle behind DRY coding.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">app.use()</span></td>
                            <td>DRYing Routes</td>
                            <td>The principles of DRY coding can also be used for when repeatable functions are used in differing routes.<br/>The <span class="attribute">.use()</span> method can be used to create a repeatable function that gets called whenever a route is invoked.<br/><br/><span class="attribute">app.use((req, res, next) => {<br/>console.log('Request received');<br/>});</span><br/><br/>The above example has no path argument and therefore the callback function will be applied to all routes.<br/>In this example we log a simple message to the console to acknowledge the request however in more complex applications this could be a lot more useful.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">next()</span></td>
                            <td>Next</td>
                            <td>In an application there may be multiple routes defined that are intended to trigger one after the other to provide some specific functionality.<br/><br/>The <span class="attribute">next()</span> method is how we chain middlewares together.<br/>An example of how this is used is shown below;<br/><br/><span class="code">GET /magic/fireball</span><br/><br/><span class="attribute">app.use((req, res, next) => {<br/>console.log("A sorcerer approaches!");<br/>next();<br/>});<br/><br/>app.get('/magic/:spellname', (req, res, next) => {<br/>console.log("The sorcerer is casting a spell!");<br/>next();<br/>});<br/><br/>app.get('/magic/:spellname', (req, res, next) => {<br/>console.log(`The sorcerer has cast ${req.params.spellname}`);<br/>res.status(200).send();<br/>});<br/><br/>app.get('/magic/:spellname', (req, res, next) => {<br/>console.log("The sorcerer is leaving!");<br/>});</span><br/><br/>In the example shown above we receive a GET request. The <span class="attribute">app.use()</span> route is triggered because there is no path assigned and therefore will trigger on every request.<br/>'A sorcerer approaches!' is printed to the console as per the body of the callback function for that route.<br/>Within the callback function we also have a <span class="attribute">next()</span> call.<br/>This call, instead of finishing the process allows the code to pass control onto the next matching route if there is one.<br/>There is another matching route for our GET request therefore the next middleware is invoked and the <span class="attribute">app.get()</span> route is triggered.<br/>'The sorcerer is casting a spell' is printed to the console.<br/>Another <span class="attribute">next()</span> call follows, passing control to the next matching route.<br/>This route matches the GET request and therefore logs the phrase 'The sorcerer has cast fireball' to the console.<br/>Notice however that this callback function does not contain a <span class="attribute">next()</span> call.<br/>This then does not allow control to pass onto our final middleware and instead the process is finished without the final middleware triggering even though the route is valid and matches our request.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Using middleware to provide checking logic to multiple routes</td>
                            <td>On many routes there is likely the need to provide checking logic against submitted information. Checking against usernames, passwords, whether submitted information is formatted correctly or even orf the correct type.<br/><br/>Following the the principles of DRY coding we can write a middleware that does this for us, and even more importantly we can write route specific versions of this.<br/><br/>Lets say we have an application that has multiple endpoints, each one providing different functionality to our website.<br/>Things like <span class="code">/jellyBean</span>, <span class="code">/lollipop</span>, <span class="code">/iceCream</span> etc...<br/>Lets also say that we have various routes defined in our application on the <span class="code">/jellyBean</span> route.<br/><br/>On those routes we want to provide targetted checking logic. This is to make sure that whatever <span class="code">/jellyBean</span> requests come in, look for valid information held in our database.<br/>To do this we can create a middleware that only targets this endpoint for whatever GET, PUT, POST or DELETE request might come in .<br/>This will serve as the first stop in the middleware chain to provide the check to ensure the request is valid before spending any further processing power on the request.<br/>It will also allow us to take all of this additional checking logic out that previously would be held in each individual callback functions of the various GET, PUT, POST and DELETE routes.<br/><br/><span class="attribute">app.use('/jellyBean', (req, res, next) => {<br/>const productName = req.params.productName;<br/>if (!productDatabase[productName]) {<br/>console.log('Response Sent');<br/>return res.status(404).send('Product with that name does not exist');<br/>}<br/><br/>next();<br/>});</span><br/><br/>The code above invokes the <span class="attribute">.use()</span> method and mounts it on the <span class="code">/jellyBean</span> path endpoint. This means any request that comes in on that path will first be run through the middleware to check the request is valid.<br/>The checking logic here is not important as its just a generic logic to demonstrate the point however within the checking logic notice how there is a <span class="attribute">return</span> on the <span class="attribute">if</span> statement.<br/>This is important as it provides a break point for the code if the request fails the checking logic. It stops the code from running any further and provides a 404 failure code back to the front end.<br/><br/>Notice also how at the end of the callback functions body is a <span class="attribute">next()</span> call. This ensures that if the request is deemed valid by the checking logic it will then pass control onto the next matching middleware.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Adding additional parameters to the request object</td>
                            <td>The chaining of middleware allows us to manipulate the requests as they come in.<br/>We might want to do this to allow for simpler logic elsewhere in our back end or to pick out various parameters for manipulation at the next middleware in the chain.<br/><br/>To do this is quite simple.<br/><br/><span class="attribute">app.use('/endpoint', (req, res, next) => {<br/>req.keyOne = valueOne;<br/>req.keyTwo = valueTwo;<br/>next();<br/>});</span><br/><br/>In the above example middleware we have, within the callback function, 2 new parameters added to the request object. As you can see it is as simple as adding them to the request object like we would with any normal addition to any object.<br/>We assign it a key and then assign that key a value.<br/>These properties will now be accessible by the next middleware as that will receive the updated request object.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">app.use(['/path1', 'path2'], callbackFunction)</span></td>
                            <td>Targetting multiple routes to reduce code</td>
                            <td>The <span class="attribute">.use()</span> method allows for multiple paths to be used in the first path argument provided they are presented as an array.<br/>This is a powerful option as it allows us to use a single middleware to provide the same functionality to multiple routes that require it without having to duplicate our code.<br/>This builds on the DRY coding principles of reducing the amount of code needed.<br/><br/>We can use this just as we did with the singular route to provide checking logic to a route before allowing the code to continue processing.<br/>This however will be applicable to multiple routes.<br/><br/><span class="attribute">app.use(['/jellyBean', '/lollipop', '/iceCream'], (req, res, next) => {<br/>const productName = req.params.productName;<br/>if (!productDatabase[productName]) {<br/>console.log('Response Sent');<br/>return res.status(404).send('Product with that name does not exist');<br/>}<br/><br/>next();<br/>});</span><br/><br/>In the example above we have the same code as described in the previous example showing how to apply checking logic in a middleware prior to passing control on to any GET, PUT, POST or DELETE method logic.<br/>The main change and most important thing to notice here is that in the first argument of the <span class="attribute">.use()</span> method we have an array that contains multiple routes.<br/>If a request is received that matches either of these routes then this middleware will trigger and the callback function will be invoked. If there is no match then the app will simply carry on normal and continue looking for a matching route.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">app.use('/path1', callbackFunction1, callbackFunction2)</span></td>
                            <td>Using defined callbacks and using multiple callbacks</td>
                            <td>The <span class="attribute">.use()</span> method also allows for multiple callbacks to be used in the second path argument, these however, do not need to be presented in an array. They can be presented as an array however it is assumed that after the first argument all following arguments will be callback functions.<br/><br/>An example of how this might work is shown below;<br/><br/><span class="attribute">const authenticate = (req, res, next) => {<br/>//Authentication logic in here...<br/>next();<br/>};<br/><br/>const validateData = (req, res, next) => {<br/>//validation logic in here...<br/>next();<br/>};<br/><br/>const getSpell = (req, res, next) => {<br/>res.status(200).send(getSpellById(req.params.id));<br/>};<br/><br/>const createSpell = (req, res, next) => {<br/>createSpellFromRequest(req);<br/>res.status(201).send();<br/>};<br/><br/>const updateSpell = (req, res, next) => {<br/>updateSpellFromRequest(req);<br/>res.status(204).send();<br/>}<br/><br/>app.get('/spells/:id', authenticate, getSpell);<br/><br/>app.post('/spells', authenticate, validateData, createSpell);<br/><br/>app.put('/spells/:id', authenticate, validateData, updateSpell);</span><br/><br/>In the code above we have 5 defined functions each doing various different things.<br/>At the bottom we have our GET, POST and PUT routes. Notice how instead of writing anonymous functions with their own logic we have inserted the named functions.<br/>These will process one after the other in the order they are written. Provided a <span class="attribute">next()</span> call is also included at the end of each function it will then pass control onto the next function in the list of arguments.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">morgan()</span></td>
                            <td>Using open source middleware</td>
                            <td>Open source middleware can be installed and required in to allows us to spend less time creating functions that already exist as open source entities.<br/>As an example <span class="attribute">morgan()</span> is a request logging middleware that we can use in our application that provides us with console logs on the requests being made to our server.<br/><br/>Lets run though an example of how we can install and use this open source middleware in our application.<br/><br/>Because <span class="attribute">morgan()</span> is external we need to install it first. We do this in the usual way on our command line;<br/><br/><span class="code">npm i morgan</span><br/><br/>Then within our application we need to require it in;<br/><br/><span class="attribute">const morgan = require('morgan');</span><br/><br/>As with most open source middleware, there will be various instructions on how to use it with information on possible arguments it can take etc. the npm site for morgan goes through these and can be found <a href="https://www.npmjs.com/package/morgan" target="_blank">here</a>.<br/>For our example we will be using the argument <span class="attribute">'tiny'</span> as this will give us a minimal log to the console that lets us know the method of the request, endpoint being used, response code, response itself and then the response time<br/><br/>Once <span class="attribute">morgan()</span> is in our application we can then mount it as a route with the below code;<br/><br/><span class="attribute">app.use(morgan('tiny'));</span><br/><br/>This middleware has all of the expected functions it receives a <span class="attribute">req</span>, <span class="attribute">res</span> and <span class="attribute">next</span> argument and then sends them on. This small line of code essentially replaces something like the below;<br/><br/><span class="attribute">app.use((req, res, next) => {<br/>console.log(`${req.method} Request Received`);<br/>next();<br/>});</span><br/><br/>It reduces the amount of code to sift through and provides more information.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">bodyParser()</span></td>
                            <td>Using open source middleware to process the body of a request</td>
                            <td>An HTTP request will often include a body.<br/>This is block of information sent to the server for processing. This could be anything like details for the registration of a new user or a comment posted by a user.<br/><br/>Dealing with this can require some fairly complex code however there are open source middlewares available that will be continually kept up to date that can do this for us.<br/><br/>One example of this is <span class="attribute">body-parser</span>.<br/>As with our previous open source middleware example we need to install it as a dependency through our command line and then require it into our application before using.<br/><br/><span class="code">npm i body-parser</span><br/><br/>And then we require it in;<br/><br/><span class="attribute">const bodyParser = require('body-parser');</span><br/><br/>Finally we apply it our routes;<br/><br/><span class="attribute">app.use(bodyParser.json());</span><br/><br/>This simple line of code provides greater functionality in far fewer lines than something like the code shown below;<br/><br/><span class="attribute">const bodyParser = (req, res, next) => {<br/>let queryData = '';<br/>req.on('data', (data) => {<br/>data = data.toString();<br/>queryData += data;<br/>});<br/>req.on('end', () => {<br/>if (queryData) {<br/>req.body = JSON.parse(queryData);<br/>}<br/>next();<br/>});<br/>};</span><br/><br/>Now the interesting thing here is that this open source middleware comes with its own methods and this is an important thing to note generally on external middlewares.<br/>They will have their own instructions for use and reading the documentation on how to operate these correctly is something that cannot be skipped.<br/>In the above example we call the <span class="attribute">bodyParser</span> and invoke its own <span class="attribute">.json()</span> method upon it. This will parse all body information into JSON format.<br/>Without reading the documentation this would not be immediately obvious.<br/><br/>Further documentation for this particular middleware can be found <a href="https://www.npmjs.com/package/body-parser" target="_blank">here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">Error</span></td>
                            <td>Error handling middleware</td>
                            <td>Error handling middleware needs to be the last <span class="attribute">app.use()</span> in your file. If an error happens in any of our routes, we want to make sure it gets passed to our error handler. The middleware stack progresses through routes as they are presented in a file, therefore the error handler should sit at the bottom of the file right before our <span class="attribute">app.listen()</span> call at the very bottom.<br/><br/>In examples above we provide error handling in each request route but these don't provide information or options to do anything other than send back an error code.<br/>Implementing error handling middleware allows us to introduce additional logic to give us more feedback on the error and even possibly do something about it.<br/><br/>Below is an example of the syntax used for creating the error handling middleware;<br/><br/><span class="attribute">app.use((err, req, res, next) => {<br/>const status = err.status || 500;<br/>res.status(status).send(err.message);<br/>console.log(`${err.message}`);<br/>});</span><br/><br/>Notice that in addition to our usual <span class="attribute">req</span>, <span class="attribute">res</span> and <span class="attribute">next</span> arguments we also now include the <span class="attribute">err</span> argument.<br/>This is the error object that will be created and passed into the middleware in the event of our app encountering and then creating a new error.<br/>Within the body of this middleware we are also referencing status codes and error messages with the assumption that these details will be passed down to us through the middleware stack.<br/>Because of this flow of information down the stack we then want to refactor our other middlewares to create and pass this information down so that we can properly process this information in the event of an error.<br/><br/>As an example lets take the below code that has its own error code handling within the middleware itself.<br/><br/><span class="attribute">app.use('/jellyBean', (req, res, next) => {<br/>const productName = req.params.productName;<br/>if (!productDatabase[productName]) {<br/>return res.status(404).send('Product with that name does not exist');<br/>}<br/><br/>next();<br/>});</span><br/><br/>This does the job perfectly fine but in our new error handling middleware set up this doesn't pass any information on to enable us to see what else is going. Its just a static error.<br/>Below is an example of the same middleware refactored to create an error object, add information to that object and then invoke our error handling middleware whilst passing this information on to it.<br/><br/><span class="attribute">app.use('/jellyBean', (req, res, next) => {<br/>const productName = req.params.productName;<br/>if (!productDatabase[productName]) {<br/>let productError = new Error('Product with that name does not exist');<br/>productError.status = 404;<br/>return next(productError);<br/>}<br/><br/>next();<br/>});</span><br/><br/>Notice how we still have the same type of information (the status code, the error message) however, we create a new error object, add the status code to that object as well as the message and then we return the <span class="attribute">next()</span> call including the new error object as the argument.<br/>This bit is particularly important as the return breaks the stack.<br/>Instead of passing control to the next middleware this, if invoked, recognises an error and skips everything else and progresses straight to our error handling middleware.<br/>Because we have created an error object these elements are accessed using dot notation.<br/>So the error message would be accessible at <span class="attribute">err.message</span> and we can see that we define the status code at <span class="attribute">err.status</span><br/><br/>While our given example doesn't do much with this information other than send a message, in more complex applications this provides us with an opportunity for more interactivity with the error.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Express.js maintained middleware</td>
                            <td>The Express.js team maintain a list of useful middleware.<br/>Some of this used to be bundled in with Express however to reduce bloat it can simply be required in as necessary.<br/><br/>The full list can be found on the <a href="https://expressjs.com/en/resources/middleware.html" target="_blank">Express.js Middleware Website</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.param()</span></td>
                            <td>Parameter matching in middleware</td>
                            <td>In many of our routes we are likely using parameters as placeholders to match to certain elements on our backend, things like items in a database for example.<br/>Due to the fact that we don't know what the user input will be, the code body of that middleware will likely have some sort of checking logic. This provides us with a sense check on the request before progressing any further.<br/>So, for example, if the requested item does not exist we can quickly return an error indicating that the item doesn't exist before processing any further code.<br/><br/>Having this sense checking logic inevitably ends up in the same sense checking logic being written multiple times as the app grows in complexity and more middlewares are required to do various tasks.<br/>The <span class="attribute">.param()</span> method allows us to write a middleware that provides a sense check once and simplify the rest of the middlewares into doing what we actually want them to do, thereby using DRY coding principles and simplifying the code.<br/><br/>An An example is shown below;<br/><br/>Lets say that we have our database of jellybeans and then on our backend we have multiple middlewares that provide GET, PUT, POST and DELETE functionality.<br/>Each one of those middlewares will have an endpoint that looks like the following;<br/><span class="code">/jellyBean/:jellyBeanId</span><br/><br/>As mentioned above, because we don't know what the user request will be, we will need to provide checking logic against each of these endpoints for the <span class="code">:jellyBeanId</span> parameter to ensure the request is valid.<br/>This means the same logic will need to be written 4 times, once for each of the middlewares.<br/>The logic for the GET request might look something like the below;<br/><br/><span class="attribute">app.get('/jellyBean/:jellyBeanId', (req, res, next) => {<br/>const params = req.params.jellyBeanId;<br/>const jellyBeanId = jellyBeanDatabase.findIndex(jellyBean => jellyBean.id === params;);<br/>if (jellyBeanId !== -1) {<br/>res.send(jellyBeanDatabase[params]);<br/>} else {<br/>res.status(404).send('JellyBean Not Found');<br/>});</span><br/><br/>However we can avoid this by using the <span class="attribute">.param()</span> method and creating a new middleware that is ordered to trigger before any of these other middlewares.<br/>Our <span class="attribute">.param()</span> method should be placed above any of the routes, so it triggers first, and then in this case it might look something like the below;<br/><br/><span class="attribute">app.param('jellyBeanId', (req, res, next, id) => {<br/>const jellyBeanId = Number(id);<br/>const found = jellyBeanDatabase.findIndex(jellyBean => jellyBean.id === jellyBeanId);<br/>if (found !== -1) {<br/>req.jellyBeanIndex = found;<br/>next();<br/>} else {<br/>res.sendStatus(404);<br/>}<br/>})</span><br/><br/>There are a few things to note here, the first is that the route handler doesn't contain a <span class="attribute">:</span> before the parameter, it's just <span class="attribute">jellyBeanId</span>. The parameter is passed into the callback function, which now has 4 arguments. The last one being that parameter.<br/>Within our logic we do a quick check to make sure its a number and then store that parameter in a variable.<br/>This is then used in a <span class="attribute">.findIndex()</span> method to check our database to see if an entry that matches that index exists, if it does then that number is stored in the variable <span class="attribute">found</span>.<br/>After this we have a simple <span class="attribute">if...else</span> statement that attaches that index number to the <span class="attribute">req</span> object under <span class="attribute">jellyBeanIndex</span> for future use in other middlewares, or if the logic fails we send back an error status code.<br/><br/>With this no in place we can refactor all of our GET, PUT, POST and DELETE requests to remove any checking logic as the <span class="attribute">.param()</span> middleware will do it first before passing it on to the relevant route handlers.<br/>So for example our GET route from earlier might be refactored to look like the below;<br/><br/><span class="attribute">app.get('jellyBean/:jellyBeanId', (req, res, next) => {<br/>res.send(jellyBeanDatabase[req.jellyBeanIndex]);<br/>});</span><br/><br/>Notice how much simpler the route becomes. Also notice how we now use the new request object parameter of <span class="attribute">.jellyBeanIndex</span> to send back the relevant information as we have already done the check and created this parameter in the <span class="attribute">.param()</span> middleware.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">{ mergeParams: true }</span></td>
                            <td>Nested routes and merging parameters</td>
                            <td>The nesting of routes has already been covered, its a useful method to separate concerns in larger apps in a similar way that modules deal with differing parts of an app in React applications.<br/><br/>In React, if we want a child module to access data from the parent module we can pass it down through props.<br/>We can do a similar thing in express with routes. We can allow the parameters from a parent route to be used in a child route.<br/><br/>Lets say we have a database of sorcerers and then a separate database of spells.<br/>Multiple sorcerers might use the same spell, meaning that our route is likely to have a <span class="attribute">:sorcererId</span> style parameter in its route.<br/>As such we might then have a <span class="attribute">.param()</span> middleware that extracts this parameter.<br/>This parameter can be passed down for use in nested routes much like props are used in React applications.<br/>In order to do that we need to tell express that we want these parameters to be passed down. We do this by including a configuration object when we define the router.<br/>The syntax for this is shown below;<br/><br/><span class="attribute">const parentRouter = express.Router();<br/>const nestedChildRouter = express.Router({ mergeParams: true });</span><br/><br/>So now that we have told express that we want the parameter of the parent router to be passed down to the nested child router we can then reference those parameters without the need to specifically define them in some way.<br/><br/>The reason this is important is that the normal behaviour in express for nested child routers is that if the parent route includes parameters (<span class="attribute">:sorcererId</span>) these parameters are not available inside the nested child route by default.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
                        <div id="authentication_authorization">
                <h2>Authentication & Authorization</h2>
                <p>This section explains some of the concepts and syntax behind User authentication and authorization in general.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Authentication</td>
                            <td>Authentication is the process of verifying who you are.<br/><br/>This can be through supplying username and passwords or username and PIN codes. There can be various different identifier and entry code style combinations, all of which should be unique to each person.<br/><br/>A username and password system is known as single factor, it is also becoming increasingly insecure.<br/>Multi factor authentication is the process of logging in using a username and password and then receiving a secondary temporary passcode on a secondary laptop, phone or email address. This way the genuine user who has set up this login system has access to the various devices being used to log in and therefore makes it much harder for anyone else to gain access as they are unlikely to have access to the additional devices/email addresses.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Authorization</td>
                            <td>Authorization is the verification of what you are allowed to do.<br/><br/>You might be logged in, however you might not be allowed to edit other user's information unless you have administrator privileges.<br/><br/>Authorization prevents users from accessing parts of an application which they are not intended to access.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Encryption</td>
                            <td>Encryption is the process of transforming data into an unreadable format unless you have the correct key to decode the data.<br/><br/>This prevents information from being stolen/intercepted and therefore prevents things like authentication and authorization from being overridden.<br/><br/>There are two main types of encryption, single key and asymmetrical.<br/><br/>Single key encryption is the process of encoding the data with a key that both the sender and the receiver possess.<br/><br/>Asymmetrical encryption is the process of encoding the data with one key on the sender's side and then decoding it with another key on the receiver's side.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Sessions & Cookies</td>
                            <td>Websites can often provide personalised user experiences. Things like colour changes to the homepage or providing customised search options etc.<br/>This can be done through a user logging in, but it can also be done on a temporary basis through the use of sessions.<br/>A session is similar to a temporary login.<br/>The user can make various changes to suit their preference and the app can remember these, keeping their preferences consistent during the user's browsing time.<br/><br/>Session data is stored server-side and associated with a session ID.<br/>Sessions are best thought of as short term memory for a web app.<br/><br/>While session data is stored server side, the actual ID associated with that data is kept client side. This is done in the form of cookies.<br/><br/>Cookies are small text files no bigger the 4kb.<br/>The browser stores these and they are automatically sent with HTTP requests to a web app.<br/>They are set by the HTTP response header in key-value pairs. A session cookie is et set with the first HTTP response from the server and persists until the browser is closed or the cookie expires.<br/>They look similar to the example below;<br/><br/><span class="attribute">Set-Cookie: sessionID=34jgL79b</span><br/><br/>A session would usually follow the events listed below;<br/>1. User navigates to a site. The web server creates a session and a session ID.<br/>2. In the server's response, it tells the browser to store a cookie with the session ID. The should not include any personal information.<br/>3. The session ID cookie automatically attaches to each HTTP request to the server.<br/>4. When the server reads the session ID cookie sent t=with the HTTP request, it returns the session data associated with the ID.<br/>5. The process continues as long as the session is active.<br/>6. The session and session ID cookie expires after a user closes out the browser, logs out or a pre-determined time passes.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Cookie security</td>
                            <td>Cookies can contain sensitive information, including things like personal preferences and browsing history.<br/>To prevent malicious actors from gaining access to this information we can provide security to the cookies. This can range from simple expiration dates set on the cookies to other keywords that can prevent cross site scripting attacks.<br/><br/>Below is an example of setting a cookie with an expiration date and time;<br/><br/><span class="attribute">Set-Cookie:Key=Value; expires=Saturday, 01-May-2027 07:30:00 GMT</span><br/><br/>We can also add additional keywords after this to provide added security.HTTPOnly ensures that the cookie data is not accessible to a script running client-side. This will prevent cross site scripting attacks.<br/>Example syntax is shown below;<br/><br/><span class="attribute">Set-Cookie:Key=Value; expires=Saturday, 01-May-2027 07:30:00 GMT; HTTPOnly</span><br/><br/>2 other common keywords are;<br/><br/><span class="attribute">SameSite</span> - This helps prevent cross site request forgery attacks<br/><br/><span class="attribute">Secure</span> - This makes sure that cookies are only sent with a request to an HTTPS page<br/><br/>There are further options which can be found with detailed explanations <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Set-Cookie" target="_blank">here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">localStorage</span> & <span class="attribute">sessionStorage</span></td>
                            <td>Local Storage & Session Storage</td>
                            <td>Cookies provide a way of accessing sessions however the attaching the data to each request, constantly sending it back and forth can affect site performance. Cookie data is also limited to just 4kb which is very small.<br/><br/><span class="attribute">localStorage</span>/<span class="attribute">sessionStorage</span> are newer forms of client side storage introduced when HTML5 came out.<br/><br/><span class="attribute">localStorage</span> stores data in browser as key-value pairs. It can also store up to 10MB of data, a significant increase.<br/>It does not interact with the server but is modified and accessed by client side JavaScript code.<br/>It also persists after the users has closed the browser, it will clear once the browser cache is deleted.<br/><br/><span class="attribute">sessionStorage</span> uses the same syntax as <span class="attribute">localStorage</span> but holds session data. It can only hold 5MB of data but still a lot more than cookies. This does clear when the browser or tab is closed and therefore is more secure as well as being more of a temporary measure.<br/><br/>To set key-values to local storage the syntax would be as follows;<br/><br/><span class="attribute">localStorage.setItem('key', 'value');</span><br/><br/>A practical example of this is shown below;<br/><br/><span class="attribute">function selectProfile(name){<br/>if (name != localStorage.getItem('profile')) {<br/>alert("Now setting character to... " + name)<br/>}<br/>localStorage.setItem('profile', name);<br/>}</span><br/><br/>In the example above we set the key to <span class="attribute">'profile'</span> and we use a variable that is set by some incoming value to set the value. This is then stored in <span class="attribute">localStorage</span> and can be accessed later.<br/><br/>To access this information we would use the syntax;<br/><br/><span class="attribute">localStorage.getItem('key');</span><br/><br/>Once again, a practical example of this would be;<br/><br/><span class="attribute">function loadProfile(){<br/>// Set character to the 'profile' value from localStorage<br/>var character = localStorage.getItem('profile');<br/><br/>if (character) {<br/>display_character(character)<br/>}<br/>}</span><br/><br/>This accesses the <span class="attribute">localStorage</span> key of <span class="attribute">'profile'</span> and returns its value which is then used to display a character elsewhere in the web app.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Session Security</td>
                            <td>Session security is important to prevent hijacking by malicious actors. For example if someone is doing some internet banking and their session gets hijacked, the malicious actor could transfer funds from the victims bank to another account.<br/>There are a few good practice elements that can be implemented to help prevent this;<br/><br/><span class="code">Define session expiry</span><br/>Simply by ensuring that a session has a time limit can close the window to anyone with malicious intent.<br/>Automatic session expiry on the back end and then session expiry on the client side significantly impacts a hacker's window to get in and cause harm.<br/>Idle timeouts are popular but absolute timeouts are an even stricter way to ensure security albeit at the expense of possibly annoying users with the need to consistently refresh the session.<br/><br/><span class="code">Make Session ID's difficult to hack</span><br/>Session ID's are basically passwords. The longer and more complex they are, the more difficult it is for a hacker to gain access.<br/>They are ideally over 128 bits long and do not contain any kind of personal information to reduce the possibility of guessing.<br/>Any kind of algorithm should also not follow any kind of predictable pattern which would aid hacking.<br/><br/><span class="code">Securing Cookies</span><br/>If cookies are to be used then they should be secured with the keywords already discussed. This makes them harder to steal.<br/><br/><span class="code">Enforce HTTPS</span><br/>All sessions based web apps should enforce HTTPS for communications. This prevents web attacks and prevents the attacker gaining access to the session.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>HTTP Security Headers</td>
                            <td>HTTP security headers are response headers that get sent back by the server upon a request. They include security information, telling the browser how to behave and what security policies it should be employing with the web app.<br/>By implementing these security policies they prevent numerous attacks and are generally good practice in providing a more secure environment all round.<br/><br/>There are numerous options and there will be multiple employed in a well written app.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">Strict-Transportation-Security</span></td>
                            <td>HTTP Security Headers</td>
                            <td>This header tells the browser that only the HTTPS version of the requested site is available. This means only HTTPS can be used and therefore the communication between them is more secure.<br/><br/><span class="attribute">Strict-Transport-Security: max-age31536000; includeSubDomains</span><br/><br/>The above example defines that the browser should remember that this app is only to be accessed using HTTPS for the length of 1 year (31536000 seconds), the <span class="attribute">includeSubDomains</span> keyword also tells it to apply this to sub domains of the app.<br/><br/><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Strict-Transport-Security" target="_blank">More detailed information on this header can be found here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">Content-Security-Policy</span></td>
                            <td>HTTP Security Headers</td>
                            <td>This defines an allowlist of where content is to be loaded from. It restricts assets the browser can load while using the current website. It prevents cross site scripting attacks by defining that the browser cannot load JavaScript from other sources than those defined by the header.<br/><br/><span class="attribute">Content-Security-Policy: script-src 'self'; img-src 'self' https://www.thiswebsite.com</span><br/><br/>The above example defines that the browser should not load scripts or images from any other source than https://thiswebsite.com<br/><br/><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CSP" target="_blank">More detailed information on this header can be found here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">X-Frame-Options</span></td>
                            <td>HTTP Security Headers</td>
                            <td>This header stops the current page from being hidden in an <span class="code">&lt;iframe&gt;</span> tag in another sites HTML. This prevents clickjacking which is the process of deceiving the user to click on something they think is harmless when in fact its actually an invisible button that redirects to something more nefarious such as delete account or transfer funds etc.<br/><br/><span class="attribute">X-Frame-Options: DENY</span><br/><br/>The above example means that the webpage cannot be hidden in a <span class="code">&lt;iframe&gt;</span> tag anywhere. There are other options that allow partial access if necessary<br/><br/><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Frame-Options" target="_blank">More detailed information on this header can be found here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">helmet()</span></td>
                            <td>How to set security headers in express using Helmet</td>
                            <td>Helmet is a middleware that can be installed and then used to set the security headers.<br/>You can install it in the usual way;<br/><br/><span class="code">npm install helmet</span><br/><br/>It is then implemented within the server in the usual way;<br/><br/><span class="attribute">const helmet = require('helmet');<br/>app.use(helmet());</span><br/><br/>There are numerous options to configure the middleware however the default options set most of the headers as standard<br/><br/><a href="https://www.npmjs.com/package/helmet/v/6.1.2" target="_blank">More detailed information on this header can be found here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>How to set security headers in other common servers</td>
                            <td><span class="code">nginx</span><br/>The following is added to an nginx server's config file to add the <span class="attribute">Strict-Transport-Security</span> header to all HTTP responses;<br/><br/><span class="attribute">add_header Strict-Transport-Security: 'max-age31536000; includeSubDomains always;'</span><br/><br/><a href="https://blog.nginx.org/blog/http-strict-transport-security-hsts-and-nginx" target="_blank">This link</a> details the options for this header as well as serving as a guide for adding other headers in the same environment<br/><br/><br/><br/><span class="code">Apache</span><br/>The following is added to an Apache server's config file (located at /etc/httpd/conf/httpd.conf) to add the <span class="attribute">Strict-Transport-Security</span> header to all HTTP responses;<br/><br/><span class="attribute">Header always set Strict-Transport-Security: "max-age31536000; includeSubDomains"</span><br/><br/><br/><br/><span class="code">Microsoft IIS</span><br/>The following is added to the Web.config file's <span class="attribute">&lt;httpProtocol&gt;</span> section;<br/><br/><span class="attribute">&lt;system.webServer&gt;<br/>&lt;httpProtocol&gt;<br/>&lt;customHeaders&gt;<br/>&lt;add name="Content-Security-Policy" value="default-src 'self';" /&gt;<br/>&lt;/customHeaders&gt;<br/>&lt;/httpProtocol&gt;<br/>&lt;/system.webServer&gt;</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
                        <div id="express_session">
                <h2>Express Session</h2>
                <p>This section explains some of the concepts and syntax behind the express session middleware.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">express-session</span></td>
                            <td>Using express session</td>
                            <td>We can use <span class="attribute">express-session</span> middleware on our server to generate unique session ID's.<br/>First we install it in the usual way;<br/><br/><span class="code">npm install express-session</span><br/><br/>Then we require it in to our server in the usual way;<br/><br/><span class="attribute">const session = require('express-session');</span><br/><br/>Once it's installed and present in our server we then need to configure it.<br/>The configuration object has 3 keys, these are;<br/><br/><span class="attribute">secret</span> - This property is a key used for signing and/or encrypting cookies in order to protect our session ID.<br/><br/><span class="attribute">resave</span> - This option, when set to true, will force a session to be saved back to the session data store. This happens even if there have been no changes made.<br/>Typically this should be set to false, however, that depends on the web app's session storage strategy.<br/><br/><span class="attribute">saveUninitialized</span> - This is a boolean value. When set to true, the server will store every new session, even if there are no changes to the session object. This could be useful for track recurring visits from the same browser however this does eat up memory. Setting it to false allows us to save memory.<br/><br/>An example of the configuration object in use is shown below;<br/><br/><span class="attribute">app.use(<br/>session({<br/>secret: 'oai253vj65',<br/>resave: false,<br/>saveUninitialized: false,<br/>})<br/>);</span><br/><br/>In the above example the <span class="attribute">secret</span> value would usually be a random string that is stored in a secure environment variable and not hardcoded like this. It is written like the above as an demonstration.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.MemoryStore()</span></td>
                            <td>Storing session data</td>
                            <td>Sessions are stored in 3 different ways.<br/><br/>1. In-memory (the default option)<br/>2. Databases such as MongoDB or MySQL<br/>3. In a memory cache such as Redis or Memcached.<br/><br/><span class="attribute">express-session</span> provides an in-memory store called <span class="attribute">MemoryStore()</span>. This is automatically set as the default option unless another is specified.<br/><br/>A new store can be instantiated like so;<br/><br/><span class="attribute">const store = new session.MemoryStore();</span><br/><br/>This can then be added to the configuration object like so;<br/><br/><span class="attribute">app.use(<br/>session({<br/>secret: 'oai253vj65',<br/>resave: false,<br/>saveUninitialized: false,<br/>store,<br/>})<br/>);</span><br/><br/>An important note about the above code is that in-memory sessions should only be used in development and not in production as they provide security risks.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">cookie: {}</span></td>
                            <td>Creating session cookies</td>
                            <td>To create a cookie for our session we should define it within the configuration object.<br/>To define the cookie we need to define key-values of the various elements of the cookie we want to create. An example is shown below;<br/><br/><span class="attribute">app.use(<br/>session({<br/>secret: 'oai253vj65',<br/>cookie: { maxAge: 172800000, secure: true, sameSite: 'none'},<br/>resave: false,<br/>saveUninitialized: false,<br/>store,<br/>})<br/>);</span><br/><br/>in the above example we create a cookie that expires in 48 hours, it is only to use HTTPS and then we allow for cross-site. Differing parameters can be added to enable differing cookies to be created.<br><br/><a href="https://expressjs.com/en/resources/middleware/session.html" target="_blank">More detailed information on the options for this can be found here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">req.session</span></td>
                            <td>Using the session to authenticate users</td>
                            <td>We can use the session now it has been configured.<br/>Lets use an example to demonstrate what we might add and how we might utilise the session object.<br/><br/>In this example we have a simple login page that asks for a username and a password.<br/>If a user logs in with the correct credentials we want to create a session.<br/>Within our POST request logic to login we might have something that look like the following;<br/><br/><span class="attribute">if (user.password === password) {<br/>req.session.authenticated = true;<br/>req.session.user = {<br/>username,<br/>password,<br/>}<br/>}</span><br/><br/>Now the above code is an extremely simplified version of the internal logic of a POST request but you can see the essence of what it's doing.<br/>Once the user has passed our checking logic to ensure they are authenticated we'll add an <span class="attribute">authenticated</span> property to the session object that is set to true so that we know they are authentic.<br/>We then add a <span class="attribute">user</span> property that we populate with a new object that contains the received <span class="attribute">username</span> and <span class="attribute">password</span> properties following authentication.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>For additional tags and examples see the <a href="https://expressjs.com/en/5x/api.html" target="_blank">Express.js Website</a> for more info.</p>
        </div>
    </body>
    <footer>

    </footer>
</html>