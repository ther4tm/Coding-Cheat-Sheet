<!DOCTYPE html>
<html>
    <head>
        <title>Express.js Cheat Sheet</title>
        <link href="./resources/css/index.css" type="text/css" rel="stylesheet">
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link rel="preconnect" href="https://fonts.googleapis.com">
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
    </head>
    <body>
        <header>
            <nav>
                <div class="dropdown">
                    <button class="dropdownBtn">Front End</button>
                    <div class="dropdownContent">
                        <a href="./htmlcheatsheet.html">HTML</a>
                        <a href="./csscheatsheet.html">CSS</a>
                        <a href="./javascriptcheatsheet.html">JavaScript</a>
                        <a href="./reactcheatsheet.html">React</a>
                        <a href="./reduxcheatsheet.html">Redux</a>
                    </div>
                </div>
                <div class="dropdown">
                    <button class="dropdownBtn">Back End</button>
                    <div class="dropdownContent">
                        <a href="./nodecheatsheet.html">Node.js</a>
                        <a href="./expresscheatsheet.html">Express.js</a>
                    </div>
                </div>
                <div class="dropdown">
                    <button class="dropdownBtn">Other</button>
                    <div class="dropdownContent">
                        <a href="./commandlinecheatsheet.html">Command Line</a>
                        <a href="./markdowncheatsheet.html">Markdown</a>
                        <a href="./styleguide.html">Style Guide</a>
                    </div>
                </div>
            </nav>
        </header>
        <div class="content">
            <h1>Express.js Cheat Sheet</h1>
            <p>Below is a list of commands, methods and fundamental principles regarding the Express.js server framework including a brief description of what they do and any notes on correct syntax.</p>
            <div id="fundamentals">
                <h2>Fundamentals</h2>
                <p>This section describes some fundamental properties of the Express.js framework.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">express</span></td>
                            <td>Express</td>
                            <td>Express is a node module.<br/>It does not come pre-installed so we need to install it before use. We can do this using <span class="attribute">npm</span> in the terminal.<br/><br/>The correct syntax for this is shown below;<br/><br/><span class="attribute">npm i express</span><br/><br/>Once installed into the project file we can then require it in like any other non-global node module.<br/><br/><span class="attribute">const express = require('express');</span><br/><br/>Once required in we then need to invoke the express method within a variable to then be able to create a server.<br/><br/><span class="attribute">const app = express();</span><br/><br/>With that all now established we can start a server and specify server behavior.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">app.listen()</span></td>
                            <td>Listen method</td>
                            <td>The purpose of a server is to listen for requests, perform whatever action is required to satisfy the request, and then return a response.<br/><br/>In order for our server to start responding, we have to tell the server where to listen for new requests by providing a port number argument to a method called <span class="attribute">app.listen()</span>.<br/>The server will then listen on the specified port and respond to any requests that come into it.<br/>The second argument is a callback function that will be called once the server is running and ready to receive responses.<br/><br/>An example of syntax is shown below;<br/><br/><span class="attribute">const app = express();<br/>const PORT = 4001;<br/><br/>app.listen(PORT, () => {<br/>console.log(`Server is listening on port ${PORT}`);<br/>});</span><br/><br/>In the above example we create a <span class="attribute">PORT</span> variable that contains the port number for our server to listen for instructions on. We then invoke the <span class="attribute">.listen()</span> express method, providing the <span class="attribute">PORT</span> variable as the first argument and a callback function that prints a simple message to the console as the second argument.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Routes</td>
                            <td>Once we have set up the server to listen for any and all requests we then need to establish how it will respond to these requests.<br/>This requires us to create a number of Routes.<br/>Routes in this context are basically like instructions in a similar vein to actions in Redux.<br/><br/>Routes define the control flow for specific requests based on the request's included path and HTTP verb.<br/><br/>So for example, a user on the front end might click a link to look at another page of the website.<br/>This is a get request.<br/>The link clicked by the user triggers a get request to be sent to the back end. The details of how this works will be explained later but our site will have some routes set up to provide appropriate responses to these requests, instructions on what the back end should do next and how it should respond.<br/><br/>There will be many different routes set up to enable different functionality.<br/>They are defined by the specific HTTP verb (GET, POST etc.) and paths.<br/>The path is the part of a request URL after the hostname and port number, so in a request to <span class="code">localhost:4001/monsters</span>, the hostname is <span class="code">localhost</span>, the port the server is listening on is <span class="code">4001</span> and the path is <span class="code">/monsters</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">app.get()</span></td>
                            <td>GET method</td>
                            <td>In express.js the <span class="attribute">.get()</span> method is used to match up any GET requests to the outlined functionality.<br/><br/>The <span class="attribute">.get()</span> method accepts 2 arguments, the first is a path which is usually a string and the second is a callback function that will handle the specific request.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const moods = [{ mood: 'excited about express!'}];<br/>app.get('/moods', (req, res, next) => {<br/>// Here we would send back the moods array in response<br/>});</span><br/><br/>In the above example a route for a GET request with the path of <span class="attribute">/moods</span> has been set up</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.send()</span></td>
                            <td>Send Method</td>
                            <td>Express sends responses using the <span class="attribute">.send()</span> method on the response object. This method will take any input and include it in the response body.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const monsters = [<br/>{ type: 'werewolf' },<br/>{ type: 'hydra' }, <br/>{ type: 'chupacabra' }<br/>];<br/><br/>app.get('/monsters', (req, res, next) => {<br/>res.send(monsters);<br/>});</span><br/><br/>In this example a GET request using the path <span class="code">/monsters</span> will match to a defined route. Express will match this route and call the callback function.<br/>In the response body it shows that the route has been set up to use the <span class="attribute">.send()</span> method on the response object with the argument <span class="attribute">monsters</span>.<br/>Above this route you can see the <span class="attribute">monsters</span> variable contains an array of objects containing various <span class="attribute">key:value</span> pairs of different monsters.<br/><br/>All of this will be sent back as the response because this is what the route has been set up to do.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.json()</span></td>
                            <td>JSON send Method</td>
                            <td>By using <span class="attribute">.json()</span> instead of <span class="attribute">.send()</span> on the response (<span class="attribute">res</span>) object, you can explicitly send JSON formatted responses. It does everything the same as the above <span class="attribute">.send()</span> method but its formatted into JSON.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Matching route paths</td>
                            <td>Express matches requests by route and, as with all javascript code, it works from top to bottom and works methodically until either a match has been found or there is no code left to evaluate.<br/><br/>So if we have a list of 15 routes all set out and our request path matches a route located at number 8, it will run through the first 7 and try to match the path.<br/><br/>It also operates on a first called basis so lets say there is a mistake in your code and there are 2 paths that have the same route then it will call the first one it encounters.<br/><br/>Finally if it reaches the end of the list and no matches have been found it will automatically send back a 404 not found response.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">req</span> & <span class="attribute">res</span></td>
                            <td>Request Object, Response Object</td>
                            <td>In the above examples we've briefly mentioned the 3 arguments that are fed into the callback functions of each method (<span class="attribute">req</span>, <span class="attribute">res</span> & <span class="attribute">next</span>).<br/>For now we'll focus on the <span class="attribute">req</span> & <span class="attribute">res</span> elements.<br/><br/>These are the <span class="attribute">request</span> and <span class="attribute">response</span> objects. Both have a few built in methods that provide tools to deal with requests and responses. The most important thing to keep in mind here is that both are objects containing information about the incoming request and its associated information (<span class="attribute">req</span>) or the outgoing response and its details (<span class="attribute">res</span>).</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">app.get('/monsters/:name')</span></td>
                            <td>Dynamic routes</td>
                            <td>Dynamic routes in express.js are called route parameters. They can be easily identified through the use of the <span class="attribute">:</span> character at the beginning of the path segment.<br/><br/>They work in a very similar way to DOM routing in React, in that you can define a route with a placeholder that allows for the dynamic interaction of unknown content.<br/>For example, if we created a route path of <span class="code">/monsters/:name</span> then both the incoming GET requests of <span class="code">/monsters/hydra</span> and <span class="code">/monsters/dragon</span> would be valid and get matched to our dynamic route.<br/><br/>The next interesting point to note about this is that express extracts the values of those parameters and attaches them as an object to the request object under the key <span class="attribute">req.params</span>.<br/>Within this object it then creates a key:value pair with the key being the dynamic route placeholder and the value being whatever information is extracted from the request.<br/><br/>So for example the GET request of <span class="code">/monsters/hydra</span> would be accepted as a valid request, the <span class="code">hydra</span> part of the path would be extracted and could then be accessed through the <span class="attribute">req</span> object at <span class="attribute">req.params.name</span>.<br/><br/>Below is a visual explanation of the <span class="attribute">req</span> object to show how the dynamic route has extracted and stored the information for use in a response.<br/><br/><span class="attribute">req = {<br/>//example other key,<br/>params: {<br/>{ name: hydra }<br/>},<br/>//example other key<br/>}</span><br/><br/>For a practical example lets say that we have a database on the back end of monster stats. The front end is our website that is displaying various facts about monsters, the user can click different links to load up the different stats.<br/>Whenever the user clicks the link it will send a GET request for each different monster. Each different monster will send its own GET request including its own path. We can use dynamic routing to accept all of these and send back the relevant stats for display on the website.<br/><br/><span class="attribute">const monsters = { <br/>hydra: { height: 3, age: 4 },<br/>dragon: { height: 200, age: 350 } <br/>};<br/><br/>app.get('/monsters/:name', (req, res, next) => {<br/>console.log(req.params); // { name: 'hydra' }<br/>res.send(monsters[req.params.name.height]);<br/>});</span><br/><br/>As you can see above, we have our database of monster facts and underneath we have our dynamic route that accepts the dynamic input of <span class="code">:name</span>.<br/>When the user clicks on <span class="attribute">hydra</span> this will trigger a GET request that will send the path <span class="code">/monsters/hydra</span> to our express server. Our dynamic route will accept this, because it follows the valid pattern we've written in the GET request and as you can see in the response we use the extracted values from <span class="attribute">req.params</span> to access the relevant information from our <span class="attribute">monsters</span> database and we send our <span class="attribute">res</span> object back pinpointing (in this example) the height value of the hydra in our <span class="attribute">monsters</span> database.</td> 
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Longer dynamic routes</td>
                            <td>Route parameters match to their specific part of the path. What this means is that the dynamic portion of the route can be much further along the path than the first section after the root, all you need to bear in mind is that the route should mirror this in order for a request to be successful.<br/><br/>An example of correct syntax is shown below;<br/><br/><span class="code">Request = GET /monster/name/25</span><br/><br/><span class="attribute">app.get('/monster/name')<br/><br/>app.get('/monster/name/:id')</span><br/><br/>In the above example the request would get checked against the first route (because this is how express works, top to bottom), it would fail because the route path isn't the correct length.<br/>It would then move onto the next route, check the path and match because it is of the correct length and it is dynamic meaning that our request would match.</td> 
                        </tr>
                        <tr>
                            <td><span class="attribute">.status()</span></td>
                            <td>Status codes</td>
                            <td>Express has a built in method that allows us to set status codes on any response that we send back. Status codes are automatically sent back on successful (200 OK) or unsuccessful (404 NOT FOUND) responses, however we can include a status method and provide a custom status code.<br/><br/><span class="attribute">const monsterStoreInventory = { fenrirs: 4, banshees: 1, jerseyDevils: 4, krakens: 3 };<br/><br/>app.get('/monsters-inventory/:name', (req, res, next) => {<br/>const monsterInventory = monsterStoreInventory[req.params.name];<br/>if (monsterInventory) {<br/>res.send(monsterInventory);<br/>} else {<br/>res.status(404).send('Monster not found');<br/>}<br/>});</span><br/><br/>In the example above we've set up a route to check an inventory database. If the request finds something, it send back a response with an automatic 200 OK response code.<br/>If the request is for something not contained within the database we send back a 404 code with our custom message 'Monster not found' chained onto the end of the <span class="attribute">.status()</span> method.</td> 
                        </tr>
                        <tr>
                            <td><span class="attribute">?</span></td>
                            <td>Using Queries</td>
                            <td>Query strings appear at the end of the path in URLs and they are indicated with a <span class="attribute">?</span> character.<br/><br/>Query strings do not count as part of the path.<br/><br/>Therefore a request of <span class="code">/monsters/1?name=chimera&age=1</span> can be broken down into the path, which would be <span class="code">/monsters/1</span> and the query which would be <span class="code">name=chimera&age=1</span><br/><br/>Express parses anything after the <span class="attribute">?</span> into a Javascript object that is then automatically attached to the request object as the value of <span class="attribute">req.query</span>.<br/><br/>They key:value relationship of the query string is indicated by the <span class="attribute">=</span> character contained in the query string. Furthermore key:value pairs are further separated by the <span class="attribute">&</span> character.<br/>So in our example above, the object automatically attached to <span class="attribute">req.query</span> would look like;<br/><br/><span class="attribute">{ name: chimera, age: 1 }</span></td> 
                        </tr>
                        <tr>
                            <td><span class="attribute">.put()</span></td>
                            <td>PUT Method</td>
                            <td>PUT requests are used for updating existing resources. Like a user's location or their favourite food within their user profile.<br/><br/>Below is an example of how we can use PUT requests to allow a user to update the details of our monsters.<br/><br/>Let's say that our user decides to change the name and age of the monster at index 1 in our database. The PUT request would look like this;<br/><span class="attribute">/monsters/1?name=chimera&age=1</span><br/><br/>To make this change our code would look like the below;<br/><br/><span class="attribute">const monsters = {<br/>'1': { name: 'cerberus', age: '4'  }<br/>'2': { name: 'dragon', age: '67'  }<br/>};<br/><br/>app.put('/monsters/:id', (req, res, next) => {<br/>const monsterUpdates = req.query;<br/>monsters[req.params.id] = monsterUpdates;<br/>res.send(monsters[req.params.id]);<br/>});</span><br/><br/>At the top we have our existing monster database. It is an object that contains various monsters arranged by ID. The ID's are numbered and within each ID is another object that contains the monster's name and its age.<br/>As with any Javascript object, all of these details can be easily accessed through standard dot notation<br/>(e.g. <span class="attribute">monsters['1'].name</span> would get 'cerberus').<br/><br/>Underneath this we have our route to handle the PUT request.<br/>The path is dynamic which allows us to handle any particular monster selected by the user based on its ID.<br/>Within the callback we have a variable (<span class="attribute">monsterUpdates</span>) set up to extract the query information (<span class="attribute">req.query</span>) received from the request object.<br/>which is <span class="attribute">{ name:'chimera', age: '1'}</span><br/><br/>Underneath this we have the section of code that does the actual update.<br/>It says in the <span class="attribute">monsters</span> variable (our database) we target a specific monster using the <span class="attribute">[req.params.id]</span>. The ID is <span class="code">1</span> because that's the ID contained within the path from request, so this is targetting the object with the key of <span class="code">'1'</span> in the <span class="attribute">monsters</span> object (our database of monsters).<br/>Currently that monster is <span class="attribute">{ name: 'cerberus', age: '4' }</span>.<br/>In our code we are then re-assigning this to be the information we have received from the PUT request and stored in the <span class="attribute">monsterUpdates</span> variable.<br/>Now we know Javascript objects recognise the same keys if they already exist and simply overwrites the values and if the key doesn't exist it will create it for us.<br/>In this example the keys already exist so this piece of code will overwrite<br/><span class="attribute">{ name: 'cerberus', age: '4' }</span><br/>with the value in our PUT request which we know is<br/><span class="attribute">{ name: 'chimera', age: '1' }</span>.<br/><br/>The final part of the code is a simple <span class="attribute">.send()</span> method that sends this back to the front end. This is best thought of as a confirmation that the change has been made and displays this to the front end.</td> 
                        </tr>
                        <tr>
                            <td><span class="attribute">.post()</span></td>
                            <td>POST Method</td>
                            <td>POST requests are slightly different from GET and PUT requests because a POST request is creating new information as opposed to retrieving or editing existing information.<br/><br/>This is an important factor to bear in mind when it comes to adding the information to an existing database. If we are adding new information to an array we can simply add this to the array using various array editing methods like <span class="attribute">.push()</span> however, if we are editing an object it becomes a little more tricky as we are likely to want to give it a key based on either an index or something unique to prevent clashes of information.<br/><br/>An example of this is shown below;<br/><br/>Lets say we want to add a brand new monster to our existing monster database.<br/>It currently looks like the below;<br/><br/><span class="attribute">const monsters = {<br/>'1': { name: 'chimera', age: '1' }<br/>'2': { name: 'dragon', age: '67' }<br/>};</span><br/><br/>Our monsters are arranged within the database using indexes (<span class="attribute">'1'</span>) as the key for each individual monster and the associated records. When we add a new one we need to take this into account in how we handle the request.<br/><br/><span class="attribute">app.post('/monsters', (req, res, next) => {<br/>const newMonster = req.query;<br/>if (newMonster) {<br/>monsters[Object.keys(monsters).length] = newMonster;<br/>res.status(201).send(newMonster);<br/>} else {<br/>res.status(400).send()<br/>}<br/>});</span><br/><br/>Each individual case will handle this differently however in this small example this is how we would use the POST request to add new content to our existing monsters database.<br/>Notice how we also add in a quick sense checking <span class="attribute">if</span> statement that ensures we have valid content and sends back a 201 content created status code if successful or a 400 not valid code if unsuccessful.<br/><br/>So if our POST request looked like this;<br/><span class="code">/monsters?name=cerberus&age=4</span><br/><br/>Then our new database would end up looking like the below;<br/><br/><span class="attribute">const monsters = {<br/>'1': { name: 'chimera', age: '1' },<br/>'2': { name: 'dragon', age: '67' },<br/>'3': { name: 'cerberus', age: '4' }<br/>};</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.delete()</span></td>
                            <td>DELETE Method</td>
                            <td>DELETE requests are used to delete existing data, because these routes are used to delete existing data their paths should usually end with a route parameter to indicate which resource to delete.<br/><br/>As with the POST request, deleting elements from an array can be done with the available array editing methods such as <span class="attribute">.splice()</span> however some thought into how to target the specific item to be deleted should be given when forming the route.<br/><br/>An example of how to delete an entry from our monsters database is shown below;<br/><br/>Lets say our database is as shown below;<br/><br/><span class="attribute">const monsters = {<br/>'1': { name: 'chimera', age: '1' },<br/>'2': { name: 'dragon', age: '67' },<br/>'3': { name: 'cerberus', age: '4' }<br/>};</span><br/><br/>And we receive a DELETE request as follows;<br/><span class="code">/monsters/1</span><br/><br/>Our route might look something like the following;<br/><br/><span class="attribute">app.delete('/monsters/:id', (req, res, next) => {<br/>const id = req.params.id;<br/><br/>if (monsters.hasOwnProperty(id)) {<br/>delete monsters[id];<br/>res.status(204).send('Monster deleted');<br/>} else {<br/>res.status(404).send('Monster not found');<br/>}<br/>});</span><br/><br/>Notice how we have a dynamic route set up to accept any input to delete a monster from the database.<br/>We extract the ID parameter from the request path and then use that to identify which element of our database we intend to delete. A 204 No content code is sent upon successful deletion.<br/>One important point to note here is that when we delete this entry from our database, the existing entries do not get refactored, therefore our database will now look like the following;<br/><br/><span class="attribute">const monsters = {<br/>'2': { name: 'dragon', age: '67' },<br/>'3': { name: 'cerberus', age: '4' }<br/>};</span><br/><br/>As a result the database object might look a little messy and could potentially be difficult to maintain with numbered keys like this example.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="router">
                <h2>Express.Router</h2>
                <p>This section describes the principles of modular routing.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">.Router()</span></td>
                            <td>Router</td>
                            <td>The <span class="attribute">.Router()</span> method provides a subset of express methods. In order to use these we need to invoke the method on the express import itself.<br/><br/>An example of the syntax is shown below;<br/><br/><span class="attribute">const express = require('express');<br/>const app = express();<br/><br/>const monstersRouter = express.Router();</span><br/><br/>In the code above we can see that we still required in <span class="attribute">'express'</span> and we still invoke that onto our <span class="attribute">app</span> variable.<br/>Below that however we invoke the <span class="attribute">.Router()</span> method on a new variable called <span class="attribute">monstersRouter</span>. This gives us access to the subset of express methods that we will use later to create routes and refactor our code to be modular and therefore easier to maintain.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.use()</span></td>
                            <td>Mounting the Router</td>
                            <td>Once the <span class="attribute">.Router()</span> method is invoked we can mount it at a specified path using the <span class="attribute">.use()</span> method on our <span class="attribute">app</span> variable.<br/><br/>Syntax for this is shown below;<br/><br/><span class="attribute">const monstersRouter = express.Router();<br/><br/>app.use('/monsters', monstersRouter);<br/><br/>monstersRouter.get('/:id', (req, res, next) => {<br/>const monster = monsters[req.params.id];<br/>if (monster) {<br/>res.send(monster);<br/>} else {<br/>res.status(404).send();<br/>}<br/>});</span><br/><br/>In the <span class="attribute">.use()</span> method you can see that we specify the path that we want the <span class="attribute">monstersRouter</span> to be mounted on.<br/>The <span class="attribute">.get()</span> method underneath this then demonstrates how we can invoke things like <span class="attribute">.get()</span> or <span class="attribute">.post()</span> methods on this new route.<br/>The interesting part of this is that on the <span class="attribute">.get()</span> method shown, the path is prepended with the <span class="attribute">'/monsters'</span> path we specified at the point we invoked the <span class="attribute">.Router()</span>.<br/>This means that the <span class="attribute">.get()</span> path is actually parsing requests for <span class="attribute">'/monsters/:id'</span> because of the route we have set up.<br/>So a GET request for <span class="attribute">/monsters/1</span> would be processed by the <span class="attribute">monstersRouter.get()</span> route however a request for <span class="attribute">/animals/1</span> would not.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">module.exports</span></td>
                            <td>Making the routes modular</td>
                            <td>To keep things modular, clean and easily maintainable, the routes are generally kept in separate files with each one containing all of its own related code. These are then required into the main file for use.<br/>The premise is very similar to how we keep things modular within both React and Redux.<br/><br/>In the example below we show how the syntax for this works.<br/><br/>The below code is in the file <span class="code">main.js</span><br/><br/><span class="attribute">const express = require('express');<br/>const app = express();<br/>const monstersRouter = require('./monsters.js');<br/><br/>app.use('/monsters', monstersRouter);</span><br/><br/>The below code is in the file <span class="code">monsters.js</span><br/><br/><span class="attribute">const express = require('express');<br/>const monstersRouter = express.Router();<br/><br/>const monsters = {<br/>'1': {<br/>name: 'godzilla',<br/>age: 250000000<br/>},<br/>'2': {<br/>name: 'manticore',<br/>age: 21<br/>}<br/>}<br/><br/>monstersRouter.get('/:id', (req, res, next) => {<br/>const monster = monsters[req.params.id];<br/>if (monster) {<br/>res.send(monster);<br/>} else {<br/>res.status(404).send();<br/>}<br/>});<br/><br/>module.exports = monstersRouter;</span><br/><br/>Notice how we still have to require in express at the top of the file in order to use express.<br/>In terms of content, we keep the 'database' of monsters in this file along with all the logic for the routes.<br/>In this example we only show a route that deals with GET requests however we would also put PUT, POST and DELETE requests in here too.<br/><br/>At the very bottom of the file we have the <span class="attribute">module.exports</span> keyword that exports the router for use in the <span class="code">main.js</span> file.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Matching routes</td>
                            <td>Its important to remember that in express a full path of a request can be segmented. This means that we can use modular routes to access different databases and then within those modules we can set up multiple routes to do various things like get all information from a database or get specific information from a database.<br/><br/>In the code below we have 2 files, the first is <span class="code">main.js</span> and the second is the module for our monsters database and routes (<span class="code">monsters.js</span>).<br/>In this example we have 2 databases set up, 1 for animals and another for monsters, for this particular example we're not going to show any of the animals module.<br/><br/>The below code is in the file <span class="code">main.js</span><br/><br/><span class="attribute">const express = require('express');<br/>const app = express();<br/><br/>const animalsRouter = require('./animals.js');<br/>const monstersRouter = require('./monsters.js');<br/><br/>app.use('/animals', animalsRouter);<br/>app.use('/monsters', monstersRouter);</span><br/><br/>The below code is in the file <span class="code">monsters.js</span><br/><br/><span class="attribute">const express = require('express');<br/>const monstersRouter = express.Router();<br/><br/>monstersRouter.get('/', (req, res, next) => {<br/>res.send(getAllMonsters());<br/>});<br/><br/>monstersRouter.get('/:id', (req, res, next) => {<br/>const monster = getMonsterById(req.params.id);<br/>if (monster) {<br/>res.status(200).send(monster);<br/>} else {<br/>res.status(404).send('Monster not found');<br/>}<br/>});<br/><br/>module.exports = monstersRouter;</span><br/><br/>Lets say we have a GET request that comes in that looks like the following;<br/><span class="code">GET /monsters/</span><br/><br/>Due to the way we have our server set up to work with modular routes the request will be processed in the following way;<br/><br/>It will analyse the path segment by segment.<br/>It will begin by matching the first segment (<span class="code">/monsters</span>) to the monsters module and then move into the <span class="code">monsters.js</span> module file to carry on matching the rest of the path with any valid routes that might be set up.<br/><br/>Looking at the <span class="code">monsters.js</span> file we can see that the first route matches the next segment of the GET request path which is <span class="code">'/'</span>.<br/>We can see that this route has been set up to send back all of our monsters.<br/><br/>If we had a GET request that looked like the following;<br/><span class="code">GET /monsters/34</span><br/><br/>This would follow the same process however because the second segment of the path is <span class="code">'/34'</span> rather than <span class="code">'/'</span> express would skip the first route it finds in the <span class="code">monsters.js</span> file and match to the second route which has been set up to dynamically accept ID's.<br/>In this case the route would look for a monster in the database with the ID of 34 and then send that back if it exists.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>For additional tags and examples see the <a href="https://expressjs.com/en/5x/api.html" target="_blank">Express.js Website</a> for more info.</p>
        </div>
    </body>
    <footer>

    </footer>
</html>