<!DOCTYPE html>
<html>
    <head>
        <title>Express.js Cheat Sheet</title>
        <link href="./resources/css/index.css" type="text/css" rel="stylesheet">
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link rel="preconnect" href="https://fonts.googleapis.com">
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
    </head>
    <body>
        <header>
            <nav>
                <div class="dropdown">
                    <button class="dropdownBtn">Front End</button>
                    <div class="dropdownContent">
                        <a href="./htmlcheatsheet.html">HTML</a>
                        <a href="./csscheatsheet.html">CSS</a>
                        <a href="./javascriptcheatsheet.html">JavaScript</a>
                        <a href="./reactcheatsheet.html">React</a>
                        <a href="./reduxcheatsheet.html">Redux</a>
                    </div>
                </div>
                <div class="dropdown">
                    <button class="dropdownBtn">Back End</button>
                    <div class="dropdownContent">
                        <a href="./nodecheatsheet.html">Node.js</a>
                        <a href="./expresscheatsheet.html">Express.js</a>
                    </div>
                </div>
                <div class="dropdown">
                    <button class="dropdownBtn">Other</button>
                    <div class="dropdownContent">
                        <a href="./commandlinecheatsheet.html">Command Line</a>
                        <a href="./markdowncheatsheet.html">Markdown</a>
                        <a href="./styleguide.html">Style Guide</a>
                    </div>
                </div>
            </nav>
        </header>
        <div class="content">
            <h1>Express.js Cheat Sheet</h1>
            <p>Below is a list of commands, methods and fundamental principles regarding the Express.js server framework including a brief description of what they do and any notes on correct syntax.</p>
            <div id="fundamentals">
                <h2>Fundamentals</h2>
                <p>This section describes some fundamental properties of the Express.js framework.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">express</span></td>
                            <td>Express</td>
                            <td>Express is a node module.<br/>It does not come pre-installed so we need to install it before use. We can do this using <span class="attribute">npm</span> in the terminal.<br/><br/>The correct syntax for this is shown below;<br/><br/><span class="attribute">npm i express</span><br/><br/>Once installed into the project file we can then require it in like any other non-global node module.<br/><br/><span class="attribute">const express = require('express');</span><br/><br/>Once required in we then need to invoke the express method within a variable to then be able to create a server.<br/><br/><span class="attribute">const app = express();</span><br/><br/>With that all now established we can start a server and specify server behavior.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">app.listen()</span></td>
                            <td>Listen method</td>
                            <td>The purpose of a server is to listen for requests, perform whatever action is required to satisfy the request, and then return a response.<br/><br/>In order for our server to start responding, we have to tell the server where to listen for new requests by providing a port number argument to a method called <span class="attribute">app.listen()</span>.<br/>The server will then listen on the specified port and respond to any requests that come into it.<br/>The second argument is a callback function that will be called once the server is running and ready to receive responses.<br/><br/>An example of syntax is shown below;<br/><br/><span class="attribute">const app = express();<br/>const PORT = 4001;<br/><br/>app.listen(PORT, () => {<br/>console.log(`Server is listening on port ${PORT}`);<br/>});</span><br/><br/>In the above example we create a <span class="attribute">PORT</span> variable that contains the port number for our server to listen for instructions on. We then invoke the <span class="attribute">.listen()</span> express method, providing the <span class="attribute">PORT</span> variable as the first argument and a callback function that prints a simple message to the console as the second argument.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Routes</td>
                            <td>Once we have set up the server to listen for any and all requests we then need to establish how it will respond to these requests.<br/>This requires us to create a number of Routes.<br/>Routes in this context are basically like instructions in a similar vein to actions in Redux.<br/><br/>Routes define the control flow for specific requests based on the request's included path and HTTP verb.<br/><br/>So for example, a user on the front end might click a link to look at another page of the website.<br/>This is a get request.<br/>The link clicked by the user triggers a get request to be sent to the back end. The details of how this works will be explained later but our site will have some routes set up to provide appropriate responses to these requests, instructions on what the back end should do next and how it should respond.<br/><br/>There will be many different routes set up to enable different functionality.<br/>They are defined by the specific HTTP verb (GET, POST etc.) and paths.<br/>The path is the part of a request URL after the hostname and port number, so in a request to <span class="code">localhost:4001/monsters</span>, the hostname is <span class="code">localhost</span>, the port the server is listening on is <span class="code">4001</span> and the path is <span class="code">/monsters</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">app.get()</span></td>
                            <td>GET method</td>
                            <td>In express.js the <span class="attribute">.get()</span> method is used to match up any GET requests to the outlined functionality.<br/><br/>The <span class="attribute">.get()</span> method accepts 2 arguments, the first is a path which is usually a string and the second is a callback function that will handle the specific request.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const moods = [{ mood: 'excited about express!'}];<br/>app.get('/moods', (req, res, next) => {<br/>// Here we would send back the moods array in response<br/>});</span><br/><br/>In the above example a route for a GET request with the path of <span class="attribute">/moods</span> has been set up</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.send()</span></td>
                            <td>Send Method</td>
                            <td>Express sends responses using the <span class="attribute">.send()</span> method on the response object. This method will take any input and include it in the response body.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const monsters = [<br/>{ type: 'werewolf' },<br/>{ type: 'hydra' }, <br/>{ type: 'chupacabra' }<br/>];<br/><br/>app.get('/monsters', (req, res, next) => {<br/>res.send(monsters);<br/>});</span><br/><br/>In this example a GET request using the path <span class="code">/monsters</span> will match to a defined route. Express will match this route and call the callback function.<br/>In the response body it shows that the route has been set up to use the <span class="attribute">.send()</span> method on the response object with the argument <span class="attribute">monsters</span>.<br/>Above this route you can see the <span class="attribute">monsters</span> variable contains an array of objects containing various <span class="attribute">key:value</span> pairs of different monsters.<br/><br/>All of this will be sent back as the response because this is what the route has been set up to do.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.json()</span></td>
                            <td>JSON send Method</td>
                            <td>By using <span class="attribute">.json()</span> instead of <span class="attribute">.send()</span> on the response (<span class="attribute">res</span>) object, you can explicitly send JSON formatted responses. It does everything the same as the above <span class="attribute">.send()</span> method but its formatted into JSON.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Matching route paths</td>
                            <td>Express matches requests by route and, as with all javascript code, it works from top to bottom and works methodically until either a match has been found or there is no code left to evaluate.<br/><br/>So if we have a list of 15 routes all set out and our request path matches a route located at number 8, it will run through the first 7 and try to match the path.<br/><br/>It also operates on a first called basis so lets say there is a mistake in your code and there are 2 paths that have the same route then it will call the first one it encounters.<br/><br/>Finally if it reaches the end of the list and no matches have been found it will automatically send back a 404 not found response.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">req</span> & <span class="attribute">res</span></td>
                            <td>Request Object, Response Object</td>
                            <td>In the above examples we've briefly mentioned the 3 arguments that are fed into the callback functions of each method (<span class="attribute">req</span>, <span class="attribute">res</span> & <span class="attribute">next</span>).<br/>For now we'll focus on the <span class="attribute">req</span> & <span class="attribute">res</span> elements.<br/><br/>These are the <span class="attribute">request</span> and <span class="attribute">response</span> objects. Both have a few built in methods that provide tools to deal with requests and responses. The most important thing to keep in mind here is that both are objects containing information about the incoming request and its associated information (<span class="attribute">req</span>) or the outgoing response and its details (<span class="attribute">res</span>).</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">app.get('/monsters/:name')</span></td>
                            <td>Dynamic routes</td>
                            <td>Dynamic routes in express.js are called route parameters. They can be easily identified through the use of the <span class="attribute">:</span> character at the beginning of the path segment.<br/><br/>They work in a very similar way to DOM routing in React, in that you can define a route with a placeholder that allows for the dynamic interaction of unknown content.<br/>For example, if we created a route path of <span class="code">/monsters/:name</span> then both the incoming GET requests of <span class="code">/monsters/hydra</span> and <span class="code">/monsters/dragon</span> would be valid and get matched to our dynamic route.<br/><br/>The next interesting point to note about this is that express extracts the values of those parameters and attaches them as an object to the request object under the key <span class="attribute">req.params</span>.<br/>Within this object it then creates a key:value pair with the key being the dynamic route placeholder and the value being whatever information is extracted from the request.<br/><br/>So for example the GET request of <span class="code">/monsters/hydra</span> would be accepted as a valid request, the <span class="code">hydra</span> part of the path would be extracted and could then be accessed through the <span class="attribute">req</span> object at <span class="attribute">req.params.name</span>.<br/><br/>Below is a visual explanation of the <span class="attribute">req</span> object to show how the dynamic route has extracted and stored the information for use in a response.<br/><br/><span class="attribute">req = {<br/>//example other key,<br/>params: {<br/>{ name: hydra }<br/>},<br/>//example other key<br/>}</span><br/><br/>For a practical example lets say that we have a database on the back end of monster stats. The front end is our website that is displaying various facts about monsters, the user can click different links to load up the different stats.<br/>Whenever the user clicks the link it will send a GET request for each different monster. Each different monster will send its own GET request including its own path. We can use dynamic routing to accept all of these and send back the relevant stats for display on the website.<br/><br/><span class="attribute">const monsters = { <br/>hydra: { height: 3, age: 4 },<br/>dragon: { height: 200, age: 350 } <br/>};<br/><br/>app.get('/monsters/:name', (req, res, next) => {<br/>console.log(req.params); // { name: 'hydra' }<br/>res.send(monsters[req.params.name.height]);<br/>});</span><br/><br/>As you can see above, we have our database of monster facts and underneath we have our dynamic route that accepts the dynamic input of <span class="code">:name</span>.<br/>When the user clicks on <span class="attribute">hydra</span> this will trigger a GET request that will send the path <span class="code">/monsters/hydra</span> to our express server. Our dynamic route will accept this, because it follows the valid pattern we've written in the GET request and as you can see in the response we use the extracted values from <span class="attribute">req.params</span> to access the relevant information from our <span class="attribute">monsters</span> database and we send our <span class="attribute">res</span> object back pinpointing (in this example) the height value of the hydra in our <span class="attribute">monsters</span> database.</td> 
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Longer dynamic routes</td>
                            <td>Route parameters match to their specific part of the path. What this means is that the dynamic portion of the route can be much further along the path than the first section after the root, all you need to bear in mind is that the route should mirror this in order for a request to be successful.<br/><br/>An example of correct syntax is shown below;<br/><br/><span class="code">Request = GET /monster/name/25</span><br/><br/><span class="attribute">app.get('/monster/name')<br/><br/>app.get('/monster/name/:id')</span><br/><br/>In the above example the request would get checked against the first route (because this is how express works, top to bottom), it would fail because the route path isn't the correct length.<br/>It would then move onto the next route, check the path and match because it is of the correct length and it is dynamic meaning that our request would match.</td> 
                        </tr>
                        <tr>
                            <td><span class="attribute">.status()</span></td>
                            <td>Status codes</td>
                            <td>Express has a built in method that allows us to set status codes on any response that we send back. Status codes are automatically sent back on successful (200 OK) or unsuccessful (404 NOT FOUND) responses, however we can include a status method and provide a custom status code.<br/><br/><span class="attribute">const monsterStoreInventory = { fenrirs: 4, banshees: 1, jerseyDevils: 4, krakens: 3 };<br/><br/>app.get('/monsters-inventory/:name', (req, res, next) => {<br/>const monsterInventory = monsterStoreInventory[req.params.name];<br/>if (monsterInventory) {<br/>res.send(monsterInventory);<br/>} else {<br/>res.status(404).send('Monster not found');<br/>}<br/>});</span><br/><br/>In the example above we've set up a route to check an inventory database. If the request finds something, it send back a response with an automatic 200 OK response code.<br/>If the request is for something not contained within the database we send back a 404 code with our custom message 'Monster not found' chained onto the end of the <span class="attribute">.status()</span> method.</td> 
                        </tr>
                        <tr>
                            <td><span class="attribute">?</span></td>
                            <td>Using Queries</td>
                            <td>Query strings appear at the end of the path in URLs and they are indicated with a <span class="attribute">?</span> character.<br/><br/>Query strings do not count as part of the path.<br/><br/>Therefore a request of <span class="code">/monsters/1?name=chimera&age=1</span> can be broken down into the path, which would be <span class="code">/monsters/1</span> and the query which would be <span class="code">name=chimera&age=1</span><br/><br/>Express parses anything after the <span class="attribute">?</span> into a Javascript object that is then automatically attached to the request object as the value of <span class="attribute">req.query</span>.<br/><br/>They key:value relationship of the query string is indicated by the <span class="attribute">=</span> character contained in the query string. Furthermore key:value pairs are further separated by the <span class="attribute">&</span> character.<br/>So in our example above, the object automatically attached to <span class="attribute">req.query</span> would look like;<br/><br/><span class="attribute">{ name: chimera, age: 1 }</span></td> 
                        </tr>
                        <tr>
                            <td><span class="attribute">.put()</span></td>
                            <td>PUT Method</td>
                            <td>PUT requests are used for updating existing resources. Like a user's location or their favourite food within their user profile.<br/><br/>Below is an example of how we can use PUT requests to allow a user to update the details of our monsters.<br/><br/>Let's say that our user decides to change the name and age of the monster at index 1 in our database. The PUT request would look like this;<br/><span class="attribute">/monsters/1?name=chimera&age=1</span><br/><br/>To make this change our code would look like the below;<br/><br/><span class="attribute">const monsters = {<br/>'1': { name: 'cerberus', age: '4'  }<br/>'2': { name: 'dragon', age: '67'  }<br/>};<br/><br/>app.put('/monsters/:id', (req, res, next) => {<br/>const monsterUpdates = req.query;<br/>monsters[req.params.id] = monsterUpdates;<br/>res.send(monsters[req.params.id]);<br/>});</span><br/><br/>At the top we have our existing monster database. It is an object that contains various monsters arranged by ID. The ID's are numbered and within each ID is another object that contains the monster's name and its age.<br/>As with any Javascript object, all of these details can be easily accessed through standard dot notation<br/>(e.g. <span class="attribute">monsters['1'].name</span> would get 'cerberus').<br/><br/>Underneath this we have our route to handle the PUT request.<br/>The path is dynamic which allows us to handle any particular monster selected by the user based on its ID.<br/>Within the callback we have a variable (<span class="attribute">monsterUpdates</span>) set up to extract the query information (<span class="attribute">req.query</span>) received from the request object.<br/>which is <span class="attribute">{ name:'chimera', age: '1'}</span><br/><br/>Underneath this we have the section of code that does the actual update.<br/>It says in the <span class="attribute">monsters</span> variable (our database) we target a specific monster using the <span class="attribute">[req.params.id]</span>. The ID is <span class="code">1</span> because that's the ID contained within the path from request, so this is targetting the object with the key of <span class="code">'1'</span> in the <span class="attribute">monsters</span> object (our database of monsters).<br/>Currently that monster is <span class="attribute">{ name: 'cerberus', age: '4' }</span>.<br/>In our code we are then re-assigning this to be the information we have received from the PUT request and stored in the <span class="attribute">monsterUpdates</span> variable.<br/>Now we know Javascript objects recognise the same keys if they already exist and simply overwrites the values and if the key doesn't exist it will create it for us.<br/>In this example the keys already exist so this piece of code will overwrite<br/><span class="attribute">{ name: 'cerberus', age: '4' }</span><br/>with the value in our PUT request which we know is<br/><span class="attribute">{ name: 'chimera', age: '1' }</span>.<br/><br/>The final part of the code is a simple <span class="attribute">.send()</span> method that sends this back to the front end. This is best thought of as a confirmation that the change has been made and displays this to the front end.</td> 
                        </tr>
                        <tr>
                            <td><span class="attribute">.post()</span></td>
                            <td>POST Method</td>
                            <td>POST requests are slightly different from GET and PUT requests because a POST request is creating new information as opposed to retrieving or editing existing information.<br/><br/>This is an important factor to bear in mind when it comes to adding the information to an existing database. If we are adding new information to an array we can simply add this to the array using various array editing methods like <span class="attribute">.push()</span> however, if we are editing an object it becomes a little more tricky as we are likely to want to give it a key based on either an index or something unique to prevent clashes of information.<br/><br/>An example of this is shown below;<br/><br/>Lets say we want to add a brand new monster to our existing monster database.<br/>It currently looks like the below;<br/><br/><span class="attribute">const monsters = {<br/>'1': { name: 'chimera', age: '1' }<br/>'2': { name: 'dragon', age: '67' }<br/>};</span><br/><br/>Our monsters are arranged within the database using indexes (<span class="attribute">'1'</span>) as the key for each individual monster and the associated records. When we add a new one we need to take this into account in how we handle the request.<br/><br/><span class="attribute">app.post('/monsters', (req, res, next) => {<br/>const newMonster = req.query;<br/>if (newMonster) {<br/>monsters[Object.keys(monsters).length] = newMonster;<br/>res.status(201).send(newMonster);<br/>} else {<br/>res.status(400).send()<br/>}<br/>});</span><br/><br/>Each individual case will handle this differently however in this small example this is how we would use the POST request to add new content to our existing monsters database.<br/>Notice how we also add in a quick sense checking <span class="attribute">if</span> statement that ensures we have valid content and sends back a 201 content created status code if successful or a 400 not valid code if unsuccessful.<br/><br/>So if our POST request looked like this;<br/><span class="code">/monsters?name=cerberus&age=4</span><br/><br/>Then our new database would end up looking like the below;<br/><br/><span class="attribute">const monsters = {<br/>'1': { name: 'chimera', age: '1' },<br/>'2': { name: 'dragon', age: '67' },<br/>'3': { name: 'cerberus', age: '4' }<br/>};</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.delete()</span></td>
                            <td>DELETE Method</td>
                            <td>DELETE requests are used to delete existing data, because these routes are used to delete existing data their paths should usually end with a route parameter to indicate which resource to delete.<br/><br/>As with the POST request, deleting elements from an array can be done with the available array editing methods such as <span class="attribute">.splice()</span> however some thought into how to target the specific item to be deleted should be given when forming the route.<br/><br/>An example of how to delete an entry from our monsters database is shown below;<br/><br/>Lets say our database is as shown below;<br/><br/><span class="attribute">const monsters = {<br/>'1': { name: 'chimera', age: '1' },<br/>'2': { name: 'dragon', age: '67' },<br/>'3': { name: 'cerberus', age: '4' }<br/>};</span><br/><br/>And we receive a DELETE request as follows;<br/><span class="code">/monsters/1</span><br/><br/>Our route might look something like the following;<br/><br/><span class="attribute">app.delete('/monsters/:id', (req, res, next) => {<br/>const id = req.params.id;<br/><br/>if (monsters.hasOwnProperty(id)) {<br/>delete monsters[id];<br/>res.status(204).send('Monster deleted');<br/>} else {<br/>res.status(404).send('Monster not found');<br/>}<br/>});</span><br/><br/>Notice how we have a dynamic route set up to accept any input to delete a monster from the database.<br/>We extract the ID parameter from the request path and then use that to identify which element of our database we intend to delete. A 204 No content code is sent upon successful deletion.<br/>One important point to note here is that when we delete this entry from our database, the existing entries do not get refactored, therefore our database will now look like the following;<br/><br/><span class="attribute">const monsters = {<br/>'2': { name: 'dragon', age: '67' },<br/>'3': { name: 'cerberus', age: '4' }<br/>};</span><br/><br/>As a result the database object might look a little messy and could potentially be difficult to maintain with numbered keys like this example.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="router">
                <h2>Express.Router</h2>
                <p>This section describes the principles of modular routing.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">.Router()</span></td>
                            <td>Router</td>
                            <td>The <span class="attribute">.Router()</span> method provides a subset of express methods. In order to use these we need to invoke the method on the express import itself.<br/><br/>An example of the syntax is shown below;<br/><br/><span class="attribute">const express = require('express');<br/>const app = express();<br/><br/>const monstersRouter = express.Router();</span><br/><br/>In the code above we can see that we still required in <span class="attribute">'express'</span> and we still invoke that onto our <span class="attribute">app</span> variable.<br/>Below that however we invoke the <span class="attribute">.Router()</span> method on a new variable called <span class="attribute">monstersRouter</span>. This gives us access to the subset of express methods that we will use later to create routes and refactor our code to be modular and therefore easier to maintain.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.use()</span></td>
                            <td>Mounting the Router</td>
                            <td>The <span class="attribute">.use()</span> method is used to mount middleware at a specified path. Middleware are functions that have access to the request (<span class="attribute">req</span>), response (<span class="attribute">res</span>) and next (<span class="attribute">next()</span>) function in the applications request-response cycle.<br/>Below is the boilerplate syntax for this method;<br/><br/><span class="attribute">app.use([path], callbackFunction)</span><br/><br/>The path section is optional, but when used this basically tells the method what path the callback function is to be applied to. If this is not included then the callback function will be applied to all routes.<br/>The callback function element is where a callback function will be defined that tells the route what to do when a valid roue has been matched.<br/><br/>Following on on from the example used in the <span class="attribute">.Router()</span> method, once the <span class="attribute">.Router()</span> method is invoked we can mount it at a specified path using the <span class="attribute">.use()</span> method on our <span class="attribute">app</span> variable.<br/><br/>Syntax for this is shown below;<br/><br/><span class="attribute">const monstersRouter = express.Router();<br/><br/>app.use('/monsters', monstersRouter);<br/><br/>monstersRouter.get('/:id', (req, res, next) => {<br/>const monster = monsters[req.params.id];<br/>if (monster) {<br/>res.send(monster);<br/>} else {<br/>res.status(404).send();<br/>}<br/>});</span><br/><br/>In the <span class="attribute">.use()</span> method you can see that we specify the path that we want the <span class="attribute">monstersRouter</span> to be mounted on.<br/>The <span class="attribute">.get()</span> method underneath this then demonstrates how we can invoke things like <span class="attribute">.get()</span> or <span class="attribute">.post()</span> methods on this new route.<br/>The interesting part of this is that on the <span class="attribute">.get()</span> method shown, the path is prepended with the <span class="attribute">'/monsters'</span> path we specified at the point we invoked the <span class="attribute">.Router()</span>.<br/>This means that the <span class="attribute">.get()</span> path is actually parsing requests for <span class="attribute">'/monsters/:id'</span> because of the route we have set up.<br/>So a GET request for <span class="attribute">/monsters/1</span> would be processed by the <span class="attribute">monstersRouter.get()</span> route however a request for <span class="attribute">/animals/1</span> would not.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">module.exports</span></td>
                            <td>Making the routes modular</td>
                            <td>To keep things modular, clean and easily maintainable, the routes are generally kept in separate files with each one containing all of its own related code. These are then required into the main file for use.<br/>The premise is very similar to how we keep things modular within both React and Redux.<br/><br/>In the example below we show how the syntax for this works.<br/><br/>The below code is in the file <span class="code">main.js</span><br/><br/><span class="attribute">const express = require('express');<br/>const app = express();<br/>const monstersRouter = require('./monsters.js');<br/><br/>app.use('/monsters', monstersRouter);</span><br/><br/>The below code is in the file <span class="code">monsters.js</span><br/><br/><span class="attribute">const express = require('express');<br/>const monstersRouter = express.Router();<br/><br/>const monsters = {<br/>'1': {<br/>name: 'godzilla',<br/>age: 250000000<br/>},<br/>'2': {<br/>name: 'manticore',<br/>age: 21<br/>}<br/>}<br/><br/>monstersRouter.get('/:id', (req, res, next) => {<br/>const monster = monsters[req.params.id];<br/>if (monster) {<br/>res.send(monster);<br/>} else {<br/>res.status(404).send();<br/>}<br/>});<br/><br/>module.exports = monstersRouter;</span><br/><br/>Notice how we still have to require in express at the top of the file in order to use express.<br/>In terms of content, we keep the 'database' of monsters in this file along with all the logic for the routes.<br/>In this example we only show a route that deals with GET requests however we would also put PUT, POST and DELETE requests in here too.<br/><br/>At the very bottom of the file we have the <span class="attribute">module.exports</span> keyword that exports the router for use in the <span class="code">main.js</span> file.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Matching routes</td>
                            <td>Its important to remember that in express a full path of a request can be segmented. This means that we can use modular routes to access different databases and then within those modules we can set up multiple routes to do various things like get all information from a database or get specific information from a database.<br/><br/>In the code below we have 2 files, the first is <span class="code">main.js</span> and the second is the module for our monsters database and routes (<span class="code">monsters.js</span>).<br/>In this example we have 2 databases set up, 1 for animals and another for monsters, for this particular example we're not going to show any of the animals module.<br/><br/>The below code is in the file <span class="code">main.js</span><br/><br/><span class="attribute">const express = require('express');<br/>const app = express();<br/><br/>const animalsRouter = require('./animals.js');<br/>const monstersRouter = require('./monsters.js');<br/><br/>app.use('/animals', animalsRouter);<br/>app.use('/monsters', monstersRouter);</span><br/><br/>The below code is in the file <span class="code">monsters.js</span><br/><br/><span class="attribute">const express = require('express');<br/>const monstersRouter = express.Router();<br/><br/>monstersRouter.get('/', (req, res, next) => {<br/>res.send(getAllMonsters());<br/>});<br/><br/>monstersRouter.get('/:id', (req, res, next) => {<br/>const monster = getMonsterById(req.params.id);<br/>if (monster) {<br/>res.status(200).send(monster);<br/>} else {<br/>res.status(404).send('Monster not found');<br/>}<br/>});<br/><br/>module.exports = monstersRouter;</span><br/><br/>Lets say we have a GET request that comes in that looks like the following;<br/><span class="code">GET /monsters/</span><br/><br/>Due to the way we have our server set up to work with modular routes the request will be processed in the following way;<br/><br/>It will analyse the path segment by segment.<br/>It will begin by matching the first segment (<span class="code">/monsters</span>) to the monsters module and then move into the <span class="code">monsters.js</span> module file to carry on matching the rest of the path with any valid routes that might be set up.<br/><br/>Looking at the <span class="code">monsters.js</span> file we can see that the first route matches the next segment of the GET request path which is <span class="code">'/'</span>.<br/>We can see that this route has been set up to send back all of our monsters.<br/><br/>If we had a GET request that looked like the following;<br/><span class="code">GET /monsters/34</span><br/><br/>This would follow the same process however because the second segment of the path is <span class="code">'/34'</span> rather than <span class="code">'/'</span> express would skip the first route it finds in the <span class="code">monsters.js</span> file and match to the second route which has been set up to dynamically accept ID's.<br/>In this case the route would look for a monster in the database with the ID of 34 and then send that back if it exists.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="API_fundamentals">
                <h2>API fundamentals</h2>
                <p>This section explains some of the fundamental principles of REST, RESTful API's and API's in general.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>REST</td>
                            <td>Representational State Transfer (REST) is the architecture behind a specific type of web service. It consists of standards and constraints for sharing data between different systems.<br/>Systems that implement this architecture are known as RESTful.<br/><br/>A simple way of visualising what REST is would be to compare it to physical collections of music, movies or TV programmes against a streaming service.<br/>If you want to listen to a specific track, the entire album must be copied and duplicated and then distributed however with a streaming service a singular track can be shared via a reference to a song title and doesn't require a copy of the entire album to be made. The streaming service is RESTful whereas the physical collection is not.<br/><br/>An Application Programming Interface (API) is an interface that allows software programmes to communicate with one another. A RESTful API is the same but it is constrained by the principles of REST.<br/>In a web API a server receives a request through a URL endpoint and sends a response in return which is often data in JSON format.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>REST Principles</td>
                            <td>There are 6 main constraints that define REST;<br/><br/><span class="attribute">Uniform Interface</span><br/>The interface of components must be the same. URI standards must be used to identify resources which basically means paths should be used that could be entered into the browser location bar.<br/><br/><span class="attribute">Client-Server</span><br/>There is a separation of concerns between the client and the server.<br/><br/><span class="attribute">Stateless Interactions</span><br/>All requests contain all of the information needed for that request. It does not rely on any session state.<br/><br/><span class="attribute">Cacheable</span><br/>The client can cache resources.<br/><br/><span class="attribute">Layered System</span><br/>The client can be connected to the end server or an intermediate layer such as a load balancer.<br/><br/><span class="attribute">Code on Demand</span><br/>This is optional but a client can download code, which reduces visibility from the outside.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Response codes</td>
                            <td>The status codes received back from a server when requests have been made are an easy way to understand, at a high level, what is going on with a request.<br/>There are a 5 categories of status codes and they can be defined as;<br/><br/><span class="attribute">1xx</span> - Information<br/><span class="attribute">2xx</span> - Success<br/><span class="attribute">3xx</span> - Redirection<br/><span class="attribute">4xx</span> - Client error<br/><span class="attribute">5xx</span> - Server error</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>REST API Endpoints</td>
                            <td>API's allow data to be accessed via endpoints. An endpoint is the URL path contained in a request such as GET, PUT, POST or DELETE.<br/><br/>An API URL will consist of 2-3 main elements. these are the root, the path and optional query strings (dependent on what the request is doing).<br/><br/><span class="attribute">Root</span><br/>The root of the API is the domain of the site, sometimes it might also contain the version of the API.<br/><span class="code">https://my.api.com</span> or <span class="code">https://my.api.com/v3</span><br/><br/><span class="attribute">Path</span><br/>The unique location of the specific resource being accessed.<br/>This is usually the part of the path that a route will be written for on the server.<br/><span class="code">/users</span> or <span class="code">/users/25</span><br/><br/><span class="attribute">Query Parameters</span><br/>This is the optional element that will not always be present.<br/>It will hold the key:value pairs for the request but could also contain things like limits to only return a specified number of results.<br/><span class="code">?name=josh&age=35</span> or <span class="code">?limit=10</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Guidelines on creating RESTful API Endpoints</td>
                            <td>There are a few naming conventions with regards to API endpoints.<br/><br/><span class="attribute">Paths should be plural</span><br/>It is likely that databases are for mass information and not singular things therefore the convention is for the endpoint segment to be plural<br/><span class="code">/users/5</span> as opposed to <span class="code">/user/5</span><br/><br/><span class="attribute">Endpoints should not display the file extension</span><br/>The API might be returning JSON data or similar however the URL should not end in .json or.js etc.<br/><br/><span class="attribute">Endpoints should use nouns and not verbs</span><br/>Words like <span class="code">add</span> or <span class="code">delete</span> should not appear in RESTful API URL's. These kind of actions should be handled by the routes written on the server.<br/><br/><span class="attribute">Paths are case sensitive</span><br/>Paths should be written in lowercase with the use of hyphens instead of underscores.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="middleware">
                <h2>Middleware</h2>
                <p>This section explains some of the ideas behind middleware in general.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Middleware and the stack</td>
                            <td>Middleware is code that executes between a server receiving a request and sending a response. It operates on the boundary, so to speak, between those two HTTP actions.<br/><br/>In Express, middleware is a function. (<span class="attribute">app.use()</span> or <span class="attribute">app.get()</span> etc...)<br/>Middleware can perform logic on the request and response objects, such as: inspecting a request, performing some logic based on the request, attaching information to the response, attaching a status to the response, sending the response back to the user, or simply passing the request and response to another middleware. Middleware can do any combination of those things or anything else a Javascript function can do.<br/><br/>Most of Express's functionality lies around chaining middleware together. The chain of middleware is called the middleware stack.<br/><br/>The middleware stack is processed in the order that each middleware appears in the application file.<br/>This happens regardless of method so if an <span class="attribute">app.get()</span> is the first thing in the application followed by an <span class="attribute">app.use()</span> then the get method will still get called first.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>DRY coding</td>
                            <td>Don't Repeat Yourself (DRY) coding is the practice of minimising the amount of similar code in order to reduce the possibility of bugs.<br/>For example the below code demonstrates 3 very similar functions;<br/><br/><span class="attribute">const addFive = number => {<br/>const fiveAdded = number + 5;<br/>console.log(`Your number plus 5 is ${fiveAdded}`);<br/>}<br/><br/>const addTen = number => {<br/>const tenAdded = number + 10;<br/>console.log(`Your number plus 10 is ${tenAdded}`);<br/>}<br/><br/>const addTwenty = number => {<br/>const twentyAdded = number + 20;<br/>console.log(`Your number plus 20 is ${twentyAdded}`);<br/>}</span><br/><br/>These functions could be refactored to something like the function below;<br/><br/><span class="attribute">const addNumber = (number, addend) => {<br/>const numAdded = number + addend;<br/>console.log(`Your number plus ${addend} is ${numAdded}`);<br/>}</span><br/><br/>The new refactored code reduces the amount of code required to carry out the same task. It is less prone to mistakes because there are less things to go wrong with it.<br/>This is the fundamental principle behind DRY coding.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">app.use()</span></td>
                            <td>DRYing Routes</td>
                            <td>The principles of DRY coding can also be used for when repeatable functions are used in differing routes.<br/>The <span class="attribute">.use()</span> method can be used to create a repeatable function that gets called whenever a route is invoked.<br/><br/><span class="attribute">app.use((req, res, next) => {<br/>console.log('Request received');<br/>});</span><br/><br/>The above example has no path argument and therefore the callback function will be applied to all routes.<br/>In this example we log a simple message to the console to acknowledge the request however in more complex applications this could be a lot more useful.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">next()</span></td>
                            <td>Next</td>
                            <td>In an application there may be multiple routes defined that are intended to trigger one after the other to provide some specific functionality.<br/><br/>The <span class="attribute">next()</span> method is how we chain middlewares together.<br/>An example of how this is used is shown below;<br/><br/><span class="code">GET /magic/fireball</span><br/><br/><span class="attribute">app.use((req, res, next) => {<br/>console.log("A sorcerer approaches!");<br/>next();<br/>});<br/><br/>app.get('/magic/:spellname', (req, res, next) => {<br/>console.log("The sorcerer is casting a spell!");<br/>next();<br/>});<br/><br/>app.get('/magic/:spellname', (req, res, next) => {<br/>console.log(`The sorcerer has cast ${req.params.spellname}`);<br/>res.status(200).send();<br/>});<br/><br/>app.get('/magic/:spellname', (req, res, next) => {<br/>console.log("The sorcerer is leaving!");<br/>});</span><br/><br/>In the example shown above we receive a GET request. The <span class="attribute">app.use()</span> route is triggered because there is no path assigned and therefore will trigger on every request.<br/>'A sorcerer approaches!' is printed to the console as per the body of the callback function for that route.<br/>Within the callback function we also have a <span class="attribute">next()</span> call.<br/>This call, instead of finishing the process allows the code to pass control onto the next matching route if there is one.<br/>There is another matching route for our GET request therefore the next middleware is invoked and the <span class="attribute">app.get()</span> route is triggered.<br/>'The sorcerer is casting a spell' is printed to the console.<br/>Another <span class="attribute">next()</span> call follows, passing control to the next matching route.<br/>This route matches the GET request and therefore logs the phrase 'The sorcerer has cast fireball' to the console.<br/>Notice however that this callback function does not contain a <span class="attribute">next()</span> call.<br/>This then does not allow control to pass onto our final middleware and instead the process is finished without the final middleware triggering even though the route is valid and matches our request.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Using middleware to provide checking logic to multiple routes</td>
                            <td>On many routes there is likely the need to provide checking logic against submitted information. Checking against usernames, passwords, whether submitted information is formatted correctly or even orf the correct type.<br/><br/>Following the the principles of DRY coding we can write a middleware that does this for us, and even more importantly we can write route specific versions of this.<br/><br/>Lets say we have an application that has multiple endpoints, each one providing different functionality to our website.<br/>Things like <span class="code">/jellyBean</span>, <span class="code">/lollipop</span>, <span class="code">/iceCream</span> etc...<br/>Lets also say that we have various routes defined in our application on the <span class="code">/jellyBean</span> route.<br/><br/>On those routes we want to provide targetted checking logic. This is to make sure that whatever <span class="code">/jellyBean</span> requests come in, look for valid information held in our database.<br/>To do this we can create a middleware that only targets this endpoint for whatever GET, PUT, POST or DELETE request might come in .<br/>This will serve as the first stop in the middleware chain to provide the check to ensure the request is valid before spending any further processing power on the request.<br/>It will also allow us to take all of this additional checking logic out that previously would be held in each individual callback functions of the various GET, PUT, POST and DELETE routes.<br/><br/><span class="attribute">app.use('/jellyBean', (req, res, next) => {<br/>const productName = req.params.productName;<br/>if (!productDatabase[productName]) {<br/>console.log('Response Sent');<br/>return res.status(404).send('Product with that name does not exist');<br/>}<br/><br/>next();<br/>});</span><br/><br/>The code above invokes the <span class="attribute">.use()</span> method and mounts it on the <span class="code">/jellyBean</span> path endpoint. This means any request that comes in on that path will first be run through the middleware to check the request is valid.<br/>The checking logic here is not important as its just a generic logic to demonstrate the point however within the checking logic notice how there is a <span class="attribute">return</span> on the <span class="attribute">if</span> statement.<br/>This is important as it provides a break point for the code if the request fails the checking logic. It stops the code from running any further and provides a 404 failure code back to the front end.<br/><br/>Notice also how at the end of the callback functions body is a <span class="attribute">next()</span> call. This ensures that if the request is deemed valid by the checking logic it will then pass control onto the next matching middleware.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Adding additional parameters to the request object</td>
                            <td>The chaining of middleware allows us to manipulate the requests as they come in.<br/>We might want to do this to allow for simpler logic elsewhere in our back end or to pick out various parameters for manipulation at the next middleware in the chain.<br/><br/>To do this is quite simple.<br/><br/><span class="attribute">app.use('/endpoint', (req, res, next) => {<br/>req.keyOne = valueOne;<br/>req.keyTwo = valueTwo;<br/>next();<br/>});</span><br/><br/>In the above example middleware we have, within the callback function, 2 new parameters added to the request object. As you can see it is as simple as adding them to the request object like we would with any normal addition to any object.<br/>We assign it a key and then assign that key a value.<br/>These properties will now be accessible by the next middleware as that will receive the updated request object.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">app.use(['/path1', 'path2'], callbackFunction)</span></td>
                            <td>Targetting multiple routes to reduce code</td>
                            <td>The <span class="attribute">.use()</span> method allows for multiple paths to be used in the first path argument provided they are presented as an array.<br/>This is a powerful option as it allows us to use a single middleware to provide the same functionality to multiple routes that require it without having to duplicate our code.<br/>This builds on the DRY coding principles of reducing the amount of code needed.<br/><br/>We can use this just as we did with the singular route to provide checking logic to a route before allowing the code to continue processing.<br/>This however will be applicable to multiple routes.<br/><br/><span class="attribute">app.use(['/jellyBean', '/lollipop', '/iceCream'], (req, res, next) => {<br/>const productName = req.params.productName;<br/>if (!productDatabase[productName]) {<br/>console.log('Response Sent');<br/>return res.status(404).send('Product with that name does not exist');<br/>}<br/><br/>next();<br/>});</span><br/><br/>In the example above we have the same code as described in the previous example showing how to apply checking logic in a middleware prior to passing control on to any GET, PUT, POST or DELETE method logic.<br/>The main change and most important thing to notice here is that in the first argument of the <span class="attribute">.use()</span> method we have an array that contains multiple routes.<br/>If a request is received that matches either of these routes then this middleware will trigger and the callback function will be invoked. If there is no match then the app will simply carry on normal and continue looking for a matching route.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">app.use('/path1', callbackFunction1, callbackFunction2)</span></td>
                            <td>Using defined callbacks and using multiple callbacks</td>
                            <td>The <span class="attribute">.use()</span> method also allows for multiple callbacks to be used in the second path argument, these however, do not need to be presented in an array. They can be presented as an array however it is assumed that after the first argument all following arguments will be callback functions.<br/><br/>An example of how this might work is shown below;<br/><br/><span class="attribute">const authenticate = (req, res, next) => {<br/>//Authentication logic in here...<br/>next();<br/>};<br/><br/>const validateData = (req, res, next) => {<br/>//validation logic in here...<br/>next();<br/>};<br/><br/>const getSpell = (req, res, next) => {<br/>res.status(200).send(getSpellById(req.params.id));<br/>};<br/><br/>const createSpell = (req, res, next) => {<br/>createSpellFromRequest(req);<br/>res.status(201).send();<br/>};<br/><br/>const updateSpell = (req, res, next) => {<br/>updateSpellFromRequest(req);<br/>res.status(204).send();<br/>}<br/><br/>app.get('/spells/:id', authenticate, getSpell);<br/><br/>app.post('/spells', authenticate, validateData, createSpell);<br/><br/>app.put('/spells/:id', authenticate, validateData, updateSpell);</span><br/><br/>In the code above we have 5 defined functions each doing various different things.<br/>At the bottom we have our GET, POST and PUT routes. Notice how instead of writing anonymous functions with their own logic we have inserted the named functions.<br/>These will process one after the other in the order they are written. Provided a <span class="attribute">next()</span> call is also included at the end of each function it will then pass control onto the next function in the list of arguments.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">morgan()</span></td>
                            <td>Using open source middleware</td>
                            <td>Open source middleware can be installed and required in to allows us to spend less time creating functions that already exist as open source entities.<br/>As an example <span class="attribute">morgan()</span> is a request logging middleware that we can use in our application that provides us with console logs on the requests being made to our server.<br/><br/>Lets run though an example of how we can install and use this open source middleware in our application.<br/><br/>Because <span class="attribute">morgan()</span> is external we need to install it first. We do this in the usual way on our command line;<br/><br/><span class="code">npm i morgan</span><br/><br/>Then within our application we need to require it in;<br/><br/><span class="attribute">const morgan = require('morgan');</span><br/><br/>As with most open source middleware, there will be various instructions on how to use it with information on possible arguments it can take etc. the npm site for morgan goes through these and can be found <a href="https://www.npmjs.com/package/morgan" target="_blank">here</a>.<br/>For our example we will be using the argument <span class="attribute">'tiny'</span> as this will give us a minimal log to the console that lets us know the method of the request, endpoint being used, response code, response itself and then the response time<br/><br/>Once <span class="attribute">morgan()</span> is in our application we can then mount it as a route with the below code;<br/><br/><span class="attribute">app.use(morgan('tiny'));</span><br/><br/>This middleware has all of the expected functions it receives a <span class="attribute">req</span>, <span class="attribute">res</span> and <span class="attribute">next</span> argument and then sends them on. This small line of code essentially replaces something like the below;<br/><br/><span class="attribute">app.use((req, res, next) => {<br/>console.log(`${req.method} Request Received`);<br/>next();<br/>});</span><br/><br/>It reduces the amount of code to sift through and provides more information.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">bodyParser()</span></td>
                            <td>Using open source middleware to process the body of a request</td>
                            <td>An HTTP request will often include a body.<br/>This is block of information sent to the server for processing. This could be anything like details for the registration of a new user or a comment posted by a user.<br/><br/>Dealing with this can require some fairly complex code however there are open source middlewares available that will be continually kept up to date that can do this for us.<br/><br/>One example of this is <span class="attribute">body-parser</span>.<br/>As with our previous open source middleware example we need to install it as a dependency through our command line and then require it into our application before using.<br/><br/><span class="code">npm i body-parser</span><br/><br/>And then we require it in;<br/><br/><span class="attribute">const bodyParser = require('body-parser');</span><br/><br/>Finally we apply it our routes;<br/><br/><span class="attribute">app.use(bodyParser.json());</span><br/><br/>This simple line of code provides greater functionality in far fewer lines than something like the code shown below;<br/><br/><span class="attribute">const bodyParser = (req, res, next) => {<br/>let queryData = '';<br/>req.on('data', (data) => {<br/>data = data.toString();<br/>queryData += data;<br/>});<br/>req.on('end', () => {<br/>if (queryData) {<br/>req.body = JSON.parse(queryData);<br/>}<br/>next();<br/>});<br/>};</span><br/><br/>Now the interesting thing here is that this open source middleware comes with its own methods and this is an important thing to note generally on external middlewares.<br/>They will have their own instructions for use and reading the documentation on how to operate these correctly is something that cannot be skipped.<br/>In the above example we call the <span class="attribute">bodyParser</span> and invoke its own <span class="attribute">.json()</span> method upon it. This will parse all body information into JSON format.<br/>Without reading the documentation this would not be immediately obvious.<br/><br/>Further documentation for this particular middleware can be found <a href="https://www.npmjs.com/package/body-parser" target="_blank">here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">Error</span></td>
                            <td>Error handling middleware</td>
                            <td>Error handling middleware needs to be the last <span class="attribute">app.use()</span> in your file. If an error happens in any of our routes, we want to make sure it gets passed to our error handler. The middleware stack progresses through routes as they are presented in a file, therefore the error handler should sit at the bottom of the file right before our <span class="attribute">app.listen()</span> call at the very bottom.<br/><br/>In examples above we provide error handling in each request route but these don't provide information or options to do anything other than send back an error code.<br/>Implementing error handling middleware allows us to introduce additional logic to give us more feedback on the error and even possibly do something about it.<br/><br/>Below is an example of the syntax used for creating the error handling middleware;<br/><br/><span class="attribute">app.use((err, req, res, next) => {<br/>const status = err.status || 500;<br/>res.status(status).send(err.message);<br/>console.log(`${err.message}`);<br/>});</span><br/><br/>Notice that in addition to our usual <span class="attribute">req</span>, <span class="attribute">res</span> and <span class="attribute">next</span> arguments we also now include the <span class="attribute">err</span> argument.<br/>This is the error object that will be created and passed into the middleware in the event of our app encountering and then creating a new error.<br/>Within the body of this middleware we are also referencing status codes and error messages with the assumption that these details will be passed down to us through the middleware stack.<br/>Because of this flow of information down the stack we then want to refactor our other middlewares to create and pass this information down so that we can properly process this information in the event of an error.<br/><br/>As an example lets take the below code that has its own error code handling within the middleware itself.<br/><br/><span class="attribute">app.use('/jellyBean', (req, res, next) => {<br/>const productName = req.params.productName;<br/>if (!productDatabase[productName]) {<br/>return res.status(404).send('Product with that name does not exist');<br/>}<br/><br/>next();<br/>});</span><br/><br/>This does the job perfectly fine but in our new error handling middleware set up this doesn't pass any information on to enable us to see what else is going. Its just a static error.<br/>Below is an example of the same middleware refactored to create an error object, add information to that object and then invoke our error handling middleware whilst passing this information on to it.<br/><br/><span class="attribute">app.use('/jellyBean', (req, res, next) => {<br/>const productName = req.params.productName;<br/>if (!productDatabase[productName]) {<br/>let productError = new Error('Product with that name does not exist');<br/>productError.status = 404;<br/>return next(productError);<br/>}<br/><br/>next();<br/>});</span><br/><br/>Notice how we still have the same type of information (the status code, the error message) however, we create a new error object, add the status code to that object as well as the message and then we return the <span class="attribute">next()</span> call including the new error object as the argument.<br/>This bit is particularly important as the return breaks the stack.<br/>Instead of passing control to the next middleware this, if invoked, recognises an error and skips everything else and progresses straight to our error handling middleware.<br/>Because we have created an error object these elements are accessed using dot notation.<br/>So the error message would be accessible at <span class="attribute">err.message</span> and we can see that we define the status code at <span class="attribute">err.status</span><br/><br/>While our given example doesn't do much with this information other than send a message, in more complex applications this provides us with an opportunity for more interactivity with the error.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Express.js maintained middleware</td>
                            <td>The Express.js team maintain a list of useful middleware.<br/>Some of this used to be bundled in with Express however to reduce bloat it can simply be required in as necessary.<br/><br/>The full list can be found on the <a href="https://expressjs.com/en/resources/middleware.html" target="_blank">Express.js Middleware Website</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.param()</span></td>
                            <td>Parameter matching in middleware</td>
                            <td>In many of our routes we are likely using parameters as placeholders to match to certain elements on our backend, things like items in a database for example.<br/>Due to the fact that we don't know what the user input will be, the code body of that middleware will likely have some sort of checking logic. This provides us with a sense check on the request before progressing any further.<br/>So, for example, if the requested item does not exist we can quickly return an error indicating that the item doesn't exist before processing any further code.<br/><br/>Having this sense checking logic inevitably ends up in the same sense checking logic being written multiple times as the app grows in complexity and more middlewares are required to do various tasks.<br/>The <span class="attribute">.param()</span> method allows us to write a middleware that provides a sense check once and simplify the rest of the middlewares into doing what we actually want them to do, thereby using DRY coding principles and simplifying the code.<br/><br/>An An example is shown below;<br/><br/>Lets say that we have our database of jellybeans and then on our backend we have multiple middlewares that provide GET, PUT, POST and DELETE functionality.<br/>Each one of those middlewares will have an endpoint that looks like the following;<br/><span class="code">/jellyBean/:jellyBeanId</span><br/><br/>As mentioned above, because we don't know what the user request will be, we will need to provide checking logic against each of these endpoints for the <span class="code">:jellyBeanId</span> parameter to ensure the request is valid.<br/>This means the same logic will need to be written 4 times, once for each of the middlewares.<br/>The logic for the GET request might look something like the below;<br/><br/><span class="attribute">app.get('/jellyBean/:jellyBeanId', (req, res, next) => {<br/>const params = req.params.jellyBeanId;<br/>const jellyBeanId = jellyBeanDatabase.findIndex(jellyBean => jellyBean.id === params;);<br/>if (jellyBeanId !== -1) {<br/>res.send(jellyBeanDatabase[params]);<br/>} else {<br/>res.status(404).send('JellyBean Not Found');<br/>});</span><br/><br/>However we can avoid this by using the <span class="attribute">.param()</span> method and creating a new middleware that is ordered to trigger before any of these other middlewares.<br/>Our <span class="attribute">.param()</span> method should be placed above any of the routes, so it triggers first, and then in this case it might look something like the below;<br/><br/><span class="attribute">app.param('jellyBeanId', (req, res, next, id) => {<br/>const jellyBeanId = Number(id);<br/>const found = jellyBeanDatabase.findIndex(jellyBean => jellyBean.id === jellyBeanId);<br/>if (found !== -1) {<br/>req.jellyBeanIndex = found;<br/>next();<br/>} else {<br/>res.sendStatus(404);<br/>}<br/>})</span><br/><br/>There are a few things to note here, the first is that the route handler doesn't contain a <span class="attribute">:</span> before the parameter, it's just <span class="attribute">jellyBeanId</span>. The parameter is passed into the callback function, which now has 4 arguments. The last one being that parameter.<br/>Within our logic we do a quick check to make sure its a number and then store that parameter in a variable.<br/>This is then used in a <span class="attribute">.findIndex()</span> method to check our database to see if an entry that matches that index exists, if it does then that number is stored in the variable <span class="attribute">found</span>.<br/>After this we have a simple <span class="attribute">if...else</span> statement that attaches that index number to the <span class="attribute">req</span> object under <span class="attribute">jellyBeanIndex</span> for future use in other middlewares, or if the logic fails we send back an error status code.<br/><br/>With this no in place we can refactor all of our GET, PUT, POST and DELETE requests to remove any checking logic as the <span class="attribute">.param()</span> middleware will do it first before passing it on to the relevant route handlers.<br/>So for example our GET route from earlier might be refactored to look like the below;<br/><br/><span class="attribute">app.get('jellyBean/:jellyBeanId', (req, res, next) => {<br/>res.send(jellyBeanDatabase[req.jellyBeanIndex]);<br/>});</span><br/><br/>Notice how much simpler the route becomes. Also notice how we now use the new request object parameter of <span class="attribute">.jellyBeanIndex</span> to send back the relevant information as we have already done the check and created this parameter in the <span class="attribute">.param()</span> middleware.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">{ mergeParams: true }</span></td>
                            <td>Nested routes and merging parameters</td>
                            <td>The nesting of routes has already been covered, its a useful method to separate concerns in larger apps in a similar way that modules deal with differing parts of an app in React applications.<br/><br/>In React, if we want a child module to access data from the parent module we can pass it down through props.<br/>We can do a similar thing in express with routes. We can allow the parameters from a parent route to be used in a child route.<br/><br/>Lets say we have a database of sorcerers and then a separate database of spells.<br/>Multiple sorcerers might use the same spell, meaning that our route is likely to have a <span class="attribute">:sorcererId</span> style parameter in its route.<br/>As such we might then have a <span class="attribute">.param()</span> middleware that extracts this parameter.<br/>This parameter can be passed down for use in nested routes much like props are used in React applications.<br/>In order to do that we need to tell express that we want these parameters to be passed down. We do this by including a configuration object when we define the router.<br/>The syntax for this is shown below;<br/><br/><span class="attribute">const parentRouter = express.Router();<br/>const nestedChildRouter = express.Router({ mergeParams: true });</span><br/><br/>So now that we have told express that we want the parameter of the parent router to be passed down to the nested child router we can then reference those parameters without the need to specifically define them in some way.<br/><br/>The reason this is important is that the normal behaviour in express for nested child routers is that if the parent route includes parameters (<span class="attribute">:sorcererId</span>) these parameters are not available inside the nested child route by default.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="authentication_authorization">
                <h2>Authentication & Authorization</h2>
                <p>This section explains some of the concepts and syntax behind User authentication and authorization in general.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Authentication</td>
                            <td>Authentication is the process of verifying who you are.<br/><br/>This can be through supplying username and passwords or username and PIN codes. There can be various different identifier and entry code style combinations, all of which should be unique to each person.<br/><br/>A username and password system is known as single factor, it is also becoming increasingly insecure.<br/>Multi factor authentication is the process of logging in using a username and password and then receiving a secondary temporary passcode on a secondary laptop, phone or email address. This way the genuine user who has set up this login system has access to the various devices being used to log in and therefore makes it much harder for anyone else to gain access as they are unlikely to have access to the additional devices/email addresses.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Authorization</td>
                            <td>Authorization is the verification of what you are allowed to do.<br/><br/>You might be logged in, however you might not be allowed to edit other user's information unless you have administrator privileges.<br/><br/>Authorization prevents users from accessing parts of an application which they are not intended to access.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Encryption</td>
                            <td>Encryption is the process of transforming data into an unreadable format unless you have the correct key to decode the data.<br/><br/>This prevents information from being stolen/intercepted and therefore prevents things like authentication and authorization from being overridden.<br/><br/>There are two main types of encryption, single key and asymmetrical.<br/><br/>Single key encryption is the process of encoding the data with a key that both the sender and the receiver possess.<br/><br/>Asymmetrical encryption is the process of encoding the data with one key on the sender's side and then decoding it with another key on the receiver's side.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Sessions & Cookies</td>
                            <td>Websites can often provide personalised user experiences. Things like colour changes to the homepage or providing customised search options etc.<br/>This can be done through a user logging in, but it can also be done on a temporary basis through the use of sessions.<br/>A session is similar to a temporary login.<br/>The user can make various changes to suit their preference and the app can remember these, keeping their preferences consistent during the user's browsing time.<br/><br/>Session data is stored server-side and associated with a session ID.<br/>Sessions are best thought of as short term memory for a web app.<br/><br/>While session data is stored server side, the actual ID associated with that data is kept client side. This is done in the form of cookies.<br/><br/>Cookies are small text files no bigger the 4kb.<br/>The browser stores these and they are automatically sent with HTTP requests to a web app.<br/>They are set by the HTTP response header in key-value pairs. A session cookie is et set with the first HTTP response from the server and persists until the browser is closed or the cookie expires.<br/>They look similar to the example below;<br/><br/><span class="attribute">Set-Cookie: sessionID=34jgL79b</span><br/><br/>A session would usually follow the events listed below;<br/>1. User navigates to a site. The web server creates a session and a session ID.<br/>2. In the server's response, it tells the browser to store a cookie with the session ID. The should not include any personal information.<br/>3. The session ID cookie automatically attaches to each HTTP request to the server.<br/>4. When the server reads the session ID cookie sent t=with the HTTP request, it returns the session data associated with the ID.<br/>5. The process continues as long as the session is active.<br/>6. The session and session ID cookie expires after a user closes out the browser, logs out or a pre-determined time passes.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Cookie security</td>
                            <td>Cookies can contain sensitive information, including things like personal preferences and browsing history.<br/>To prevent malicious actors from gaining access to this information we can provide security to the cookies. This can range from simple expiration dates set on the cookies to other keywords that can prevent cross site scripting attacks.<br/><br/>Below is an example of setting a cookie with an expiration date and time;<br/><br/><span class="attribute">Set-Cookie:Key=Value; expires=Saturday, 01-May-2027 07:30:00 GMT</span><br/><br/>We can also add additional keywords after this to provide added security.HTTPOnly ensures that the cookie data is not accessible to a script running client-side. This will prevent cross site scripting attacks.<br/>Example syntax is shown below;<br/><br/><span class="attribute">Set-Cookie:Key=Value; expires=Saturday, 01-May-2027 07:30:00 GMT; HTTPOnly</span><br/><br/>2 other common keywords are;<br/><br/><span class="attribute">SameSite</span> - This helps prevent cross site request forgery attacks<br/><br/><span class="attribute">Secure</span> - This makes sure that cookies are only sent with a request to an HTTPS page<br/><br/>There are further options which can be found with detailed explanations <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Set-Cookie" target="_blank">here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">localStorage</span> & <span class="attribute">sessionStorage</span></td>
                            <td>Local Storage & Session Storage</td>
                            <td>Cookies provide a way of accessing sessions however the attaching the data to each request, constantly sending it back and forth can affect site performance. Cookie data is also limited to just 4kb which is very small.<br/><br/><span class="attribute">localStorage</span>/<span class="attribute">sessionStorage</span> are newer forms of client side storage introduced when HTML5 came out.<br/><br/><span class="attribute">localStorage</span> stores data in browser as key-value pairs. It can also store up to 10MB of data, a significant increase.<br/>It does not interact with the server but is modified and accessed by client side JavaScript code.<br/>It also persists after the users has closed the browser, it will clear once the browser cache is deleted.<br/><br/><span class="attribute">sessionStorage</span> uses the same syntax as <span class="attribute">localStorage</span> but holds session data. It can only hold 5MB of data but still a lot more than cookies. This does clear when the browser or tab is closed and therefore is more secure as well as being more of a temporary measure.<br/><br/>To set key-values to local storage the syntax would be as follows;<br/><br/><span class="attribute">localStorage.setItem('key', 'value');</span><br/><br/>A practical example of this is shown below;<br/><br/><span class="attribute">function selectProfile(name){<br/>if (name != localStorage.getItem('profile')) {<br/>alert("Now setting character to... " + name)<br/>}<br/>localStorage.setItem('profile', name);<br/>}</span><br/><br/>In the example above we set the key to <span class="attribute">'profile'</span> and we use a variable that is set by some incoming value to set the value. This is then stored in <span class="attribute">localStorage</span> and can be accessed later.<br/><br/>To access this information we would use the syntax;<br/><br/><span class="attribute">localStorage.getItem('key');</span><br/><br/>Once again, a practical example of this would be;<br/><br/><span class="attribute">function loadProfile(){<br/>// Set character to the 'profile' value from localStorage<br/>var character = localStorage.getItem('profile');<br/><br/>if (character) {<br/>display_character(character)<br/>}<br/>}</span><br/><br/>This accesses the <span class="attribute">localStorage</span> key of <span class="attribute">'profile'</span> and returns its value which is then used to display a character elsewhere in the web app.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Session Security</td>
                            <td>Session security is important to prevent hijacking by malicious actors. For example if someone is doing some internet banking and their session gets hijacked, the malicious actor could transfer funds from the victims bank to another account.<br/>There are a few good practice elements that can be implemented to help prevent this;<br/><br/><span class="code">Define session expiry</span><br/>Simply by ensuring that a session has a time limit can close the window to anyone with malicious intent.<br/>Automatic session expiry on the back end and then session expiry on the client side significantly impacts a hacker's window to get in and cause harm.<br/>Idle timeouts are popular but absolute timeouts are an even stricter way to ensure security albeit at the expense of possibly annoying users with the need to consistently refresh the session.<br/><br/><span class="code">Make Session ID's difficult to hack</span><br/>Session ID's are basically passwords. The longer and more complex they are, the more difficult it is for a hacker to gain access.<br/>They are ideally over 128 bits long and do not contain any kind of personal information to reduce the possibility of guessing.<br/>Any kind of algorithm should also not follow any kind of predictable pattern which would aid hacking.<br/><br/><span class="code">Securing Cookies</span><br/>If cookies are to be used then they should be secured with the keywords already discussed. This makes them harder to steal.<br/><br/><span class="code">Enforce HTTPS</span><br/>All sessions based web apps should enforce HTTPS for communications. This prevents web attacks and prevents the attacker gaining access to the session.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>HTTP Security Headers</td>
                            <td>HTTP security headers are response headers that get sent back by the server upon a request. They include security information, telling the browser how to behave and what security policies it should be employing with the web app.<br/>By implementing these security policies they prevent numerous attacks and are generally good practice in providing a more secure environment all round.<br/><br/>There are numerous options and there will be multiple employed in a well written app.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">Strict-Transportation-Security</span></td>
                            <td>HTTP Security Headers</td>
                            <td>This header tells the browser that only the HTTPS version of the requested site is available. This means only HTTPS can be used and therefore the communication between them is more secure.<br/><br/><span class="attribute">Strict-Transport-Security: max-age31536000; includeSubDomains</span><br/><br/>The above example defines that the browser should remember that this app is only to be accessed using HTTPS for the length of 1 year (31536000 seconds), the <span class="attribute">includeSubDomains</span> keyword also tells it to apply this to sub domains of the app.<br/><br/><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Strict-Transport-Security" target="_blank">More detailed information on this header can be found here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">Content-Security-Policy</span></td>
                            <td>HTTP Security Headers</td>
                            <td>This defines an allowlist of where content is to be loaded from. It restricts assets the browser can load while using the current website. It prevents cross site scripting attacks by defining that the browser cannot load JavaScript from other sources than those defined by the header.<br/><br/><span class="attribute">Content-Security-Policy: script-src 'self'; img-src 'self' https://www.thiswebsite.com</span><br/><br/>The above example defines that the browser should not load scripts or images from any other source than https://thiswebsite.com<br/><br/><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CSP" target="_blank">More detailed information on this header can be found here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">X-Frame-Options</span></td>
                            <td>HTTP Security Headers</td>
                            <td>This header stops the current page from being hidden in an <span class="code">&lt;iframe&gt;</span> tag in another sites HTML. This prevents clickjacking which is the process of deceiving the user to click on something they think is harmless when in fact its actually an invisible button that redirects to something more nefarious such as delete account or transfer funds etc.<br/><br/><span class="attribute">X-Frame-Options: DENY</span><br/><br/>The above example means that the webpage cannot be hidden in a <span class="code">&lt;iframe&gt;</span> tag anywhere. There are other options that allow partial access if necessary<br/><br/><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Frame-Options" target="_blank">More detailed information on this header can be found here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">helmet()</span></td>
                            <td>How to set security headers in express using Helmet</td>
                            <td>Helmet is a middleware that can be installed and then used to set the security headers.<br/>You can install it in the usual way;<br/><br/><span class="code">npm install helmet</span><br/><br/>It is then implemented within the server in the usual way;<br/><br/><span class="attribute">const helmet = require('helmet');<br/>app.use(helmet());</span><br/><br/>There are numerous options to configure the middleware however the default options set most of the headers as standard<br/><br/><a href="https://www.npmjs.com/package/helmet/v/6.1.2" target="_blank">More detailed information on this header can be found here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>How to set security headers in other common servers</td>
                            <td><span class="code">nginx</span><br/>The following is added to an nginx server's config file to add the <span class="attribute">Strict-Transport-Security</span> header to all HTTP responses;<br/><br/><span class="attribute">add_header Strict-Transport-Security: 'max-age31536000; includeSubDomains always;'</span><br/><br/><a href="https://blog.nginx.org/blog/http-strict-transport-security-hsts-and-nginx" target="_blank">This link</a> details the options for this header as well as serving as a guide for adding other headers in the same environment<br/><br/><br/><br/><span class="code">Apache</span><br/>The following is added to an Apache server's config file (located at /etc/httpd/conf/httpd.conf) to add the <span class="attribute">Strict-Transport-Security</span> header to all HTTP responses;<br/><br/><span class="attribute">Header always set Strict-Transport-Security: "max-age31536000; includeSubDomains"</span><br/><br/><br/><br/><span class="code">Microsoft IIS</span><br/>The following is added to the Web.config file's <span class="attribute">&lt;httpProtocol&gt;</span> section;<br/><br/><span class="attribute">&lt;system.webServer&gt;<br/>&lt;httpProtocol&gt;<br/>&lt;customHeaders&gt;<br/>&lt;add name="Content-Security-Policy" value="default-src 'self';" /&gt;<br/>&lt;/customHeaders&gt;<br/>&lt;/httpProtocol&gt;<br/>&lt;/system.webServer&gt;</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="express_session">
                <h2>Express Session</h2>
                <p>This section explains some of the concepts and syntax behind the express session middleware.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">express-session</span></td>
                            <td>Using express session</td>
                            <td>We can use <span class="attribute">express-session</span> middleware on our server to generate unique session ID's.<br/>First we install it in the usual way;<br/><br/><span class="code">npm install express-session</span><br/><br/>Then we require it in to our server in the usual way;<br/><br/><span class="attribute">const session = require('express-session');</span><br/><br/>Once it's installed and present in our server we then need to configure it.<br/>The configuration object has 3 keys, these are;<br/><br/><span class="attribute">secret</span> - This property is a key used for signing and/or encrypting cookies in order to protect our session ID.<br/><br/><span class="attribute">resave</span> - This option, when set to true, will force a session to be saved back to the session data store. This happens even if there have been no changes made.<br/>Typically this should be set to false, however, that depends on the web app's session storage strategy.<br/><br/><span class="attribute">saveUninitialized</span> - This is a boolean value. When set to true, the server will store every new session, even if there are no changes to the session object. This could be useful for track recurring visits from the same browser however this does eat up memory. Setting it to false allows us to save memory.<br/><br/>An example of the configuration object in use is shown below;<br/><br/><span class="attribute">app.use(<br/>session({<br/>secret: 'oai253vj65',<br/>resave: false,<br/>saveUninitialized: false,<br/>})<br/>);</span><br/><br/>In the above example the <span class="attribute">secret</span> value would usually be a random string that is stored in a secure environment variable and not hardcoded like this. It is written like the above as an demonstration.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.MemoryStore()</span></td>
                            <td>Storing session data</td>
                            <td>Sessions are stored in 3 different ways.<br/><br/>1. In-memory (the default option)<br/>2. Databases such as MongoDB or MySQL<br/>3. In a memory cache such as Redis or Memcached.<br/><br/><span class="attribute">express-session</span> provides an in-memory store called <span class="attribute">MemoryStore()</span>. This is automatically set as the default option unless another is specified.<br/><br/>A new store can be instantiated like so;<br/><br/><span class="attribute">const store = new session.MemoryStore();</span><br/><br/>This can then be added to the configuration object like so;<br/><br/><span class="attribute">app.use(<br/>session({<br/>secret: 'oai253vj65',<br/>resave: false,<br/>saveUninitialized: false,<br/>store,<br/>})<br/>);</span><br/><br/>An important note about the above code is that in-memory sessions should only be used in development and not in production as they provide security risks.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">cookie: {}</span></td>
                            <td>Creating session cookies</td>
                            <td>To create a cookie for our session we should define it within the configuration object.<br/>To define the cookie we need to define key-values of the various elements of the cookie we want to create. An example is shown below;<br/><br/><span class="attribute">app.use(<br/>session({<br/>secret: 'oai253vj65',<br/>cookie: { maxAge: 172800000, secure: true, sameSite: 'none'},<br/>resave: false,<br/>saveUninitialized: false,<br/>store,<br/>})<br/>);</span><br/><br/>in the above example we create a cookie that expires in 48 hours, it is only to use HTTPS and then we allow for cross-site. Differing parameters can be added to enable differing cookies to be created.<br><br/><a href="https://expressjs.com/en/resources/middleware/session.html" target="_blank">More detailed information on the options for this can be found here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">req.session</span></td>
                            <td>Using the session to authenticate users</td>
                            <td>We can use the session now it has been configured.<br/>Lets use an example to demonstrate what we might add and how we might utilise the session object.<br/><br/>In this example we have a simple login page that asks for a username and a password.<br/>If a user logs in with the correct credentials we want to create a session.<br/>Within our POST request logic to login we might have something that look like the following;<br/><br/><span class="attribute">if (user.password === password) {<br/>req.session.authenticated = true;<br/>req.session.user = {<br/>username,<br/>password,<br/>}<br/>}</span><br/><br/>Now the above code is an extremely simplified version of the internal logic of a POST request but you can see the essence of what it's doing.<br/>Once the user has passed our checking logic to ensure they are authenticated we'll add an <span class="attribute">authenticated</span> property to the session object that is set to true so that we know they are authentic.<br/>We then add a <span class="attribute">user</span> property that we populate with a new object that contains the received <span class="attribute">username</span> and <span class="attribute">password</span> properties following authentication.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">req.session.authenticated</span></td>
                            <td>Accessing session data</td>
                            <td>In the example above we add additional key-values to the session object, we can leverage those properties to provide security checking middleware in our app to ensure that people who should not be allowed to access certain parts of the app cannot do so.<br/><br/><span class="attribute">function authorizedUser(req, res, next) {<br/>if (req.session.authenticated) {<br/>res.next();<br/>} else {<br/>res.status(403).json({ msg: 'You're not authorized to view this page' });<br/>}<br/>};</span><br/><br/>In the above example code we have a named function that does a very simple check and then either passes control or sends back an error.<br/><br/>We would put this in front of whatever route we wanted to provide a level of security over like an admin page for example to check that the logged in user has admin privileges.<br/>This could look like the following;<br/><br/><span class="attribute">app.get('/secretAdminSection', authorizedUser, (req, res, next) => {<br/>//whatever code goes here<br/>});</span><br/><br/>Notice how we simply add in the checking middleware for the route to provide a check against the logged in user's credentials.<br/>If they have access rights, the server will carry on, if not then it will throw an error and they will be denied access.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">res.render()</span></td>
                            <td>Passing session information to populate a view template</td>
                            <td>A view template (also called a template file or view) is a file that defines the structure of your HTML pages, but with placeholders for dynamic content. These files are used by template engines like EJS, Pug, or Handlebars to generate HTML on the server side.<br/>Instead of writing raw HTML manually for every response, you write one template with "holes" in it, and then fill in those holes with real data when rendering the page using <span class="attribute">res.render()</span> in Express.<br/><br/>Template = Blueprint of the page<br/><span class="attribute">res.render()</span> = fills in the blanks using your data<br/>Result = full HTML page sent to the browser<br/><br/>An example of how this could work is shown below;<br/><br/>Below is the template HTML;<br/><br/><span class="attribute">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>&lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;h1&gt;Welcome, &lt;%= username %&gt;!&lt;/h1&gt;<br/>&lt;p&gt;Your role: &lt;%= role %>&lt;/p&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span><br/><br/>The following code would be contained in the relevant express route;<br/><br/><span class="attribute">app.get('/profile', (req, res, next) => {<br/>res.render('profile', {<br/>title: 'User Profile',<br/>username: req.session.user.username,</span> <span class="code">//'Matt'</span><br/><span class="attribute">role: 'req.session.user.role',</span><span class="code">//'Admin'</span><br/><span class="attribute">});<br/>});</span><br/><br/>Both of the above would result in the HTML shown below;<br/><br/><span class="attribute">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>&lt;title&gt;User Profile&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;h1&gt;Welcome, Matt!&lt;/h1&gt;<br/>&lt;p&gt;Your role: Admin&lt;/p&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">jsonwebtoken</span></td>
                            <td>JSON Web Tokens</td>
                            <td>JSON Web tokens are another method of authentication with pro's and cons.<br/><br/><a href="https://supertokens.com/blog/what-is-jwt" target="_blank">An in depth look at them and how to use them can be found here</a></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="passport">
                <h2>Passport.js</h2>
                <p>This section explains the Passport.js middleware, including concepts and syntax.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Passport.js</td>
                            <td>What is Passport.js?<br/>Passport.js is an express middleware that allows us to implement authentication using the concepts of strategies.<br/><br/>Strategies are separate modules created to work with different means of authentication. They are basically plugin's that define how a user's credentials are submitted and verified.<br/>This can be things like username/password combinations, OAuth login services through things like Facebook or Google (login with Facebook etc...).</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">passport</span> & <span class="attribute">passport-local</span></td>
                            <td>Configuring Passport.js</td>
                            <td>Before we can use Passport we need to install, require in and then configure it.<br/>We install it in the usual way;<br/><br/><span class="code">npm install passport passport-local</span><br/><br/>Then we require it in to our server in the usual way;<br/><br/><span class="attribute">const passport = require('passport');<br/>const LocalStrategy = require('passport-local').Strategy;</span><br/><br/>The <span class="attribute">passport-local</span> module allows us to use the traditional authentication module of using usernames and passwords that we control in a database somewhere.<br/>To use other services like facebook we would install <span class="code">passport-facebook</span> and require that in.<br/>For this exercise we will be using traditional methods.<br/><br/>Now that we have the package installed and required in, we need to implement it. We do this with the <span class="attribute">initialize()</span> method.<br/>That would look something like the following;<br/><br/><span class="attribute">app.use(passport.initialize());</span><br/><br/>Next we want to allow for persistent logins so we call the <span class="attribute">session()</span> method on <span class="attribute">passport</span>.<br/>Syntax is shown below;<br/><br/><span class="attribute">app.use(passport.session());</span><br/><br/>This call alters the request object and allows us to attach a 'user' value that can be retrieved from the session ID.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">passport-local</span></td>
                            <td>How to use local strategy</td>
                            <td>With <span class="attribute">passport</span> initialized and session's set up we can pass a new instance of <span class="attribute">LocalStrategy</span> into <span class="attribute">passport</span> as middleware.<br/>This might look something like the following;<br/><br/><span class="attribute">passport.use(new LocalStrategy(<br/>function(username, password, done) {<br/></span><span class="code">//function body goes here<br/>//this is explained in further detail later on</span><br/><span class="attribute">}<br/>));</span><br/><br/>Before we explain what goes on in the function body lets look at what this instance of the <span class="attribute">LocalStrategy</span> object is expecting/doing.<br/><br/>As you can see, the <span class="attribute">LocalStrategy</span> object takes in an anonymous function that has the parameters <span class="attribute">username</span>, <span class="attribute">password</span> and a callback function called <span class="attribute">done</span>.<br/><br/>The <span class="attribute">done</span> callback function is method defined within the <span class="attribute">LocalStrategy</span> object. We use this within the anonymous function body to simply pass either errors or authenticated users to <span class="attribute">passport</span>. Under the hood it is best thought of as a simple function that passes information on.<br/>It is a method so it accepts 2 arguments, 1 - An error or null if no error is found, 2 - A user or false if no user is found.<br/>The <span class="attribute">username</span>, and <span class="attribute">password</span> parameters are the user input received when a user tries to log in.<br/><br/>So lets look at what the anonymous function body should be doing to authenticate a user.<br/>We want it to;<br/><br/>1 - Do a check on our database that the provided username exists.<br/>2 - If the username does not exist we want to produce an error and bounce it back.<br/>3 - If the username does exist then we want to do a check to see if the provided password is valid.<br/>4 - If the password is not valid then we want to produce an error and bounce it back.<br/>5 - If the username and password are both valid then we want to return the user object.<br/><br/>Below we have an example of a strategy.<br/>In this strategy we have a lookup function (<span class="attribute">.findByUsername()</span>), this is just a demonstration function and could behave differently however for the purpose of this example it looks up the username in the database and then returns either an error or a user object.<br/>The returned items are fed into a callback function which is where our authentication logic is located.<br/><br/><span class="attribute">passport.use(new LocalStrategy(<br/>function (username, password, done) {<br/></span><span class="code"><br/>//The below code targets our database and uses the checking method on the users key in the database</span><br/><span class="attribute">database.users.findByUsername(username, (err, user) => {<br/></span><span class="code"><br/>//If there's an error in db lookup return err in callback function</span><br/><span class="attribute">if (err) return done(err);</span><br/><span class="code"><br/>//If user is not found, return null and false in callback function</span><br/><span class="attribute">if (!user) return done(null, false);</span><br/><span class="code"><br/>//If user is found but password is invalid, return err and false in callback function</span><br/><span class="attribute">if (user.password != password) return done(null, false);</span><br/><span class="code"><br/>//If user is found and the password is valid, return the user object in the callback function</span><br/><span class="attribute">return done(null, user);<br/>});<br/>})<br/>);</span><br/><br/>Notice in the above logic we follow an error first approach, so as soon as a negative result is encountered we break out of the code.<br/>The checking logic systematically checks through each our points and if successful authenticates the user.<br/>This creates a session and is maintained via a cookie set in the user's browser.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">passport.serializeUser()</span></td>
                            <td>Serializing Users</td>
                            <td>Once a user has logged in and been authenticated successfully a session will be created and maintained with a cookie in the browser. However, if they refresh the page then this data will not persist following HTTP requests.<br/>We need to serialize and deserialize them in order to stop the information from being lost.<br/><br/>Serializing a user basically stores a bit of information about that user from the user object we will have got from their login into the session.<br/>This is usually the user's ID as it will be a unique identifier we can use later on to continually look up their information.<br/><br/>The syntax for serializing a user is as follows;<br/><br/><span class="attribute">passport.serializeUser((user, done) => {<br/>done(null, user.id);<br/>});</span><br/><br/>When we serialize a user in this manner, passport takes the second argument fed into the done callback, <span class="attribute">user.id</span> in this case, and stores it internally on the request object at <span class="attribute">req.session.passport</span>.<br/>We can access this elsewhere in our code and it would look something like the below;<br/><br/><span class="attribute">req.session.passport.user = { id: 'abc123' }</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">passport.deserializeUser()</span></td>
                            <td>Deserializing Users</td>
                            <td>With the user Id now stored in the session we can use that to access the user object from our database every time a page gets refreshed or a HTTP request is made.<br/><br/>To do this we need to deserialize the user, the syntax for this would look something like the following;<br/><br/><span class="attribute">passport.deserializeUser((id, done) => {<br/>database.users.findById(id, function (err, user) {<br/>if (err) return done(err);<br/>done(null, user);<br/>});<br/>});</span><br/><br/>Its important to note here that whatever piece of information you stored in the client side browser when serializing is what should be used when deserializing because passport knows that this is what it should be looking for.<br/>You also need to make sure the key matches, so if you used <span class="attribute">user.id</span> in the serializing, then <span class="attribute">id</span> should be used in deserializing.<br/><br/>So in the above code the <span class="attribute">id</span> is used to lookup the <span class="attribute">user</span> object in the database, the <span class="attribute">user</span> object is then returned and attached to the request object.<br/>It is stored under <span class="attribute">req.user</span> and can be accessed in every following request until logout or session timeout.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Logging In</td>
                            <td>In order for users to log in to our app we need to create endpoints to handle this.<br/><br/>A log in is actually a POST request.<br/>We send the username and password in a POST request to our server and then authenticate it with our passport middleware.<br/>If the user is valid it will be serialized, a session will be created and we're off to the races.<br/><br/>An example of a login endpoint is shown below;<br/><br/><span class="attribute">app.post("/login",<br/>passport.authenticate("local", { failureRedirect : "/login"}),<br/>(req, res) => {<br/>res.redirect("profile");<br/>}<br/>);</span><br/><br/>In the above code we can see that our endpoint is for <span class="attribute">/login</span>. Following the endpoint we have declared that we want to use our passport middleware, after this there is the usual callback function containing the <span class="attribute">req</span> and <span class="attribute">res</span> arguments and its code body.<br/><br/>There are a few interesting things going on here so lets go through them one by one.<br/><br/>We pass our passport middleware with the <span class="attribute">.authenticate()</span> method which itself contains 2 arguments.<br/>The first argument is a string specifying which strategy to employ. We have specified to use <span class="attribute">'local'</span> meaning that we will be using username and passwords to authenticate the user.<br/>The second argument is an optional object that will redirect the user to the specified page if the login process fails, in this instance we are redirecting the user back to the login page.<br/><br/>In the code body we have a <span class="attribute">res.redirect()</span> that upon successfully logging in will send a response back, redirecting the browser to the <span class="attribute">'profile'</span> page.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>User Registration</td>
                            <td>Below is a worked example of how to register a new user without using a database. This is a simplified walkthrough to show basic principles and coding patterns.<br/>Instead of a database we will use an array to hold the data.<br/><br/><span class="attribute">function createUser(user) {<br/>return new Promise((resolve, reject) => {<br/>const newUser = {</span><span class="code"><br/>// getNewId creates an updated ID<br/>for the new user</span><span class="attribute"><br/>id: getNewId(records),<br/>...user,<br/>};<br/>records = [newUser, ...records];<br/>resolve(newUser);<br/>});<br/>};<br/></span><br/><br/>The above code is a helper function used to create new users, update the "Database" array.<br/>In this function we're creating a promise in order to prevent events from becoming blocked when running the app.<br/>Once a new user is created, it gets inserted into the array and sends the newly created user back.<br/><br/>Below is a route that would be invoked when a potential new user submits their data.<br/>This action would send a POST request;<br/><br/><span class="attribute">app.post("/register", async (req, res) => {<br/>const { username, password } = req.body;<br/></span><span class="code">// Create new user with helper function:<br/></span><span class="attribute">const newUser = await database.users.createUser({username, password});<br/></span><span class="code">// Add if/else statement with the newUser as the condition:<br/></span><span class="attribute">if (newUser) {<br/></span><span class="code">// Send successful response if new user is created:<br/></span><span class="attribute">res.status(201).json({<br/>msg: 'User successfully created.',<br/>newUser,<br/>});<br/>} else {<br/></span><span class="code">// Send error response if new user failed to be created:<br/></span><span class="attribute">res.status(500).json({<br/>msg: 'Error, user not created.'<br/>});<br/>}<br/>});</span><br/><br/>Lets explain what's going on in this code.<br/>We begin by adding an <span class="attribute">async</span> keyword before the callback as the helper function we are using is a promise.<br/><br/>In the code body we extract the submitted <span class="attribute">username</span> and <span class="attribute">password</span> from the request body using destructured syntax.<br/><br/>We then create a <span class="attribute">newUser</span> variable that we await (as the helper function is a promise) and we use the helper function to create a new user, add it to the "Database" array and then return the new user on its own to populate the <span class="attribute">newUser</span> variable.<br/><br/>We then have an <span class="attribute">if...else</span> statement that checks to see if the <span class="attribute">newUser</span> variable contains information and the creation of a new user has been successful. If it has then we send back a 201 status code with a success message as well as the <span class="attribute">newUser</span> object.<br/>If there was an error then we send back a 500 status code and the error message.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.logout()</span></td>
                            <td>Logging Out</td>
                            <td>Passport exposes a logout function built in to the request object.<br/>The function can be called from any route handler in order to terminate a login session.<br/>It operates by removing the <span class="attribute">req.user</span> property and clears the login session if there is one.<br/><br/>An example of syntax is shown below;<br/><br/><span class="attribute">app.get('/logout', (req, res) => {<br/>req.logout();<br/>res.redirect('/');<br/>});</span><br/><br/>By terminating the session, the user will need to log back in and authenticate once more if they wish use features of the app that require authentication.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Logging In with other services Facebook, Google etc..</td>
                            <td>Passport allows us to log in with authentication services provided by other sites like Facebook or Google. The set up is very similar but with different configuration.<br/><br/>The official Passport website provides documentation on this and how to set it up.<br/><br/><a href="https://www.passportjs.org/docs/" target="_blank">These guides can be found here</a></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="bcrypt">
                <h2>Bcrypt.js</h2>
                <p>This section explains the bcrypt middleware, including concepts around security.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Hashing</td>
                            <td>Hashing is the process of running an input through a one way algorithm to output a different set length value.<br/><br/>Hashed values are of set length and cannot be un-hashed. They do however output the same value if the same value is consistently put in, which makes them a good starting point for user passwords.<br/><br/>A user can input a password, this can be hashed and then we can store the hashed value in our database. Whenever a user log's in in the future we can run their input through tha same hashing function and as long as they enter the correct password, the hash output will match the hash output they made during signup that we store in our database and they will be authenticated.<br/><br/>This also provides security to the users if our database were to be hacked. The hacker would only gain the hash values which cannot be reverse engineered.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Salts and Rainbow tables</td>
                            <td>While a hashed output cannot be reverse engineered, there are things called Rainbow tables. These are large databases of precomputed outputs that have been run through hashing algorithms. So, commonly used passwords may have already been run through a hashing function and the hash output is likely to exist on a rainbow table.<br/>So if our database were to be hacked and someone got hold of the stored hash functions, they could then compare these to the values in the rainbow tables. If the password has already been computed then the hackers could easily figure out the original password.<br/><br/>This is why when creating a password it is often good practice to use complex combinations as these values are not likely to have been precomputed and therefore will not be on any rainbow tables.<br/><br/>As web developers we cannot rely on users always following this advice and therefore we can implement the use of salts.<br/><br/>Salts are basically extra little values added onto a user's password before it is hashed.<br/>By adding additional values to the user's password it completely changes the output from the hashing algorithm, meaning that even if they choose to use a common password, the output of the hashing algorithm will be completely different from that same commonly used password's hash output found on any rainbow table.<br/><br/>So for example if our password is <span class="code">p@ssw0rd</span>, when we hash this we might end up with an output that looks like the following;<br/><span class="code">0f359740bd1cda994f8b55330c86d845</span><br/><br/>However if we use salts then our password combo of <span class="code">p@ssw0rd</span> + <span class="code">salts</span> when hashed will produce a completely different value that might look like the following;<br/><span class="code">91ef19df6bc9c88c5d99c9584797adee</span><br/><br/>As you can see, the hash outputs are completely different and even though we are using a common password, the use of salts provides our users with added protection against the use of rainbow tables.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">bcrypt</span></td>
                            <td>Installing bcrypt</td>
                            <td>Bcrypt is a library we can install and use to hash passwords including the use of salts.<br/>Before we can make use of it we need to install and require it in.<br/>We install it in the usual way;<br/><br/><span class="code">npm i bcrypt</span><br/><br/>Then we require it in to our server in the usual way;<br/><br/><span class="attribute">const bcrypt = require('bcrypt');</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.genSalt()</span> & <span class="attribute">.hash()</span></td>
                            <td>Hashing a password</td>
                            <td>Bcrypt uses salt and salt rounds to secure passwords.<br/>A salt is a value that is concatenated to a password before it is hashed.<br/>A salt round is best described as the amount of time needed to calculate a single hash, the higher the salt round, the more time is needed to try and crack a password.<br/><br/>In the example below we will be implementing an asynchronous function as we want the programme to complete each step before moving on.<br/><br/><span class="attribute">const passwordHash = async (password, saltRounds) => {<br/>try {<br/>const salt = await bcrypt.genSalt(saltRounds);<br/>const hash = await bcrypt.hash(password, salt);<br/>return hash;<br/>} catch (err) {<br/>console.log(err);<br/>}<br/>return null;<br/>};</span><br/><br/>In the above code we start off by creating an asynchronous function that accepts 2 arguments, these are the user inputted <span class="attribute">password</span> and then a number defining the number of <span class="attribute">saltRounds</span> we want bcrypt to use. This number will be defined elsewhere.<br/><br/>In the code body, because we are using an asynchronous function we make use of <span class="attribute">try...catch</span> statements to run our logic.<br/><br/>We create a new <span class="attribute">salt</span> by using <span class="attribute">await</span> and then invoking an inbuilt bcrypt method of <span class="attribute">.genSalt()</span>. Notice how we insert the <span class="attribute">saltRounds</span> argument as the parameter for this method.<br/><br/>On the next line we generate the <span class="attribute">hash</span> by again using <span class="attribute">await</span> and then using another in built bcrypt method. The <span class="attribute">.hash()</span> method takes 2 arguments, the users <span class="attribute">password</span> and then the <span class="attribute">salt</span> that we generated on the line above.<br/><br/>If all is successful we then return the <span class="attribute">hash</span><br/><br/>If there was an error then our <span class="attribute">catch</span> will receive the error object and within the code body of this statement we log this to the console so that we can inspect what's gone wrong. Outside of this statement we return <span class="attribute">null</span> in the event of an error.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.compare()</span></td>
                            <td>Verifying a password</td>
                            <td>Bcrypt has an inbuilt function called <span class="attribute">.compare()</span> that we can use to verify passwords.<br/>The <span class="attribute">.compare()</span> function takes in 2 arguments. The first is the user input (password), the second argument is a previously hashed value, in most cases this will be the user's password they created on sign up that has been hashed and stored in our database.<br/><br/>The function is quite clever in that it will be able to compare a password that has been hashed including a salt. The function will be able to determine what salt was used in the original hashing and then use this in the comparison.<br/><br/>Below we have an example of an asynchronous function that compares 2 passwords;<br/><br/><span class="attribute">const comparePasswords = async (password, hash) => {<br/>try {<br/>const matchFound = await bcrypt.compare(password, hash);<br/>return matchFound;<br/>} catch(err) {<br/>console.log(err);<br/>}<br/>return false;<br/>};</span><br/><br/>In the example shown above we have an asynchronous function that takes in 2 arguments, these are the user input of <span class="attribute">password</span> and then a retrieved password value from our database that has already been hashed (<span class="attribute">hash</span>).<br/><br/>We then have a simple <span class="attribute">try...catch</span> statement that handles our asynchronous logic.<br/>In the <span class="attribute">try</span> section we create a new <span class="attribute">matchFound</span> variable that we <span class="attribute">await</span> and then invoke bcrypt's <span class="attribute">.compare()</span> function, taking in both <span class="attribute">password</span> and <span class="attribute">hash</span> values as arguments.<br/>This function will result in a value of either <span class="attribute">true</span> or <span class="attribute">false</span> dependent on whether the user input matches the hashed value we have stored in our database or not.<br/><br/>We then return this value.<br/><br/>Our <span class="attribute">catch</span> element receives any errors that might occur and log's them so we can inspect. Outside of the body we return a <span class="attribute">false</span> value to end the code in the event of any errors.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.compare()</span></td>
                            <td>How <span class="attribute">.compare()</span> retrieves the original salt</td>
                            <td>The salt is stored inside the hash itself and these values are extracted by <span class="attribute">.compare()</span> to then feed back into the comparison function.<br/><br/>So for example lets say we hash a password in the following way;<br/><br/><span class="attribute">const hash = await bcrypt.hash('myPassword123', 10);</span><br/><br/>The resulting hash will look like the following;<br/><br/><span class="code">$2b$10$</span><span class="attribute">QdOZ3Yjgf8GKN82VZP2KNOsJX8g0opFmKPRL1hzI1hGUGcdgZ6s6C</span><br/><br/>This string contains all of the necessary data bcrypt needs to check in the <span class="attribute">.compare()</span> function.<br/><br/><span class="attribute">$2b$10$[salt][hash]</span><br/><br/>So;<br/><br/><span class="attribute">$2b$</span> = bcrypt version<br/><span class="attribute">10$</span> = cost factor (number of salt rounds)<br/><span class="attribute">[22 character salt] [31 character hash]</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Using bcrypt in a CRUD app</td>
                            <td>The principles of how bcrypt works as explained above can be applied to a CRUD app to provide security for our users.<br/>Below there are some examples of this being used in new user registration and login routes.<br/><br/>In the below examples, there are some custom helper functions that may differ, however the purpose of the code below is to demonstrate coding patterns with relation to the asynchronous nature of bcrypt and how we can provide password security for our users.<br/><br/><span class="attribute">router.post("/register", async (req, res) => {<br/>const { email, password } = req.body;<br/>const id = { id: helper.getNewId(users) };<br/><br/>try {<br/>const user = await helper.findUser(users, email);<br/><br/>if (user) {<br/>console.log("User already exists!");<br/>return res.redirect("login");<br/>}<br/></span><span class="code">// Generate salt</span><span class="attribute"><br/>const salt = await bcrypt.genSalt(10);<br/></span><span class="code">// Hash password</span><span class="attribute"><br/>const hashedPassword = await bcrypt.hash(password, salt);<br/>const newUser = {<br/>...id,<br/>email,<br/>password: hashedPassword,<br/>};<br/><br/>await users.push(newUser);<br/>await helper.writeJSONFile(filename, users);<br/><br/>res.redirect("login");<br/>} catch (err) {<br/>res.status(500).json({ message: err.message });<br/>}<br/>});</span><br/><br/>In the above route we demonstrate how a new registration route might look when using bcrypt to has the new password and then store it in our database.<br/>Notice how we generate the salt, use that to hash the user inputted password and then store the <span class="attribute">hashedPassword</span> variable in the user object rather than the plaintext user input.<br/><br/>The example demonstrates how we would implement bcrypt in a login route.<br/><br/><span class="attribute">router.post("/login", async (req, res) => {<br/>const { password, email } = req.body;<br/><br/>try {<br/>const user = await helper.findUser(users, email);<br/><br/>if (!user) {<br/>console.log("User does not exist!");<br/>return res.redirect("login");<br/>}<br/><br/></span><span class="code">// Compare passwords:</span><span class="attribute"><br/>const matchedPassword = await bcrypt.compare(password, user.password);<br/><br/>if (!matchedPassword) {<br/>console.log("Passwords did not match!");<br/>return res.redirect("login");<br/>}<br/><br/>res.render("profile", { user });<br/>} catch (err) {<br/>res.status(500).json({ message: err.message });<br/>}<br/>});</span><br/><br/>In the above example notice how we use the <span class="attribute">.compare()</span> function to check the user input against our <span class="attribute">user.password</span> property that have retrieved earlier in the code body.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="oauth">
                <h2>OAuth</h2>
                <p>This section explains the OAuth including concepts around security and general syntax.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>What is OAuth?</td>
                            <td>OAuth is an authorization framework.<br/><br/>It basically allows a server to access authenticated resources from another server without sharing passwords.<br/>This works by allowing applications to authenticate with 3rd party services in exchange for an access token which is passed with a HTTP request to access protected content.<br/><br/>The most familiar versions of this will be when you go to a website and it says 'Sign in with Facebook' or 'Sign in with Google'.<br/>This process is using the 3rd party of Facebook or Google to authenticate the user.<br/><br/>So how does it authenticate?<br/><br/>Lets say a user is accessing our website and they sign in with Facebook. Our website will redirect them to a Facebook sign in page, they will sign into Facebook with their Facebook username and password.<br/>Facebook will authenticate them and then make sure that user is happy with the permissions our website is asking for.<br/><br/>There will be no exchange of passwords. The Facebook password will remain a secret between the user and Facebook.<br/><br/>Once the user agrees to giving the relevant permissions, they will be redirected back to our website and Facebook will provide our website with an access token.<br/>Whenever we might want to access information about the user, like a birth date for example, our website will send a request back to Facebook for this information as well as the access token.<br/><br/>The access token is basically like a key card saying that we have the right credentials to access that information.<br/>Facebook will validate the access token and upon validation will send back the requested information.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>OAuth 2.0 roles</td>
                            <td>OAuth 2.0 is a simplified version of OAuth 1.0, it also introduces 4 specific roles.<br/>These are listed below;<br/><br/><span class="attribute">Resource  Owner</span> The user who authorizes an application to an account.<br/>(The User)<br/><br/><span class="attribute">Resource Server</span> The API server that accepts access tokens and verifies their validity.<br/>(Facebook/Google/etc server)<br/><br/><span class="attribute">Authorization Server</span> The server that issues access tokens.<br/>(Facebook/Google/etc server)<br/><br/><span class="attribute">Client</span> The application that requests the access tokens.<br/>(Our website)</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Flow (or grants)</td>
                            <td>In OAuth a flow (or grant type) is basically the method a client uses to obtain an access token, which in turn is then used to access information from a resource server.<br/><br/>Different flows are used based on different circumstances. For example, is the client able to store information securely or not? The answer to this defines whether a certain type of flow should be used. If the information cannot be secured then the flow should not allow client secrets to be exposed.<br/><br/>There are other considerations, does the client require the input of a user or not?<br/><br/>All of these questions, when answered, will determine the type of flow that should be used when providing access tokens.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Types of Client</td>
                            <td>OAuth defines clients by two differing types, either they are <span class="code">public</span> or <span class="code">confidential</span> and the difference basically comes down to whether they can store credentials securely or not.<br/><br/>If a client cannot store credentials securely then there are only a limited type of flows (or grant types) they will be able to use.<br/>A flow (or grant type) dictates the interactions that go on between servers, some will use the client secret and some will not.<br/><br/><span class="code">Public</span> clients cannot store credentials securely therefore they will only be able to use grant types that do not use the client secret.<br/><br/><span class="code">Confidential</span> clients can store credentials securely and therefore they are open to grants that do use the client secret.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Types of Flow</td>
                            <td>Frontegg.com have a fantastic explanation of the different type of flow which are shown below;<br/><br/><span class="code">Authorization Code Flow</span><br/>Authorization Code Flow exchanges an authorization code for a token. For this exchange to take place, you have to also pass along your apps Client Secret. The secret must be securely stored on the client side. The implicit flow is suitable for applications that access APIs and cannot store sensitive information.<br/><br/>How this OAuth flow works:<br/><br/>
                                <ol>
                                    <li>The user clicks on a login link in the web application.</li>
                                    <li>The user is redirected to an OAuth authorization server, after which an OAuth login prompt is issued.</li>
                                    <li>The user provides credentials according to the enabled login options.</li>
                                    <li>Typically, the user is shown a list of permissions that will be granted to the web application by logging in and granting consent.</li>
                                    <li>The user is redirected to the application, with the authorization server providing a one-time authorization code.</li>
                                    <li>The app receives the users authorization code and forwards it along with the Client ID and Client Secret, to the OAuth authorization server.</li>
                                    <li>The authorization server generates an ID Token, Access Token, and an optional Refresh Token, before providing them them to the app.</li>
                                    <li>The web application can then use the Access Token to gain access to the target API with the users credentials.</li>
                                </ol>
                                <br/>Use Cases: Server side web applications where the source code is not exposed publicly.<br/><br/>
                                <span class="code">Client Credentials Flow</span><br/>The Client Credentials Flow allows applications to pass their Client Secret and Client ID to an authorization server, which authenticates the user, and returns a token. This happens without any user intervention.<br/><br/>How this OAuth flow works:<br/><br/>
                                <ol>
                                    <li>The application authenticates with the OAuth authorization server, passing the Client Secret and Client ID.</li>
                                    <li>The authorization server checks the Client Secret and Client ID and returns an Access Token to the application.</li>
                                    <li>The Access Token allows the application to access the target API with the required user account.</li>
                                </ol>
                                <br/>Use Cases: M2M apps (daemons, back-end services, and CLIs). In these types of apps, the system authenticates and grants permission behind the scenes without involving the user, because the user is often a machine or service role. It doesnt make sense to show a login prompt or use social logins.<br/><br/>
                                <span class="code">Resource Owner Password Flow</span><br/>The Resource Owner Password Flow asks users to submit their credentials via a form. Credentials are transferred to the backend and may be retained for future use, before an Access Token is granted. Its essential that the app is completely trusted. Therefore, this flow is generally not recommended.<br/><br/>How this OAuth flow works:<br/><br/>
                                <ol>
                                    <li>The user clicks a login link in the application and enters credentials into a form managed by the app.</li>
                                    <li>The application stores the credentials, and passes them to the OAuth authorization server.</li>
                                    <li>The authorization server validates credentials and returns the Access Token (and an optional Refresh Token).</li>
                                    <li>The app can now access the target API with the users credentials.</li>
                                </ol>
                                <br/>Use Cases:  Highly-trusted applications, where other flows based on redirects cannot be used.<br/><br/>
                                <span class="code">Implicit Flow with Form Post</span><br/>This flow uses OIDC to implement a web sign-in that functions like WS-Federation and SAML. The web app requests and receives tokens via the front channel, without requiring extra backend calls or secrets. With this process, you dont have to use, maintain, obtain or safeguard secrets in your app.<br/><br/>Use Cases: Apps that don't want to maintain secrets locally.<br/><br/>
                                <span class="code">Hybrid Flow</span><br/>This flow can benefit apps that can securely retain Client Secrets. It lets your app obtain immediate access to an ID token, while enabling ongoing retrieval of additional access and refresh tokens. This is useful for apps that need to immediately gain access to data about the user, but must perform some processing prior to gaining access to protected resources for a long time.<br/><br/>Use Cases: Apps that need immediate access to data about the user, but also need to use this data on an ongoing basis.<br/><br/>
                                <span class="code">Device Authorization Flow</span><br/>This flow makes it possible to authenticate users without asking for their credentials. This provides a better user experience for mobile devices, where it may be more difficult to type credentials. Applications on these devices can transfer their Client ID to the Device Authorization Flow to start the authorization process and obtain a token.<br/><br/>Use Cases: Apps running on input-constrained devices that are online (Things like Smart TV's), enabling seamless authentication via credentials stored on the device.<br/><br/>
                                <span class="code">Authorization Code Flow with PKCE</span><br/>This flow uses a PKCE. A secret known as a Code Verifier is provided by the calling application, which may be verified by the authorization server using a Proof Key. <br/><br/>Use Cases: Apps that need to serve unknown public clients who may introduce additional security issues that are not addressed by the Auth Code Flow.<br/><br/>All the above info can be found on the original website <a href="https://frontegg.com/blog/oauth-flows" target="_blank">here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>How to choose the correct type of Flow?</td>
                            <td>The type of flow needed within your app might be difficult to know straight away.<br/>Frontegg.com produced the following quick questions that can help give pointers as to the direction we might need to take.<br/><br/><span class="code">Is the Client the Resource Owner?</span><br/>The type of authorization flow is determined by the type of client, and whether it is a human or machine. In purely machine authorization, the Client is the same as the Resource Owner, so the end-user doesnt need to provide any additional authorization. In this case, use Client Credentials Flow.<br/><br/><span class="code">Is the Client a Web App Executing on the Server?</span><br/>When the Client is a typical web app executive via a server, you should apply the Authorization Code Flow. It provides an Access Token (and an optional Refresh Token) directly to the Client. This is a safer approach than having the Access Token pass through the users web browser, which may lead to exposure.<br/><br/><span class="code">Is the Client Completely Trusted with User Credentials?</span><br/>If the Client is trusted, the system may generate a Resource Owner Password Credential Grant. In this scenario, the end-user must provide credentials (passwords and usernames), generally via a digital form. The data is then passed on to the backend. It is essential that the Client is completely trusted. <br/><br/>This grant must only be employed when a redirect-based flow (Auth Code Flow) is not viable. For such cases, use the Resource Owner Password Flow.<br/><br/><span class="code">Is the Client a Single-Page Application?</span><br/>A Single-Page Application (SPA) is a browser-based one that employs scripting languages like JavaScript. When the Client is a Single-Page Application, you can use one of two grant optionsthe Implicit Flow with Form Post and the Authorization Code Flow with PKCE.<br/><br/>The preferred option is usually the Authorization Code Flow with PKCE as the client-side Access Token. It is not exposed and can deliver Refresh Tokens.<br/><br/><span class="code">Is the Client a Native Mobile Application?</span><br/>When using native applications, you should probably opt for the PKCE (Proof Code for Code Exchange) Authorization Code Flow.<br/><br/>All the above info can be found on the original website <a href="https://frontegg.com/blog/oauth-flows" target="_blank">here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">oauth2-server</span></td>
                            <td>Installing OAuth2 Server</td>
                            <td>OAuth 2 Server is a library we can install and use to implement the OAuth authentication protocol.<br/>Before we can make use of it we need to install and require it in.<br/>We install it in the usual way;<br/><br/><span class="code">npm i oauth2-server</span><br/><br/>Then we require it in to our server in the usual way;<br/><br/><span class="attribute">const OAuth2Server = require('oauth2-server');</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">OAuth2Server()</span></td>
                            <td>Creating a new instance of OAuth2 Server</td>
                            <td><span class="attribute">OAuth2Server()</span> is an object that we need to configure. First we need to make a new instance of it within our app.<br/><br/><span class="attribute">const oauth =  new OAuth2Server();</span><br/><br/>The <span class="attribute">OAuth2Server</span> object requires a model object which itself contains functions to access, store and validate access tokens. These models will be written separately in another file however within the constructor of the <span class="attribute">OAuth2Server</span> object we need to require the model object in.<br/><br/><span class="attribute">const oauth = new OAuth2Server({<br/>model: require('./model.js'),<br/>});</span><br/><br/>We can supply further additional options in the construction, one option will be to pass tokens inside the URL. The option we need for this is <span class="attribute">allowBearerTokensInQueryString</span> and we need to set it to <span class="attribute">true</span>.<br/><br/><span class="attribute">const oauth = new OAuth2Server({<br/>model: require('./model.js'),<br/>allowBearerTokensInQueryString: true,<br/>});</span><br/><br/>A further option we can configure at this stage is how long the access token is lifetime should be. This is set in seconds, so we can set the token to last for an hour with the follow option;<br/><br/><span class="attribute">const oauth = new OAuth2Server({<br/>model: require('./model.js'),<br/>allowBearerTokensInQueryString: true,<br/>accessTokenLifetime: 60 * 60<br/>});</span><br/><br/>All of this is going to be contained in the top level of our app likely to be the <span class="code">app.js</span> file where we initially require in <span class="attribute">express</span> itself.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">'client_credentials'</span></td>
                            <td>Client Credentials Flow</td>
                            <td>In the example below we will implement a client credentials flow to get an access token for authentication.<br/>This flow is for machine to machine and no user is involved. It is also for when we can securely store the client secret.<br/><br/>When a developer registers a client in an OAuth app 2 separate pieces of information are needed.<br/><br/>Client ID - a public identifier for apps. It is unique across all clients and the authorization server.<br/>Client Secret - A secret key known only to the application and the authorization server.<br/><br/>An example of how to register a client to an application is shown below;<br/>The following code is in a separate file called <span class="code">database.js</span><br/><br/><span class="attribute">module.exports ={<br/>confidentialClients: [{<br/>clientId: 'secretApplication',<br/>clientSecret: 'topSecret',<br/>grants: [<br/>'client_credentials'<br/>]<br/>}],<br/>tokens: []<br/>}</span><br/><br/>OAuth 2.0 has flexibility when it comes to what type of databases to use and the express package of <span class="attribute">oauth2-server</span> allows Postgres, MongoDB and Redis.<br/>In our example we are using an in-memory database that is defined in our file <span class="code">database.js</span>.<br/>We use <span class="attribute">module.exports</span> to create a module to hold our confidential client credentials and access tokens.<br/><br/>We register an application (<span class="attribute">secretApplication</span>) to the list of <span class="attribute">confidentialClients</span> which itself is an array.<br/>Within that array we have an object that holds keys including the <span class="attribute">clientId</span>, which is likely the name of the application, <span class="attribute">clientSecret</span> which is the very important piece of information we need to remain secure and then an array (<span class="attribute">grants</span>) of the grant types we are using.<br/><br/>Finally outside of our <span class="attribute">confidentialClients</span> key we have a <span class="attribute">tokens</span> array.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.getClient()</span></td>
                            <td>Get Client</td>
                            <td>Within the <span class="attribute">OAuth2Server</span> middleware that are some functions that are required to be implemented in the model no matter what authorization flow is to be used.<br/>The <span class="attribute">getClient()</span> function is one of these.<br/><br/>The purpose of this function is to retrieve the Client Id and, if being used in the flow, the Client Secret.<br/><br/>This is a fairly simple function to implement and an example of its implementation and export is shown below;<br/><br/>This would all be written in the <span class="code">model.js</span> file that we refer to when we originally configured the <span class="attribute">OAuth2Server</span> object;<br/><br/><span class="attribute">let database = require('./database.js');<br/><br/>const getClient = (clientId, clientSecret) => {<br/>let confidentialClients = database.confidentialClients.filter((client) => {<br/>return client.clientId === clientId && client.clientSecret === clientSecret<br/>});<br/>return confidentialClients[0];<br/>}<br/><br/>module.exports = {<br/>getClient: getClient<br/>}</span><br/><br/>Lets run through what's happening in this example.<br/>We begin by requiring in our database.<br/><br/>Underneath we have our <span class="attribute">getClient()</span> function which accepts 2 arguments. These are the <span class="attribute">clientId</span> and the <span class="attribute">clientSecret</span>.<br/>Within the code body we have 2 elements. The first element is a new variable and the variable is a search of our database using the array filtering method. We are asking the filter to iterate over the array of confidential clients.<br/>We know this is a key in our database that has an array as a property (which is why we use the filter method) and we want it to return elements that match BOTH the <span class="attribute">clientId</span> AND the <span class="attribute">clientSecret</span>.<br/><br/>These should be stored in the variable.<br/>Now if we were using a different flow we might not need the logic to match the <span class="attribute">clientSecret</span>. Its also worth nothing that this logic might differ if we are using a different database that stores things in another way other than an array. However the principle here is that were trying to find a match to the supplied <span class="attribute">clientId</span> and <span class="attribute">clientSecret</span>.<br/><br/>The second element of the code body is that we simply return the variable.<br/>Because the filter method returns an array we need to specify that we want the first element of the array to be returned which is why we include the <span class="attribute">[0]</span>.<br/><br/>Underneath the <span class="attribute">getClient()</span> function we export the function to be used elsewhere in our app.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.saveToken()</span></td>
                            <td>Save Token</td>
                            <td><span class="attribute">.saveToken()</span> is another function that must be implemented within the <span class="attribute">OAuth2Server</span> middleware.<br/><br/>The purpose of this function is to store the access token as an object to our database whenever one is obtained.<br/><br/>Much like the <span class="attribute">.getClient()</span> function this is also a fairly simple function to implement.<br/>An example of correct syntax is shown below;<br/><br/>This would also be contained in the <span class="code">model.js</span> file that we used to create the <span class="attribute">.getClient()</span> function and export.<br/><br/><span class="attribute">const saveToken = (token, client, user) => {<br/>token.client = {<br/>id: client.clientId<br/>}<br/>token.user {<br/>username: user.username<br/>}<br/>database.tokens.push(token):<br/>return token;<br/>}</span><br/><br/>Lets explain the code.<br/>Here we have a named function  that accepts 3 arguments. These are <span class="attribute">token</span>, <span class="attribute">client</span> and <span class="attribute">user</span>.<br/>The code itself is fairly simple, we are simply creating a token object and assigning specific properties to the key values we will need for other parts of our code.<br/>We start off by creating a <span class="attribute">user</span> key and we assign it an object that contains the key-value pairing of <span class="attribute">id</span> which we assign to be the received <span class="attribute">clientId</span> from the client object.<br/><br/>Underneath this we then create another key, this time its for <span class="attribute">user</span> and we assign the property of that to be an object. The object itself is another key-value pairing of <span class="attribute">username</span> which we assign to be the <span class="attribute">username</span> we received from the <span class="attribute">user</span> object.<br/><br/>Finally we know that our database has a <span class="attribute">tokens</span> key which is an array. So we use the <span class="attribute">.push()</span> method to add the new token object we have created to that array.<br/>We then return the token object to exit the function and send the information back.<br/><br/>Much like the <span class="attribute">.getClient()</span> function, we will need to use this function elsewhere in our app.<br/><br/><span class="attribute">module.exports = {<br/>getClient: getClient,<br/>saveToken: saveToken<br/>}</span><br/><br/>Because we're in the same file we can simply add it to the existing <span class="attribute">module.exports</span> object we already have.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.getUserFromClient()</span></td>
                            <td>Get User From Client</td>
                            <td><span class="attribute">.getUserFromClient()</span> is yet another function that must be implemented within the <span class="attribute">OAuth2Server</span> middleware.<br/><br/>The purpose of this function is to retrieve the user associated with the specified client.<br/>In our example we are not getting a user but this function still needs to be implemented otherwise an error will be thrown.<br/><br/>Because we don't use this but it is required all we need to do here is create the function and return an empty object.<br/>Obviously in another flow the code body would include all of the necessary retrieval logic.<br/><br/>An example of correct syntax is shown below;<br/><br/>This would also be contained in the <span class="code">model.js</span> file that we used to create the <span class="attribute">.getClient()</span> and <span class="attribute">.saveToken()</span> functions.<br/><br/><span class="attribute">const getUserFromClient = (client) => {<br/>return {};<br/>}</span><br/><br/>The function itself accepts 1 argument. The <span class="attribute">client</span> object.<br/>The code in this instance does nothing with that information and just returns and empty object as its more of a box ticking exercise for this particular flow.<br/><br/>As with the other functions, even though we don't actually use this function, we will need to export it for the functionality of our app.<br/><br/><span class="attribute">module.exports = {<br/>getClient: getClient,<br/>saveToken: saveToken,<br/>getUserFromClient: getUserFromClient<br/>}</span><br/><br/>Because we're in the same file we can simply add it to the existing <span class="attribute">module.exports</span> object we already have.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.obtainToken()</span></td>
                            <td>Obtain Token handler function</td>
                            <td>The <span class="attribute">obtainToken</span> function does what you would expect. It is a function we will need to create that has the purpose of obtaining access tokens whenever a URL is requested in our app.<br/><br/>We will need to write it in the top level of our app (<span class="code">app.js</span>).<br/><br/>An example of syntax is shown below;<br/><br/><span class="attribute">const obtainToken = (req, res) => {<br/>let request = new OAuth2Server.Request(req);<br/>let response = new OAuth2Server.Response(res);<br/><br?>return oauth.token(request, response)<br/>.then((token) => {<br/>res.json(token);<br/>})<br/>.catch((err) => {<br/>res.json(err);<br/>});<br/>}</span><br/><br/>The function itself takes in 2 arguments. These are the request object (<span class="attribute">req</span>) and the response object (<span class="attribute">res</span>) from a HTTP request.<br/><br/>In the function's code body we start off by creating a request variable that we assign as being a new instance of our <span class="attribute">OAuth2Server</span> with an attached <span class="attribute">.Request()</span> method taking the request object (<span class="attribute">req</span>) as its argument.<br/>We do this because the <span class="attribute">OAuth2Server</span> library requires its own request objects and not express ones. So essentially this variable is taking the express request object and basically converting it for use within <span class="attribute">OAuth2Server</span>.<br/><br/>Underneath this we do exactly the same thing with the response object (<span class="attribute">res</span>).<br/><br/>The next piece of code is where we generate or validate a token.<br/>We use the <span class="attribute">.token()</span> method on our <span class="attribute">ouath</span> constant (which is an instance of <span class="attribute">OAuth2Server</span> that we created at the very start), taking in both the newly formatted <span class="attribute">request</span> and <span class="attribute">response</span> objects as arguments.<br/>This processes the request to issue an access token (and refresh token dependent on the grant being used). It then validates the client credentials, grant types, scopes etc. After this is calls the model methods we set up (<span class="attribute">getClient()</span>, <span class="attribute">saveToken()</span> & <span class="attribute">getUserFromClient()</span>).<br/>Finally it validates a client in our example but if we're using a different flow it will either authenticate a user or exchange and auth code for a token.<br/><br/>After this we have a promise chain starting with a <span class="attribute">.then</span> method that handles the result.<br/>If everything is successful we send the token as a response formatted in json.<br/>It might look something like the following;<br/><br/><span class="code">{<br/>"accessToken": "abc123...",<br/>"accessTokenExpiresAt": "2025-06-27T12:34:56.789Z",<br/>"refreshToken": "def456...",<br/>"client": { ... },<br/>"user": { ... }<br/>}</span><br/><br/>There is a <span class="attribute">.catch</span> method after this in the event of any errors that might be encountered.<br/>Within this we send back any errors that might be encountered for inspection. We also format these into json.<br/>An error might look like the below;<br/><br/><span class="code">{<br/>"name": "invalid_grant",<br/>"message": "Invalid grant: user credentials are invalid"<br/>}</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.all()</span></td>
                            <td>Creating a route to generate the token</td>
                            <td>To make use of the <span class="attribute">.obtainToken()</span> function we can define a new endpoint within our <span class="code">app.js</span> file.<br/><br/>The <span class="attribute">.all()</span> handles all types of HTTP requests like GET & POST etc.. we will be using POST requests so we could also use the <span class="attribute">.post()</span> method.<br/><br/><span class="attribute">app.all('/auth', obtainToken);</span><br/><br/>So in the above endpoint we have the path as something unique that will only be used for obtaining access tokens, which is also why we can use the <span class="attribute">.all()</span> method.<br/>We are using the function to provide authorization so for the purposes of this example we've used <span class="attribute">'/auth'</span> as the path.<br/><br/>Following this we declare that the <span class="attribute">obtainToken</span> function should be invoked on this endpoint.<br/>The rest of the logic we have already set up will deal with everything else as this is just the gateway to invoke all of that other code.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.getAccessToken()</span></td>
                            <td>Validating tokens to restrict access</td>
                            <td>In addition to creating tokens, now we need to create a function that will check the validity of tokens in order to provide the verification process we're aiming for.<br/><br/>Inside our <span class="code">model.js</span> file we can create the <span class="attribute">getAccessToken()</span> function to retrieve existing tokens that were previously saved when the <span class="attribute">saveToken()</span> function is invoked.<br/>This function is required when <span class="attribute">.authenticate()</span> is used on a <span class="attribute">OAuth2Server</span> instance.<br/><br/>The function's purpose is to check a supplied token against our database and determine whether it is valid or not.<br/>Example syntax is shown below;<br/><br/><span class="attribute">const getAccessToken = (accessToken) => {<br/>let tokens = database.tokens.filter((savedToken) => {<br/>return savedToken.accessToken === accessToken;<br/>})<br/>return tokens[0];<br/>}</span><br/><br/>In the code above our function takes in the supplied <span class="attribute">accessToken</span> as an argument.<br/>The logic within the code body should be written to simply provide the check against our database of tokens for validity.<br/>In this example our database is an array so we use the <span class="attribute">.filter()</span> method to iterate through the tokens key of our database.<br/>It checks the supplied <span class="attribute">accessToken</span> against the array and stores them in the variable.<br/>The <span class="attribute">.filter()</span> method returns an array so in this example we return the variable specifying the 0 indexed item in the array (<span class="attribute">[0]</span>).<br/><br/>We need to export this function so that we have access to it at other points in our app so we can simply add it to the list of functions we are already exporting;<br/><br/><span class="attribute">module.exports = {<br/>getClient: getClient,<br/>saveTokens: saveTokens,<br/>getUserFromClient: getUserFromClient,<br/>getAccessToken: getAccessToken<br/>}</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">authenticateRequest</span></td>
                            <td>Adding the middleware to our Routes</td>
                            <td>With all of the other logic and functions now in place we need to create a middleware function that will handle the authentication process for tokens within our app.<br/><br/>The middleware is quite straight forward, it sits in the top level of our app (<span class="code">app.js</span>) and as with other checking middleware it is placed before the callback of the specific routes it is to protect.<br/><br/>Example syntax is shown below;<br/><br/><span class="attribute">const authenticateRequest = (req, res, next) => {<br/><br/>let request = new OAuth2Server.Request(req);<br/>let response = new OAuth2Server.Response(res);<br/><br/>return oauth.authenticate(request, response)<br/>.then(() => {<br/>next();<br/>})<br/>.catch((err) => {<br/>res.send(err);<br/>});<br/>}</span><br/><br/>In the code above we follow the middleware syntax patterns, we name the function (<span class="attribute">authenticateRequest</span>) and provide it with the 3 standard arguments of the request object (<span class="attribute">req</span>), the response object (<span class="attribute">res</span>) and the next (<span class="attribute">next</span>) function.<br/><br/>The first 2 lines of the code body are doing the same as the <span class="attribute">obtainToken</span> function.<br/>We create respective variables for the request and response objects where we use the <span class="attribute">.Request</span> and <span class="attribute">.Response</span> methods contained within the <span class="attribute">OAuth2Server</span> library to essentially convert the request and response objects to compatible versions of themselves for use within <span class="attribute">OAuth2Server</span>.<br/><br/>Underneath this we return our <span class="attribute">ouath</span> object and invoke the <span class="attribute">.authenticate</span> method, passing in the newly formatted <span class="attribute">request</span> and <span class="attribute">response</span> objects.<br/>This method is a simple checking method.<br/>It checks for an access token (usually in the <span class="code">Authorization: Bearer &lt;token&gt;</span> header) and does the following checks;<br/>1 - Validate the token's integrity.<br/>2 - Check if it's expired.<br/>3 - Verifies scopes or client permissions (optional)<br/>4 - If valid it then attaches the token and user to the request object (typically under <span class="attribute">req.user</span> or <span class="attribute">req.token.user</span>)<br/><br/>Following this we have a promise chain with a <span class="attribute">.then()</span> method that simply passes control onto the next middleware if the token is valid.<br/><br/>If the token is not valid our <span class="attribute">.catch()</span> method will send the error as a response.<br/>It will likely look similar to the below;<br/><br/><span class="code">{<br/>"name": "invalid_token",<br/>"message": "Access token is invalid: expired or malformed."<br/>}</span><br/><br/>Instead of sending the error we could also include a message indicating the user has attempted to access a resource they are not authenticated to access.<br/><br/>Below is a typical example of how this middleware would be inserted into a route to provide the protection before progression onto the rest of the route.<br/><br/><span class="attribute">app.get('/api/secret-data', authenticateRequest, (req, res) => {<br/></span><span class="code">//GET request logic for the app</span><span class="attribute"><br/>});</span><br/><br/>As you can see its a familiar application to other checking middleware.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Testing endpoints with HTTP</td>
                            <td>With everything now implemented we can test the endpoints by sending HTTP requests.<br/><br/>We can send a request and expect to get responses in the form of access tokens which will provide us with the information we can then use to try and access the protected routes.<br/><br/>We can make a POST request using the command line to the <span class="attribute">/auth</span> route to obtain an access token.<br/>The request would look like the below;<br/><br/><span class="code">curl --request POST \<br/>--url http://localhost:4001/auth \<br/>--header 'authorization: Basic Y29kZWNhZGVteTpjb2RlY0BkZW15' \<br/>--header 'content-type: application/x-www-form-urlencoded' \<br/>--data grant_type=client_credentials</span><br/><br/>In the HTTP header we set <span class="code">Authorization</span> to <span class="code">Basic</span> and the base64 encoded Client ID and Client Secret.<br/>In the post request data we provide <span class="code">grant_type=client_credentials</span>.<br/>The server will respond with an access token that looks like the following;<br/><br/><span class="code">{<br/>"accessToken":" "</span><span class="attribute">&lt;access token&gt;</span><span class="code">",<br/>"accessTokenExpiresAt":"2025-06-27T01:02:37.272Z",<br/>"client": {<br/>"id": "someUser",<br/>"user":{}<br/>}<br/>}</span><br/><br/>Where <span class="attribute">&lt;access token&gt;</span> will be the actual token.<br/>We can then follow up with a request to the protect route, including the access token.<br/>The command line request would look something like the following;<br/><br/><span class="code">curl --request GET \<br/>--url http://localhost:4001/secret \<br/>--header 'authorization: Bearer </span><span class="attribute">&lt;access token&gt;</span><span class="code">'</span><br/><br/>Provided no error message has been returned our OAuth 2.0 setup has successfully authenticated us.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="tdd">
                <h2>Test Driven Development</h2>
                <p>This section explains the concepts around Test Driven Development (TDD), including notes on syntax and implementation.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Brief Overview of Headless Testing</td>
                            <td>What is Headless testing?<br/>Headless testing is basically the testing of websites and apps without the GUI of a browser.<br/>It's quicker to execute because the time needed to process the GUI is no longer included.<br/><br/>Within the test you can still generate screenshots and PDFs of websites, scrape content from websites, automate form submission, and simulate keyboard input.<br/><br/><a href="https://expressjs.com/en/5x/api.html" target="_blank">LogRocket.com has a brief overview of various headless testing methods here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Mocha</td>
                            <td>What is Mocha?<br/>Mocha is the test running tool for Node.js and is a Javascript testing framework.<br/>It brings additional tools for testing.<br/><br/>To install Mocha into the project you can type the following into the root directory of the project;<br/><br/><span class="code">npm install --save-dev mocha</span><br/><br/>The <span class="attribute">--save-dev</span> attribute ensures that these are installed for development only and not production.<br/><br/>Refer back to <a href="https://ther4tm.github.io/Coding-Cheat-Sheet/javascriptcheatsheet#testing" target="_blank">notes on mocha for a refresher</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Chai</td>
                            <td>What is Chai?<br/>Chai is an additional assertion library for Node.js and browsers that can be used with any Javascript testing framework.<br/><br/>To install Chai into the project you can type the following into the root directory of the project;<br/><br/><span class="code">npm install --save-dev chai</span><br/><br/>The <span class="attribute">--save-dev</span> attribute ensures that these are installed for development only and not production.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">assert.include()</span></td>
                            <td>Chai features</td>
                            <td>Node's built in assertion library allows for many ways to test such as the following;<br/><br/><span class="attribute">assert.ok(foo.includes(bar));</span><br/><br/>To improve the readability and flow of tests the Chai extension library has some similar functions that allow us to rewrite some of the code.<br/>For example the above code can be rewritten using Chai like the following;<br/><br/><span class="attribute">assert.include(foo, bar);</span><br/><br/>We can also use the same method to check that text includes certain values such as;<br/><br/><span class="attribute">assert.include('foobar', 'foo')<br/></span><span class="code">//Evaluates to true</span><br/><br/>There are plenty of other methods within Chai that enable the writing of more expressive tests, allowing for easier to understand code.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>WebdriverI/O</td>
                            <td>What is WebdriverI/O?<br/>WebdriverI/O provides methods that allows us to programmatically interact with the user-facing elements of our app in a headless browser.<br/><br/>To install WebdriverI/O into the project you can type the following into the root directory of the project;<br/><br/><span class="code">npm i webdriverio</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">browser.url()</span></td>
                            <td>Feature Test I : Navigating without a browser</td>
                            <td>Feature tests can simulate user navigation. We can test to see if certain aspects of our app are behaving as expected using this.<br/><br/>So for example if we wish to create an app that had a messaging aspect to it and we want to test that the message area was blank upon a user navigating there at the beginning of a session, we could test for that.<br/><br/><span class="attribute">describe('User visits root', () => {<br/>describe('without existing messages', () => {<br/>it('starts blank', ()  => {<br/>browser.url('/');<br/>})<br/>});<br/>});</span><br/><br/>In the above code we have a basic mocha test block with some nested <span class="attribute">describe()</span> methods and an <span class="attribute">it()</span> method that form the basis of the test.<br/>Within the block we make use of the global <span class="attribute">browser</span> variable that is provided by WebdriverI/O.<br/>The browser variable gives us access to the headless browser we are running in the background. With this we can simulate interactions with the website by calling different methods on the global <span class="attribute">browser</span> variable within the test.<br/>In the code above we do this by calling the <span class="attribute">.url()</span> method on it which simulates the user navigating to whatever url is passed into the method as its argument.<br/>In the test above we enter <span class="attribute">'/'</span> as the argument which would navigate to the root file of our project which would be something like <span class="code">index.html</span>, alternatively we could enter something like <span class="attribute">browser.url('https://www.google.com;)</span> and it would simulate navigation to google.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">assert.equal()</span> & <span class="attribute">browser.getText()</span></td>
                            <td>Feature Test II : Testing</td>
                            <td>The next part of our test is to include assertions from Chai to test that the behaviour we receive is the behaviour we are expecting.<br/><br/>We need to require in chai in the usual way;<br/><br/><span class="attribute">const { assert } = require('chai');</span><br/><br/> In the above we bring in the <span class="attribute">assert</span> method using destructured syntax.<br/><br/>Within our code body we can add in the behaviour test now using the assertion method from chai and a couple of helper methods from WebdriverI/O.<br/><br/><span class="attribute">describe('User visits root', () => {<br/>describe('without existing messages', () => {<br/>it('starts blank', () => {<br/>browser.url('/');<br/><br/>assert.equal(browser.getText('#messages'), '');<br/>});<br/>});<br/>});</span><br/><br/>In the above code we want to test that the messages section of the app is empty.<br/>We start off by using the <span class="attribute">assert</span> method and call the <span class="attribute">equal</span>  method from chai on it to ensure that whatever argument we put into this assertion is equal to the behaviour we expect. This way, if the app does what we put in as the argument, the test will pass, if not, then it will fail and we need to debug.<br/>This method expects 2 arguments, one to compare to the other to see if they're equal. It can have a 3rd argument which is optional but this is to provide a custom error message.<br/><br/>The next part of the code is the first argument.<br/>We use the <span class="attribute">browser</span> variable again to access parts of the headless browser. We then append the <span class="attribute">getText()</span> method from WebdriverI/O. This method simply fetches whatever text from the argument inserted into the parentheses.<br/>Lets say our messages item on our website is within a div that has the ID of 'messages'. We add the identifier for that as the argument (<span class="attribute">#messages</span>) and this method will then retrieve whatever text appears in that div.<br/><br/>The second argument is what we want to compare the first argument to. Our test is checking to see if the div is empty so our second argument is an empty string.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">browser.SetValue()</span> & <span class="attribute">browser.click()</span></td>
                            <td>Feature Test III : Mimicking user input</td>
                            <td>The tests we've explored so far are fairly simple, but we want to test user interactions.<br/>We can use additional methods from WebdriverI/O to simulate more complex user interactions.<br/><br/>Below is an example test showing how we can simulate a user filling in some text boxes and then clicking submit on a form;<br/><br/><span class="attribute">  describe('posting a message', () => {<br/>it('saves the message with the author information', () => {<br/>const message ='blah blah blah blah';<br/>const author = 'username';<br/><br/>browser.url('/');<br/>browser.setValue('input[id=author]', author);<br/>browser.setValue('textarea[id=message]', message);<br/>browser.click('input[type=submit]');<br/>});<br/>});</span><br/><br/>In the above test we start by assigning some user input into 2 different variables. These will be our simulated user typed input.<br/><br/>Underneath we have our actual simulation.<br/>We start off by navigating to the web page in the same way we did with the previous test (<span class="attribute">browser.url('/');</span>).<br/><br/>We then use a new method (<span class="attribute">.setValue()</span>). This method takes 2 arguments.<br/>The first is the CSS selector that references an HTML element and the second argument is the value we wish to assign to that element.<br/>So in our simulation we select an input box with the ID of 'author'.<br/>The second argument is what we want the simulator to set as the value, so here we use our variable to set the input to read 'username'.<br/><br/>We do the same thing again underneath this for the textarea box for the longer message.<br/><br/>Finally we use another method to simulate the user clicking the submit button by appending the <span class="attribute">.click()</span> method to the <span class="attribute">browser</span> variable.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Feature Test IV : Verifying input has worked</td>
                            <td>The final portion of the test after mimicking user input is to verify that the process has worked as we expected.<br/>To do this we run an assertion from chai on the element that we expect our results to be in and compare our predefined variables against the result.<br/>This will let us know if the code for our website is performing the desired functions it should be performing.<br/><br/><span class="attribute">  describe('posting a message', () => {<br/>it('saves the message with the author information', () => {<br/><br/>const message ='blah blah blah blah';<br/>const author = 'username';<br/><br/>browser.url('/');<br/>browser.setValue('input[id=author]', author);<br/>browser.setValue('textarea[id=message]', message);<br/>browser.click('input[type=submit]');<br/><br/>assert.include(browser.getText('#messages'), author);<br/>assert.include(browser.getText('#messages'), message);<br/>});<br/>});</span><br/><br/>So in the above code we use 2 different assertions to test if the div that our messages should turn up in contains the expected text.<br/>We already have the expected text contained in the variables we wrote to perform the test so we can just reuse those within the assertion.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>For additional tags and examples see the <a href="https://expressjs.com/en/5x/api.html" target="_blank">Express.js Website</a> for more info.</p>
        </div>
    </body>
    <footer>

    </footer>
</html>