<!DOCTYPE html>
<html>
    <head>
        <title>React Cheat Sheet</title>
        <link href="./resources/css/index.css" type="text/css" rel="stylesheet">
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link rel="preconnect" href="https://fonts.googleapis.com">
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
    </head>
    <body>
        <header>
            <nav>
                <ul>
                    <li><a href="./htmlcheatsheet.html">HTML</a></li>
                    <li><a href="./csscheatsheet.html">CSS</a></li>
                    <li><a href="./commandlinecheatsheet.html">Command Line</a></li>
                    <li><a href="./javascriptcheatsheet.html">JavaScript</a></li>
                    <li><a href="./reactcheatsheet.html">React</a></li>
                    <li><a href="./markdowncheatsheet.html">Markdown</a></li>
                    <li><a href="./styleguide.html">Style Guide</a></li>
                </ul>
            </nav>
        </header>
        <div class="content">
            <h1>React Cheat Sheet</h1>
            <p>Below is a brief list of fundamental React tags/expressions and syntax including a brief description of what they do and any notes on correct syntax.</p>
            <div class="container" id="jsx">
                <h2>JSX</h2>
                <p>This section describes some fundamental properties of JSX.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td></td>
                            <td>Intro</td>
                            <td>JSX is a syntax extension for Javascript. It was written to be used with React. JSX code looks a lot like HTML.<br/>An important point to note is that JSX is not valid Javascript and web browsers cannot read it, it needs to be compiled before it reaches a web browser.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">const header = </span><span class="code">&lt;h1&gt;title&lt;/h1&gt;</span><span class="attribute">;</span></td>
                            <td>General JSX Syntax</td>
                            <td>JSX elements can be saved to variables.<br/>An example is shown below;<br/><br/><span class="attribute">const header = </span><span class="code">&lt;h1&gt;title&lt;/h1&gt;</span><span class="attribute">;</span><br/><br/>They can also be saved to objects.<br/>An example is shown below;<br/><br/><span class="attribute">const myTeam = {<br/>center: </span><span class="code">&lt;li&gt;Benzo Walli&lt;/li&gt;</span><span class="attribute">,<br/>powerForward: </span><span class="code">&lt;li&gt;Rasha Loa&lt;/li&gt;</span><span class="attribute">,<br/>smallForward: </span><span class="code">&lt;li&gt;Tayshaun Dasmoto&lt;/li&gt;</span><span class="attribute">,<br/>shootingGuard: </span><span class="code">&lt;li&gt;Colmar Cumberbatch&lt;/li&gt;</span><span class="attribute">,<br/>pointGuard: </span><span class="code">&lt;li&gt;Femi Billon&lt;/li&gt;</span><span class="attribute"><br/>};</span><br/><br/>Notice how the syntax looks like a hybrid of Javascript and HTML.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">const p1 = </span><span class="code">&lt;p id='paragraph'&gt;text&lt;/p&gt;</span><span class="attribute">;</span></td>
                            <td>JSX Attributes</td>
                            <td>JSX elements can also contain attributes much in the same way they are used in HTML.<br/>An example is shown below;<br/><br/><span class="attribute">const link = </span><span class="code">&lt;a href='www.google.com'&gt;Google&lt;/a&gt;</span><span class="attribute">;</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">const nav = (</span><br/><span class="code">&lt;div&gt;<br/>&lt;p&gt;text&lt;/p&gt;<br/>&lt;/div&gt;</span><br/><span class="attribute">);</span></td>
                            <td>Nested Elements in JSX</td>
                            <td>JSX elements can be nested much in the same that HTML is written.<br/>An example of this is shown below;<br/><br/><span class="attribute">const clickHeader = </span><span class="code">&lt;a href='www.google.com'&gt;&lt;h1&gt;Click Me!&lt;/h1&gt;&lt;/a&gt;</span><span class="attribute">;</span><br/><br/>An important point to note is that if a JSX expression takes up more than one line then it must be wrapped in parentheses.<br/>An example is shown below;<br/><br/><span class="attribute">const nav = (</span><br/><span class="code">&lt;div&gt;<br/>&lt;ul&gt;<br/>&lt;li&gt;item 01&lt;/li&gt;<br/>&lt;li&gt;item 02&lt;/li&gt;<br/>&lt;li&gt;item 03&lt;/li&gt;<br/>&lt;/ul&gt;<br/>&lt;/div&gt;</span><br/><span class="attribute">);</span><br/><br/>This way we can write our JSX in the same we would with HTML to give a visual representation of hierarchy.<br/><br/>Multi-line JSX items must also be wrapped in a single outer layer.<br/>Notice in the above example we have a containing <span class="code">&lt;div&gt;</span> element. This provides the single outer layer.<br/>An example of <strong>INCORRECT</strong> syntax using multiple outer layers is shown below;<br/><br/><span class="attribute">const nav = (</span><br/><span class="code">&lt;p&gt;item 01&lt;/p&gt;<br/>&lt;p&gt;item 02&lt;/p&gt;<br/>&lt;p&gt;item 03&lt;/p&gt;</span><br/><span class="attribute">);</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.render()</span></td>
                            <td>Rendering JSX</td>
                            <td>React as a language relies on 2 things in order to render elements to the screen correctly: What to render and where to place it.<br/>An example of syntax to render a simple header is shown below;<br/><br/><span class="attribute">const container = document.getElementById('container');<br/>const root = createRoot(container);<br/>root.render(</span><span class="code">&lt;h1&gt;Hello world&lt;/h1&gt;</span><span class="attribute">);</span><br/><br/>In the above code we have 2 variables and a function call.<br/>The first variable <span class="attribute">container</span> is a standard Javascript selection using the DOM. It is selecting the container element by its ID.<br/>This forms part of the 'where' that is required by React to place something.<br/>The second variable <span class="attribute">root</span> is an enabler for the upcoming function call. Note that we are using the <span class="attribute">createRoot()</span> method passing in <span class="attribute">container</span> as the argument.<br/>On the final line of the code snippet we call the <span class="attribute">.render()</span> method on the <span class="attribute">root</span> variable. This is telling React that we want to render something at the position of <span class="attribute">root</span>, which we have set up to be <span class="attribute">container</span>.<br/>Contained with the parentheses of the <span class="attribute">.render()</span> method is the content we want to render at this position which as you can see is a simple header element with the text 'Hello world'.</td>
                        </tr>
                        <tr>
                            <td><span class="code">className="text"</span></td>
                            <td>Classes in JSX</td>
                            <td>Classes can be used in the same way within JSX as they are in HTML however there is a slight difference in the syntax.<br/><span class="attribute">class</span> is a reserved word in Javascript so instead we use <span class="code">className</span>. It works in just the same way as it would in HTML but in order to avoid conflict between the languages it is refactored within JSX to <span class="code">className</span>.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const myDiv = </span><span class="code">&lt;div className="text"&gt;text&lt;/div&gt;</span><span class="attribute">;</span><br/><br/>Notice how we use it in the exact same way as we would do within HTML.</td>
                        </tr>
                        <tr>
                            <td><span class="code">&lt;br/&gt;</span></td>
                            <td>Self closing tags in JSX</td>
                            <td>Self closing tags in JSX are not optional.<br/>The forward slash after tags like <span class="code">&lt;br/&gt;</span> and <span class="code">&lt;img src="file_path.jpg" /&gt;</span> are required otherwise an error will be thrown.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">{  }</span></td>
                            <td>Javascript in JSX</td>
                            <td>When writing JSX, any text placed between JSX (HTML) tags will be treated as a JSX element.<br/>We can however insert Javascript elements between these tags using the curly braces <span class="attribute">{ }</span>.<br/>Doing this will tell our code that whatever is in between the curly braces should be treated in the same way as Javascript.<br/>For example, the code shown below will render a <span class="code">&lt;h1&gt;</span> element with the value of 5<br/><br/><span class="attribute">root.render(</span><span class="code">&lt;h1&gt;<span class="attribute">{ 2 + 3 }</span>&lt;/h1&gt;</span><span class="attribute">);</span></td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Javascript in JSX cont'd</td>
                            <td>Using the curly brace syntax, Javascript can be used throughout JSX code blocks to import previously declared variables or data stored in objects.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const goose = './image.jpg';<br/><br/>const gooseImg = </span><span class="code">&lt;img src=</span><span class="attribute">{goose}</span><span class="code"> /&gt;</span><span class="attribute">;<br/>root.render(gooseImg);</span><br/><br/>In the above code we have a variable declared that holds the value of a link to an image. This is standard Javascript.<br/>Underneath we have some JSX that is creating an <span class="code">&lt;img /&gt;</span> tag, however inside we use the curly braces syntax to use the variable (<span class="attribute">goose</span>) we declared at the top to be the value of the <span class="code">src</span> element.<br/><br/>Notice how we don't need to wrap quotation marks around this variable as they are contained in the original variable declaration.<br/><br/>The same methodology can be used if we stored various different bits of data in an object.<br/>An example of this is shown below;<br/><br/><span class="attribute">const pics = {<br/>bird: "./image01.jpg",<br/>fish: "./image02.jpg"<br/>};<br/><br/>const bird = (<br/></span><span class="code">&lt;img src=</span><span class="attribute">{pics.bird}<br/></span><span class="code">alt="picture of a bird"</span> <span class="code">/&gt;</span><br/><span class="attribute">);</span></td>
                        </tr>
                        <tr>
                            <td><span class="code">onClick=</span><span class="attribute">{function}</span></td>
                            <td>Event listeners in JSX</td>
                            <td>JSX elements can have event listeners just like HTML elements. Event listeners are created in JSX by giving the element an event listener attribute.<br/>An event listeners name should be the word <span class="attribute">on</span> plus the type of event that it is listening for such as <span class="attribute">Click</span> or <span class="attribute">MouseOver</span>. Further supported event names can be found on the <a href="https://react.dev/reference/react-dom/components/common#" target="_blank">React Website</a>.<br/>Event listener attributes should always be set to a valid function.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const container = document.getElementById('app');<br/>const root = createRoot(container);<br/><br/>function makeDog(value) {<br/>value.target.setAttribute('src', './photo-dog.jpeg');<br/>value.target.setAttribute('alt', 'dog');<br/>}<br/><br/>const cat = (<br/></span><span class="code">&lt;img <br/>onClick=</span><span class="attribute">{makeDog}</span><span class="code"><br/>src="./photo-cat.jpg" <br/>alt="cat" /&gt;</span><br/><span class="attribute">);<br/><br/>root.render(cat);</span><br/><br/>In the above example we have rendered a picture of a cat using the <span class="attribute">root.render()</span> method and passing the JSX variable named <span class="attribute">cat</span> as the argument, this variable has an event listener contained within that we will explain later.<br/>Above this variable we have also declared a function named <span class="attribute">makeDog</span> that targets the 'src' & 'alt' elements of the <span class="code">&lt;img&gt;</span> tag and changes their values.<br/>The event listener contained in the JSX element <span class="attribute">cat</span> is set to <span class="code">onClick</span> so when the picture is clicked the code will run the <span class="attribute">makeDog</span> function which in turn will alter the 'src' and 'alt' elements of the image so it will now appear to be a dog.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Conditional Statements in JSX</td>
                            <td><span class="attribute">if...else</span> statements cannot be inserted into JSX syntax. In order to write a conditional statement the logic needs to be held outside of the JSX and then the results can be JSX.<br/>An example of the syntax is shown below;<br/><br/><span class="attribute">let message;<br/><br/>if (user.age >= drinkingAge) {<br/>message = (<br/></span><span class="code">&lt;h1&gt;<br/>Hey, check out this alcoholic beverage!<br/>&lt;/h1&gt;</span><span class="attribute"><br/>);<br/>} else {<br/>message = (<br/></span><span class="code">&lt;h1&gt;<br/>Hey, check out these earrings I got at Claire's!<br/>&lt;/h1&gt;</span><span class="attribute"><br/>}<br/><br/>root.render(message);</span><br/><br/>Notice how we start by creating a <span class="attribute">let</span> variable called <span class="attribute">message</span> which ultimately ends up being the argument passed into the <span class="attribute">root.render()</span> call at the bottom.<br/>The <span class="attribute">if...else</span> statement is written underneath with the JSX elements being the value assigned to the <span class="attribute">let</span> variable based on the outcome of the conditional statement.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">?</span></td>
                            <td>Ternary Operators in JSX</td>
                            <td>Ternary operators can be used to write truthy or falsey conditional statements in JSX.<br/>Unlike <span class="attribute">if...else</span> conditionals, these are single line conditionals and they can be written within JSX using the curly braces (<span class="attribute">{ }</span>) syntax.<br/>An example of correct syntax is shown below;<br/><br/><span class="attribute">const headline = (<br/></span><span class="code">&lt;h1&gt;</span><br/><span class="attribute">{ age >= drinkingAge ? 'Buy Drink' : 'Do Teen Stuff' }</span><br/><span class="code">&lt;/h1&gt;</span><br/><span class="attribute">);</span><br/><br/>The reason we can use ternary operators in JSX is because it will result in a value whereas <span class="attribute">if...else</span> statements may not always provide a value as an outcome.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">&&</span></td>
                            <td>And Operators in JSX</td>
                            <td><span class="attribute">&&</span> operators can be used to write conditional statements in JSX that may or may not always evaluate to an action.<br/>As with ternary operators, these are single line conditionals and they can be written within JSX using the curly braces (<span class="attribute">{ }</span>) syntax.<br/>An example of correct syntax is shown below;<br/><br/><span class="attribute">const age = Math.random() * 10;<br/><br/>const education = (<br/></span><span class="code">&lt;ul&gt;<br/></span><span class="attribute">{ age > 4 && </span><span class="code">&lt;li&gt;Primary school&lt;/li&gt;</span><span class="attribute"> }<br/>{ age > 11 && </span><span class="code">&lt;li&gt;Secondary school&lt;/li&gt;</span><span class="attribute"> }<br/>{ age > 16 && </span><span class="code">&lt;li&gt;College&lt;/li&gt;</span><span class="attribute"> }<br/></span><span class="code">&lt;/ul&gt;</span><br/><span class="attribute">);</span><br/><br/>In the above example we have a variable declared that produces a random <span class="attribute">age</span>. We then have another variable named <span class="attribute">education</span> that contains our JSX elements including the <span class="attribute">&&</span> conditional statements all wrapped in curly braces.<br/>Each separate line has a conditional statement that will only be rendered if the condition is met, so in this example if our <span class="attribute">age</span> variable is below the number 4 then nothing will be rendered, if the <span class="attribute">age</span> value is 12 then both the first and second <span class="code">li</span> elements will be rendered showing 'Primary school' and 'Secondary school' however the <span class="code">li</span> containing 'College' will not be rendered because the condition has not been met.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.map</span></td>
                            <td>Map iterator in JSX</td>
                            <td>The <span class="attribute">.map()</span> array iterator can be used to create lists from existing arrays within JSX.<br/>An example showing correct syntax is shown below;<br/><br/><span class="attribute">const people = ['Rowe', 'Prevost', 'Gare'];<br/><br/>const peopleList = people.map((person) =><br/></span><span class="code">&lt;li&gt;</span><span class="attribute">{person}</span><span class="code">&lt;/li&gt;</span><span class="attribute"><br/>);<br/><br/>root.render(</span><span class="code">&lt;ul&gt;</span><span class="attribute">{peopleList}</span><span class="code">&lt;/ul&gt;</span><span class="attribute">);</span><br/><br/>In the above example we have an array named <span class="attribute">people</span> containing strings. Underneath we create another variable called <span class="attribute">peopleList</span>, in this we use the <span class="attribute">.map()</span> method to iterate through the array contained within <span class="attribute">people</span>, however within the argument of the <span class="attribute">.map()</span> method we include a function that contains JSX elements to additionally wrap each item in the array with <span class="code">&lt;li&gt;</span> tags.<br/>This results in <span class="attribute">peopleList</span> being populated with an array that matches the original array however each item is now wrapped in <span class="code">&lt;li&gt;</span> tags.<br/>We then use this to render a list of the names using the <span class="attribute">root.render()</span> call at the bottom.<br/>Notice how in the argument for <span class="attribute">.render()</span> we wrap the whole thing in <span class="code">&lt;ul&gt;</span> tags to create a valid JSX list.</td>
                        </tr>
                        <tr>
                            <td><span class="code">key="text"</span></td>
                            <td>Key attribute in JSX</td>
                            <td>A Key is a JSX attribute. It doesn't do anything visible however React uses them internlly to keep track of lists. If lists are not tracked then due to the way React handles re-rendering elements, a list might get scrambled if there is no 'ordering' in place.<br/>Not all lists needs to have keys however they are needed if;<br/>1 - The list items have memory from one render to the next. For example if a to-do list is re-rendered and each item must remember whether it has been checked off or not.<br/>2 - The order might be shuffled. For example search results might be re-rendered and the order may be scrambled in the re-rendering.<br/><br/>An example of the syntax of how to achieve this is shown below;<br/><br/><span class="attribute">const people = ['Rowe', 'Prevost', 'Gare'];<br/><br/>const peopleList = people.map((person,i) =><br/></span><span class="code">&lt;li key=</span><span class="attribute">{'person_' + i}</span><span class="code">&gt;</span> <span class="attribute">{person}</span><span class="code">&lt;/li&gt;</span><span class="attribute"><br/>);<br/><br/>root.render(</span><span class="code">&lt;ul&gt;</span><span class="attribute">{peopleList}</span><span class="code">&lt;/ul&gt;</span><span class="attribute">);</span><br/><br/>In the above example notice how we use javascript to add an increasing key to each item when it gets added to the array.<br/>In the argument for the <span class="attribute">.map()</span> method we include the <span class="attribute">person</span> attribute and a second <span class="attribute">i</span> attribute that we then use within the <span class="attribute">key</span> attribute we give to the <span class="code">&lt;li&gt;</span> tags that wrap around the iterated items.<br/>This results in the <span class="attribute">peopleList</span> array containing the results;<br/><span class="code">&lt;li key='person_0'&gt;Rowe&lt;/li&gt;</span><br/><span class="code">&lt;li key='person_1'&gt;Prevost&lt;/li&gt;</span><br/><span class="code">&lt;li key='person_2'&gt;Gare&lt;/li&gt;</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="container" id="react_fundamentals">
                <h2>React Fundamentals</h2>
                <p>This section describes some fundamental properties of React.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td></td>
                            <td>Intializing React on a project</td>
                            <td>React relies on a number of different libraries and folders. These can all be imported using some simple command line commands to auto install all the dependencies for a project.<br/>While in the relevant project root folder type in;<br/><br/><span class="code">npx create-react-app folder_name</span><br/><br/>This will create a folder with the name you put in instead of <span class="code">folder_name</span> and it will populate the folder with all of the necessary structure required to run a React app.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Starting a React development server</td>
                            <td>To start a development server (a web page preview of the app) you need to navigate to the app folder in terminal and type the command;<br/><br/><span class="code">npm start</span><br/><br/>This will start the react development server so you can view the app. To view the app navigate to http://localhost:3000 on any web browser.<br/><br/>To close the development server simply press ctrl+c to close the server down.<br/>If the terminal has been closed by mistake or it has shut on its own for some reason and the server is still running you can force close the server by typing the command;<br/><br/><span class="code">npx kill-port 3000</span> </td>
                        </tr>
                        <tr>
                            <td><span class="attribute">React</span></td>
                            <td>Importing React</td>
                            <td>React should be imported from the 'react' package, which in turn should be installed in each project as a dependency.<br/>When correctly imported the React library can be utilised to make use of various methods.<br/>An example of the syntax to import React is shown below;<br/><br/><span class="attribute">import React from 'react';</span><br/><br/>In a react application there are typically 2 .js files named App.js and Index.js (although these can be named whatever you wish).<br/>App.js is typically the top level of the application and index.js is the entry point (Think of app.js as a module that is separate from index.js).</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">ReactDOM</span></td>
                            <td>Importing ReactDOM</td>
                            <td>The methods imported from 'react-dom' interact with the DOM.<br/><br/>The methods imported from 'react' do not deal with the DOM at all. They don’t engage directly with anything that isn’t part of React.<br/><br/>To clarify: the DOM is used in React applications, but it isn’t part of React. After all, the DOM is also used in countless non-React applications. Methods imported from 'react' are only for pure React purposes, such as creating components or writing JSX elements.<br/>An example of correct syntax is shown below;<br/><br/><span class="attribute">import ReactDOM from 'react-dom/client';</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">function MyReactComponent()</span></td>
                            <td>Function Components</td>
                            <td>Function components in React are very similar to regular functions in Javascript, they operate in similar ways however there are slight differences.<br/>A function component in React must be defined using PascalCase otherwise React won't recognise it as a function component.<br/>Functions components must ALWAYS include a <span class="attribute">return</span>.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">function MyReactComponent() {<br/>return </span><span class="code">&lt;h1&gt;Hello!&lt;&gt;</span><span class="attribute">;<br/>}</span><br/><br/>A few further comments on function components is that the internal body of the function can contain all of the regular syntax rules of JSX. So for example multi-line code including images can be returned as part of the function body using JSX syntax which in turn can then use javascript and object selectors to target elements outside of the function.<br/>An example is shown below;<br/><br/><span class="attribute">function MyReactComponent() {<br/>return (</span><br/><span class="code">&lt;div&gt;<br/>&lt;h1&gt;Title&lt;&gt;</span><br/><span class="code">&lt;img src=</span><span class="attribute">{picture.src}</span> <span class="code"> alt=</span><span class="attribute">{picture.alt}</span><span class="code"> /&gt;<br/>&lt;/div&gt;</span><br/><span class="attribute">);<br/>};</span><br/><br/>Notice how the JSX has an outer most element that wraps everything, it is encased in parentheses and we use curly braces to use javascript selectors to populate the src and alt attributes of the image.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">export</span></td>
                            <td>Exporting</td>
                            <td>Exporting in React works in the same way as Javascript. The syntax is the same and works in the same way as it does when using modules in Javacsript.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">export default MyReactComponent;</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">&lt;MyComponent /&gt;</span></td>
                            <td>Using and Rendering Function Components</td>
                            <td>In the above JSX section we described how to render JSX elements contained within variables, we can also render function components however the setup and execution for this is slightly different.<br/>To render a component we need to use the <span class="attribute">.createRoot()</span> method from the React library and then chain the <span class="attribute">.render()</span> method to the end of it.<br/>An important point about the syntax here is that the component, when used as an argument in rendering, is written in syntax that looks like HTML rather than Javascript.<br/><br/>An example of how to render a function component is shown below;<br/>We write this call in the index.js file once the function component has been imported into it from the app.js file.<br/><br/><span class="attribute">ReactDOM.createRoot(document.getElementById('app')).render(</span><span class="code">&lt;MyComponent /&gt;</span><span class="attribute">);</span><br/><br/>In the above example we use the <span class="attribute">ReactDOM.createRoot()</span> method to create the root of where we want something to be rendered on the screen.<br/> The argument we are passing in is an element on the page with the Id of 'app' as you can see by the syntax we are using, we are using traditional DOM manipulation to select that element.<br/>We then chain the <span class="attribute">.render()</span> method after this which has the function component as the argument.<br/>Notice how the function component syntax is very similar to a self closing HTML tag.<br/>Also notice how it doesn't contain parentheses either after the function name.</td>
                        </tr>
                        <tr>
                            <td><span class="code">onHover=</span><span class="attribute">{handleHover}</span></td>
                            <td>Event Listeners and Handlers in Function Components</td>
                            <td>React function components can also include event listeners in basically the same way as Javascript. Attributes added to JSX elements like <span class="attribute">&lt;div&gt;</span> or <span class="attribute">&lt;img /&gt;</span> tags can have event listener attributes added into them so that events like <span class="attribute">onClick</span> or <span class="attribute">onHover</span> can trigger some functionality.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">function SubmitButton() {<br/>function handleClick() {<br/>alert('Submission Successful.');<br/>}<br/>return </span><span class="code">&lt;button onClick=</span><span class="attribute">{handleClick}</span><span class="code">&gt;Submit&lt;/button&gt;</span><span class="attribute">;<br/>}</span><br/><br/>The above function component includes a nested function (<span class="attribute">handleClick()</span>) that handles the event that is being listened for.<br/>The listener is contained within the JSX being returned, you can notice the <span class="code">onClick</span> attribute forming part of the <span class="code">&lt;button&gt;</span> tag.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="container" id="props">
                <h2>Props (Properties)</h2>
                <p>This section describes the use of props (Properties) including notes on usages and correct syntax.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">props.value</span></td>
                            <td>Assigning and accessing props</td>
                            <td>Every component has <span class="attribute">props</span>, these are similar to attributes in HTML. They take on a similar syntax, however they can be named whatever you like dependant on what you need to use them for.<br/>An example of a button with some standard props is shown below;<br/><br/><span class="code">&lt;button type="submit" value="submit"&gt;Submit&lt;button /&gt;</span><br/><br/>A components <span class="attribute">props</span> is an object, it holds information about that component.<br/>To access a components <span class="attribute">props</span> object you can reference the <span class="attribute">props</span> object and the dot notation for its properties much in the same way as accessing the key-value pairs of an object.<br>So for example if we had a component that had the props <span class="attribute">name: "Steve"</span> we could access this by using dot notation on the <span class="attribute">props</span> object. <br/>The syntax for this is shown below;<br/><br/><span class="attribute">props.name</span><br/><br/><span class="attribute">props</span> serve the same purpose for components as arguments do for functions.<br/><br/><span class="attribute">function App() {<br/>return </span><span class="code">&lt;PropsDisplayer name="Steve" /&gt;</span><span class="attribute">;<br/>}<br/><br/>function PropsDisplayer(props) {<br/>return </span><span class="code">&lt;p&gt;</span><span class="attribute">{props.name}</span><span class="code">&lt;/p&gt;</span><span class="attribute"><br/>}</span><br/><br/>In the example above we have 2 components. The first is returning the second and at the same time it is giving it the <span class="attribute">props</span> with the value <span class="code">name="Steve"</span>.<br/>The reason for this is because props travel from parent to child. So in the example <span class="attribute">App()</span> is the parent component which is returning the child component <span class="attribute">PropsDisplayer()</span>.<br/><br/>So when <span class="attribute">App()</span> is called, it passes the <span class="attribute">props</span> of <span class="code">name="Steve"</span> to <span class="attribute">PropsDisplayer()</span> which in turn then uses <span class="attribute">props</span> as its argument and then within its code body references this using dot notation to return a <span class="code">&lt;p&gt;</span> tag with the value <span class="attribute">{props.name}</span> back up through the chain.<br/>Lets say we are rendering this to the page so the final outcome will be <span class="code">Steve</span> is rendered to the page.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Props Attribute values</td>
                            <td>The values of props can be anything however there is specific syntax for enabling them to be read correctly.<br/>The hard and fast rule is that attributes that are strings need to be surrounded by double quotation marks (" ") and everything else needs to be contained within curly braces ({ }).<br/>Examples of the various attribute values are shown below;<br/><br/><span class="code">name="Steve"<br/>age={38}<br/>married={true}</span><br/><br/>Attributes can also be arrays. An example of syntax is shown below;<br/><br/><span class="code">list={["Steve", 38, true]}</span><br/><br/>The individual values of an array can be accessed in the traditional manner. So in order to access the age value of the array in the example above, we would use <span class="attribute">props.list[1]</span>.<br/>If we were to access the same thing directly within the parent component we would prefix it with <span class="attribute">this.</span> so it would become <span class="attribute">this.props.list[1]</span><br/><br/>Objects can also be props. An example of this is shown below;<br/><br/><span class="code">list={<br/>{name: "Steve",<br/>age: 38,<br/>married: true}<br/>}</span><br/><br/>These are also accessed in the same way we would normally access an objects values. To access the age value we would use <span class="attribute">props.list.age</span> or <span class="attribute">props.list["age"]</span> and again if we were accessing this directly within the component we would prefix the call with the <span class="attribute">this.</span> keyword.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">function({attribute})</span></td>
                            <td>Destructuring Syntax</td>
                            <td>A destructured syntax can be used when a specific attribute is required for use within a component.<br/>Below is an example of structured syntax;<br/><br/><span class="attribute">function App() {<br/>return </span><span class="code">&lt;PropsDisplayer name="Steve"</span><span class="code"> /&gt;</span><span class="attribute">;<br/>}<br/><br/>function PropsDisplayer(props) {<br/>return </span><span class="code">&lt;p&gt;</span><span class="attribute">{props.name}</span><span class="code">&lt;/p&gt;</span><span class="attribute"><br/>}</span><br/><br/>We can destructure this if we know we want to access a specific prop.<br/>An refactored version of the above code is shown below using destructured syntax;<br/><br/><span class="attribute">function App() {<br/>return </span><span class="code">&lt;PropsDisplayer name="Steve" /&gt;</span><span class="attribute">;<br/>}<br/><br/>function PropsDisplayer({name}) {<br/>return </span><span class="code">&lt;p&gt;</span><span class="attribute">{name}</span><span class="code">&lt;/p&gt;</span><span class="attribute"><br/>}</span><br/><br/>Notice how instead of using the keyword of <span class="attribute">props</span> as the argument in the <span class="code">PropsDisplayer</span> component we use the attribute name directly and wrap it in curly braces, we then use this in the specific section of code we want it to appear within the code block itself.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Using Props in conditional statements</td>
                            <td>Props can be used as the input/deciding factor in a conditional statement. So we can use them to provide different outcomes dependant on the code blocks we are using them with.<br/>An example of how props can be used in a conditional statment to provide alternate outcomes is shown below;<br/><br/><span class="attribute">function App() {<br/>return (<br/></span><span class="code">&lt;div&gt;<br/>&lt;h1&gt;MovieFlix&lt;/h1&gt;<br/>&lt;Greeting name="Alison" signedIn={true} /&gt;<br/>&lt;/div&gt;</span><span class="attribute"><br/>);<br/>}<br/><br/>function Greeting(props) {<br/>if (props.signedIn == false) {<br/>return </span><span class="code">&lt;h1&gt;Please login.&lt;/h1&gt;</span><span class="attribute">;<br/>} else {<br/>return (<br/></span><span class="code">&lt;div&gt;<br/>&lt;h1&gt; back, </span><span class="attribute">{props.name}</span><span class="code">!&lt;/h1&gt;<br/>&lt;article&gt;<br/>Latest Movie: A Computer Bug's Life<br/>&lt;/article&gt;<br/>&lt;/div&gt;</span><span class="attribute"><br/>)<br/>}<br/>}</span><br/><br/>In the example above we have 2 components, the first <span class="attribute">App()</span> component is providing props to be filtered down into the <span class="attribute">Greeting()</span> child component.<br/>Within the code body of <span class="attribute">Greeting()</span> we have a conditional statement that alters what is displayed on the page dependant on whether the <span class="attribute">props.signedIn</span> is <span class="attribute">true</span> or <span class="attribute">false.<br/></span></td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Event Listeners and defining Event Handlers</td>
                            <td>Props can be used as Event Listeners. As with other <span class="attribute">props</span> they need to be passed down from parent to child, they also need to have in-built handler functions so React knows what to do when the event is triggered.<br/>There are a few differences in Event Listeners and the Event handlers within React compared to Javascript, an example of syntax is shown below;<br/><br/><span class="attribute">function Clicker() {<br/>function handleClick() {<br/>let speech = 'Button Clicked!';<br/>alert(speech);<br/>}<br/>return </span><span class="code">&lt;Button onClick=</span><span class="attribute">{handleClick}</span><span class="code">/&gt;</span><span class="attribute">;<br/>}<br/><br/>function Button(props) {<br/>return (<br/></span><span class="code">&lt;button onClick=</span><span class="attribute">{props.onClick}</span><span class="code">&gt;<br/>Click me!<br/>&lt;/button&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/>In the example above we have 2 components. The parent component <span class="attribute">Clicker()</span> contains the handler function <span class="attribute">handleClick()</span> inside of its code body which creates an alert with the text 'Button Clicked!' when invoked. Underneath this it returns the <span class="attribute">Button()</span> component with <span class="attribute">props</span>. The <span class="attribute">props</span> assigned to it is an attribute named <span class="attribute">onClick</span> which references the <span class="attribute">handleClick()</span> function. A key point to note here is that the parent component creates an attribute and note an event listener. This is because the event listener can only go on HTML like JSX and the parent is returning a component not HTML like JSX. The easy way to tell this is due to the capitlisation of the <span class="code">&lt;Button&gt;</span> tag. Capitals at the start of a tag show that its a React component and not a HTML like JSX tag.<br/><br/>Underneath all of this we have the second component <span class="attribute">Button()</span> which returns HTML like JSX with an event listener named <span class="attribute">onClick</span> which itself references the <span class="attribute">props</span> that have been passed down via the parent component.<br/>React has several <span class="attribute">on</span> keywords that create event listeners and this is how the event listener is created within React, its a more compact way of creating an event listener rather than having to select specific things in the DOM.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">onClick</span></td>
                            <td>Click - Event listener</td>
                            <td>This triggers when the user clicks on an element.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">onChange</span></td>
                            <td>Change - Event listener</td>
                            <td>This triggers when the user changes the value of an input field.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">onSubmit</span></td>
                            <td>Submit - Event listener</td>
                            <td>This triggers when the user submits a form.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">onMouseOver</span></td>
                            <td>Mouse Over - Event listener</td>
                            <td>This triggers when the mouse pointer moves over an element.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">onMouseOut</span></td>
                            <td>Mouse Out - Event listener</td>
                            <td>This triggers when the mouse pointer moves out of an element.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">props.children</span></td>
                            <td>Children</td>
                            <td>Components in React when referenced by other components are typically written as self closing tags such as <span class="code">&lt;Button /&gt;</span>.<br/>However they can be written in the same way most HTML tags are by including opening and closing tags such as <span class="code">&lt;Button&gt;&lt;/Button&gt;</span>.<br/>The reason for using opening and closing tags over self closing tags is that the <span class="attribute">props.children</span> attribute.<br/><br/><span class="attribute">props.children</span> returns everything between the opening and closing tags it has been called on.<br/>This allows the outer component to be seperated from its internal content making it flexible and reusable.<br/>A further point to note is that if the internal content is only a single element this gets returned as it is however if there are more elements, for example multiple <span class="code">&lt;li&gt;</span> tags, then these will be returned as an array. If there is nothing inbetween then <span class="attribute">undefined</span> will be returned.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">function App() {<br/>return (<br/></span><span class="code">&lt;div&gt;<br/>&lt;List type='Living Musician'&gt;<br/>&lt;li&gt;Oasis&lt;/li&gt;<br/>&lt;li&gt;The Black Keys&lt;/li&gt;<br/>&lt;/List&gt;<br/>&lt;List type='Dead Musician'&gt;<br/>&lt;li&gt;Jimi Hendrix&lt;/li&gt;<br/>&lt;/List&gt;<br/>&lt;/div&gt;</span><span class="attribute"><br/>);<br/>}<br/><br/>function List(props) {<br/>let titleText = `Favorite ${props.type}`;<br/>if (props.children instanceof Array) {<br/>titleText += 's';<br/>}<br/>return (<br/></span><span class="code">&lt;div&gt;<br/>&lt;h1&gt;</span><span class="attribute">{titleText}</span><span class="code">&lt;/h1&gt;<br/>&lt;ul&gt;</span><span class="attribute">{props.children}</span><span class="code">&lt;/ul&gt;<br/>&lt;/div&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/>In the above example the first component <span class="attribute">App()</span> returns some JSX including the component <span class="attribute">List()</span> however, notice that each <span class="attribute">List()</span> has been written with opening and closing tags containing different levels of information as well as different <span class="attribute">props</span> attributes.<br/>The second component, <span class="attribute">List()</span>, has been written to be a reusable component that renders different information based on the <span class="attribute">props</span> it has been passed. It also has a conditional statement that allows for the pluralization of the <span class="attribute">{titleText}</span> dependant on whether the <span class="attribute">props.children</span> returns a single value or an array.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Props Default Values</td>
                            <td>In the instance of elements requiring input to render something we can provide default values as part of the component declaration.<br/>There are 3 ways to provide this, they have been outlined below;<br/><br/><span class="attribute">function Example(props) {<br/>return </span><span class="code">&lt;h1&gt;</span><span class="attribute">{props.text}</span><span class="code">&lt;/h1&gt;</span><span class="attribute"><br/>}<br/><br/>Example.defaultProps = {<br/>text: 'This is default text',<br/>};</span><br/><br/>The above example creates a <span class="attribute">defaultProps</span> static property to component which has whatever value is assigned to it as an object.<br/><br/><span class="attribute">function Example({text='This is default text'}) {<br/>return </span><span class="code">&lt;h1&gt;</span><span class="attribute">{text}</span><span class="code">&lt;/h1&gt;</span><span class="attribute"><br/>}</span><br/><br/>The above example here provide the default values directly as part of the component definition parameters.<br/><br/><span class="attribute">function Example(props) {<br/>const {text = 'This is default text'} = props;<br/>return </span><span class="code">&lt;h1&gt;</span><span class="attribute">{text}</span><span class="code">&lt;/h1&gt;</span><span class="attribute"><br/>}</span><br/><br/>The final example sets a default value as part of the component body.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="container" id="hooks">
                <h2>Hooks</h2>
                <p>This section describes the use of hooks including notes on usages and correct syntax.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">useState()</span></td>
                            <td>Function component state</td>
                            <td>The state hook is the most commonly used hook for building React components.<br/>It is a named export from the React library which means we need to import it using object destructuring. An example of this is shown below;<br/><br/><span class="attribute">import React, {useState} from 'react'</span><br/><br/>The <span class="attribute">useState()</span> function we import from the react library returns an array with 2 values, we can assign these values to variables using array destructuring.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const [currentState, setCurrentState] = useState();</span><br/><br/>The first value returned by <span class="attribute">useState()</span> allows us to track the current state of a data value or property. Its best thought of as a <span class="attribute">let</span> variable.<br/>The second value returned by <span class="attribute">useState()</span> is a <span class="attribute">function</span> that can set the state of something. So while the variable doesnt contain parentheses when we assign it to a variable in the destructuring portion outlined above, when we call it we use parentheses and pass in an argument as the state for it to set.<br/>A practical example of both in use is shown below;<br/><br/><span class="attribute">function Toggle() {<br/>const [toggle, setToggle] = useState();<br/><br/>return (<br/></span><span class="code">&lt;div&gt;<br/>&lt;p&gt;The toggle is {toggle}&lt;/p&gt;<br/>&lt;button onClick=</span><span class="attribute">{() => setToggle("On")}</span><span class="code">&gt;On&lt;/button&gt;<br/>&lt;button onClick=</span><span class="attribute">{() => setToggle("Off")}</span><span class="code">&gt;Off&lt;/button&gt;<br/>&lt;/div&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/>In the example above we name the state tracker value as <span class="attribute">toggle</span> and the set state variable as <span class="attribute">setToggle</span>. You can then see we use <span class="attribute">toggle</span> within the JSX to inform the user of the state and then provide 2 separate buttons each with event listeners attached that use the <span class="attribute">setToggle</span> function to change the state of <span class="attribute">toggle</span>. Notice how we pass different strings as the argument for each instance of <span class="attribute">setToggle</span>. This is how we can interactively change the state of the <span class="attribute">toggle</span> value.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">useState(value)</span></td>
                            <td>Starting state value</td>
                            <td>In the above examples the starting value of the state is empty and requires some kind of input to then contain a value. This is not always the required behaviour, sometimes we want the state to have a starting value.<br/>We can give the state an initial value when defining the state and set state variables.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const [currentState, setCurrentState] = useState('On');</span><br/><br/>Notice how in the above code we pass an argument of 'On' into the <span class="attribute">useState()</span> function when we are declaring the variables. This argument is used to populate the first value and give an initial state. So without doing anything else we have already set the <span class="attribute">currentState</span> to 'On'.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Using state setters outside of JSX</td>
                            <td>So far the state setters we have been using have been located within the JSX that we are returning. To make the code easier to read, test and modify we can locate the state setters oustide of the JSX.<br/>Locating these elements outside of the JSX helps with our general coding philosophy known as the separation of concerns where we try to keep things modular to a degree, enabling easier problem finding and solving.<br/><br/>Below is an example of syntax showing how we can separate the setters from the JSX.<br/><br/><span class="attribute">function EmailTextInput() {<br/>const [email, setEmail] = useState('');<br/><br/>const handleChange = (event) => {<br/>const updatedEmail = event.target.value;<br/>setEmail(updatedEmail);<br/>}<br/><br/>return (<br/></span><span class="code">&lt;div&gt;<br/>&lt;label for='email-input'&gt;E-mail address:&lt;/label&gt;<br/>&lt;input value=</span><span class="attribute">{email}</span><span class="code"> onChange=</span><span class="attribute">{handleChange}</span><span class="code"> /&gt;<br/>&lt;/div&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/>In the example above we have our state and setter defined at the top of the function component body then underneath we have another function that is an event handler function. This is invoked by a targetted event and when that event happens you can see that something is logged to a variable and then that variable is used as the argument for the state setter.<br/><br/>Underneath this function we have our JSX which shows that we are returning a simple text input box with the label 'E-mail address:'.<br/>Notice how the values for the attributes are the state and event handler function. We use them in a very similar way to the way we use <span class="attribute">props</span> to handle events and give values to things.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Simplification of event handlers</td>
                            <td>In the above example we have the long hand version of the event handler function.<br/><br/><span class="attribute">const handleChange = (event) => {<br/>const newEmail = event.target.value;<br/>setEmail(newEmail);<br/>}</span><br/><br/>This can be refactored to a more concise version.<br/>This is shown below;<br/><br/><span class="attribute">const handleChange = (event) => setEmail(event.target.value);</span><br/><br/>This can be further broken down by using object destructuring.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const handleChange = ({target}) => setEmail(target.value);</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Setting a state using a callback function</td>
                            <td>The setter value of <span class="attribute">useState()</span> can use callback functions to set new states.<br/><br/>So, for example, let's say we want to create a manual counting tracker on a website and we provide the user with 2 buttons, one that will increase the count and one that will decrease the count.<br/>Within our component function we call <span class="attribute">useState()</span> to create the state and the setter.<br/>Lets start the counter off with an initial state of 2.<br/><br/><span class="attribute">const [count, setCount] = useState(2);</span><br/><br/>Underneath this we want to create 2 separate event handler functions, one that will increase the count and another that will decrease the count.<br/>We can do this using concise arrow function syntax. We'll start with the increment function.<br/><br/><span class="attribute">const increase = () => setCount(prevCount => prevCount + 1);</span><br/><br/>In this function we call <span class="attribute">setCount()</span> to set a new state, however, in order to get the functionality we are looking for we need to use a callback function.<br/>The call back function is used as the argument within <span class="attribute">setCount()</span>.<br/>we use a placeholder text (<span class="attribute">prevCount</span>) to call back the current state (<span class="attribute">count</span>) which we know is 2 because that's what we set it to be, then within the callback function we say "take <span class="attribute">prevCount</span> (which is actually <span class="attribute">count</span>) and + 1 to it, and that will be the new state."<br/>When this runs the new state will be 3.<br/><br/>Now we can create the reduction function.<br/><br/><span class="attribute">const decrease = () => setCount(prevCount => prevCount - 1);</span><br/><br/>Now that we have both handler functions defined using call back functions we can write our JSX to include them as the values of our event listeners for each button.<br/><br/><span class="attribute">return (<br/></span><span class="code">&lt;div&gt;<br/>&lt;button onClick=</span><span class="attribute">{increase}</span><span class="code">&gt;Increase!&lt;/button&gt;<br/>&lt;button onClick=</span><span class="attribute">{decrease}</span><span class="code">&gt;Decrease!&lt;/button&gt;<br/>&lt;/div&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Using an array as a state</td>
                            <td>Arrays can be used as states.<br/>A practical example would be creating shopping lists or selecting toppings for a pizza.<br/>An important part to note here is that when an array state is updated the existing array is replaced with a new array, so there are a few things to be aware of in instances where existing state arrays are intended to be added to or have things removed. This is explained further down.<br/><br/>Setting an array as the state can be done in the same way as anything else, you use the setter method with the array as the argument.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">setState(['tomatoes', 'lemons', 'onions', 'mushrooms']);</span><br/><br/>If we want to add something to the state array we need to use a callback function in conjunction with something called the spread syntax. The spread syntax looks like 3 dots (<span class="attribute">...</span>). The way this is used is that it is prefixed to our original array and it makes a copy.<br/>For example, we have an array contained in a variable and we want to copy that into another variable for use later on without affecting the original. The syntax for this would be as below;<br/><br/><span class="attribute">const arr = [1, 2, 3];<br/>const arr2 = [...arr];</span><br/><br/>In the above example <span class="attribute">arr2</span> still has the value of <span class="attribute">[1, 2, 3]</span> but it has been copied over from <span class="attribute">arr</span> using the spread syntax.<br/>So how we can use this in conjunction with a callback function to add items to an array is shown below;<br/><br/><span class="attribute">const addItem = (item) => {<br/>setState((previousArray) => {<br/>return [item, ...previousArray];<br/>});<br/>};</span><br/><br/>In the above example we create a function component that accepts <span class="attribute">item</span> as its argument. Then within the component function we call <span class="attribute">setState()</span> passing in a callback function as the argument. The callback function creates a placeholder (<span class="attribute">previousArray</span>) that references the current state which we know is an array.<br/> Then the code we run in the callback function is to return a new array with the <span class="attribute">item</span> argument from the function component as a new item to be added to a new array, after this we use the spread syntax followed by the <span class="attribute">previousArray</span> reference to copy over the original state array.<br/>This results in a new state which is the new item and the previous array combined into a new array.<br/><br/>To remove an item from an array we need to use the <span class="attribute">.filter()</span> method. The filter method returns an array that is equal to the argument passed in.<br/>Because of this we write the logic to filter through everything that is NOT the item we want removed and the <span class="attribute">.filter()</span> method will then return a new array that excludes the item we want to remove. This is because truthy values are returned and to remove a specific item we need it to equate to falsey when evaluated by the code.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const removeItem = (targetIndex) => {<br/>setState((previousArray) => {<br/>return previousArray.filter((item, index) => index !== targetIndex);<br/>});<br/>};</span><br/><br/>In the above example we again create a function component that accepts <span class="attribute">targetIndex</span> as its argument. Within the function component we call <span class="attribute">setState()</span> again passing in a callback function as that argument. The callback function again creates a placeholder (<span class="attribute">previousArray</span>) that references the current state.<br/>The code we run in the callback function filters through the <span class="attribute">previousArray</span> checking that each item passes the evaluation condition. Because of the way we need the logic to work the evaluation logic checks that each <span class="attribute">index</span> does NOT equate to the <span class="attribute">targetIndex</span>. Every item that passes this test is put into a new array that will be returned as the new state.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Using an object as a state</td>
                            <td>Objects can also be used as states.<br/>A practical example might be a user registering on a website and needing to enter some information about themselves into a form.<br/>The information would be best handled by creating an object for later use in a database.<br/><br/>Setting an object state can be done much in the same way as declaring an object variable.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">setState({key:value, key:value});</span><br/><br/>An object state has some similiarites in terms of its behaviour to that of an array state. Changes overwrite the previous state so if we want to alter an existing object by adding to it, we need to use spread syntax (<span class="attribute">...</span>) to copy the previous state to form part of our new object.<br/><br/>In order to explain how we add to an existing object there is an example of syntax shown below.<br/><br/><span class="attribute">export default function EditProfile() {<br/>const [profile, setProfile] = useState({});<br/><br/>const handleChange = ({ target }) => {<br/>const {name, value} = target;<br/>setProfile((prev) => ({<br/>...prev,<br/>[name]: value<br/>}));<br/>};<br/><br/>const handleSubmit = (event) => {<br/>event.preventDefault();<br/>alert(JSON.stringify(profile, '', 2));<br/>};<br/><br/>return (<br/></span><span class="code">&lt;form onSubmit=</span><span class="attribute">{handleSubmit}</span><span class="code">&gt;<br/><br/>&lt;input<br/>value=</span><span class="attribute">{profile.firstName || ''}</span><span class="code"><br/>name="firstName"<br/>type="text"<br/>placeholder="First Name"<br/>onChange=</span><span class="attribute">{handleChange}</span><span class="code"><br/>/&gt;<br/><br/>&lt;input<br/>value=</span><span class="attribute">{profile.lastName || ''}</span><span class="code"><br/>type="text"<br/>name="lastName"<br/>placeholder="Last Name"<br/>onChange=</span><span class="attribute">{handleChange}</span><span class="code"><br/>/&gt;<br/><br/>&lt;button type="submit"&gt;Submit&lt;/button&gt;<br/>&lt;/form&gt;</span><span class="attribute"><br/><br/>);<br/>}</span><br/><br/>The example above creates 2 input fields and a submit button.<br/>Whenever a user types something into one of the fields the state is updated. This is because we have an event listener on both field inputs. The event listener triggers <span class="code">onChange</span> and calls the <span class="attribute">handleChange</span> function component each time.<br/>We do this because we want to get to a point where the user has typed all of their information, we have a state that reflects this information in an object and then it gets submitted.<br/>We won't go into the <span class="attribute">handleSubmit</span> function in this section so you can essentially ignore that in this example.<br/><br/>The next thing to explain is how the <span class="attribute">handleChange</span> function component works in conjunction with the text fields to update the state.<br/>So in the <span class="attribute">handleChange</span> function we have <span class="attribute">{target}</span> as the argument (this is destructured syntax for <span class="attribute">event.target</span>).<br/>Directly underneath and forming the first bit of the code body we have 2 variables being declared using destructured syntax, <span class="attribute">name</span> and <span class="attribute">value</span>. Both of those variables have the value of <span class="attribute">target</span>.What this does is that when a callback function is invoked later on in the code, both of these variables are targetting whatever the value is of the attribute that matches their name in whatever input box the user has made a change in.<br/>The <span class="attribute">name</span> variable accesses the <span class="code">name</span> attribute to get a value to be assigned as the key in the state object. In the above example, dependant on what box the user is typing into, this would be either <span class="code">firstName</span> or <span class="code">lastName</span>.<br/>The <span class="attribute">value</span> variable is accessing the <span class="code">value</span> attribute. <br/>The <span class="code">value</span> attribute in this instance works the opposite way that it normally works, this is because there is Javascript code as the property rather than a string. Instead of it filling out the text box with whatever property is assigned to it in the code, it actually puts whatever is typed into the textbox by the user into wherever the Javascript code is directing it to. So in this example it's putting whatever is typed by the user into the state object (<span class="attribute">profile</span>) under either the <span class="code">firstName</span> or <span class="code">lastName</span> key dependant on which box is being changed. The Javascript in this particular example also has an <span class="attribute">Or</span> (<span class="attribute">||</span>) operator followed by and empty string (<span class="attribute">' '</span>), this means that if a user deletes everything in the textbox and submits the form the key value pair will have a key with an empty value.<br/><br/>Underneath the unpacked variables we have the state setter function which contains a callback function as its argument. The callback function copies the existing state object (<span class="attribute">profile</span>) using a placeholder (<span class="attribute">prev</span>) and overwrites the existing object, using spread syntax (<span class="attribute">...</span>) in the same way we did with the array example before, using the copied elements. We then follow this with a comma and then the key-value pair with the variables we unpacked above containing the new information. The way this works is that if a key-value pair already exists in the copied over elements, it gets updated with what has been changed by the user and what they have typed in the text box, if it doesn't exist the function creates a new key-value pair in the state object.<br/><br/>Notice how in the key-value pair declared after the spread syntax we have the key section of the key-value pair surrounded by square brackets. This is called computed property name. Essentially this helps to keep the code modular and usable in multiple instances. The computed property naming code takes whatever value is stored in the variable contained within the square brackets, in this instance the variable is <span class="attribute">name</span> so the value will be <span class="code">firstName</span> or <span class="code">lastName</span>, and it uses that value as the name for the key. This is why the same bit of code works for various inputs that have different names. This why we can call the same callback function on the input for <span class="code">firstName</span> and again on <span class="code">lastName</span>.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Separating into multiple states</td>
                            <td>When many pieces of data are in use and things need to be changed its often best for readability and debugging to separate things out into multiple states.<br/><br/><span class="attribute">function Subject() {<br/>const [state, setState] = useState({<br/>currentGrade: 'B',<br/>classmates: ['Hasan', 'Sam', 'Emma'],<br/>classDetails: {topic: 'Math', teacher: 'Ms. Barry', room: 201},<br/>exams: [{unit: 1, score: 91}, {unit: 2, score: 88}]<br/>})}</span><br/><br/>The code above contains an object as the state. It is a very complex state with many pieces of data that may need amending. This could require very complex handler functions in order to amend the data.<br/><br/>Instead of keeping everything within one state it is best practice to try and separate these elements out into different states so we can more easily handle changes with simpler handler functions.<br/>See the refactored code below;<br/><br/><span class="attribute">function Subject() {<br/>const [currentGrade, setGrade] = useState('B');<br/>const [classmates, setClassmates] = useState(['Hasan', 'Sam', 'Emma']);<br/>const [classDetails, setClassDetails] = useState({topic: 'Math', teacher: 'Ms. Barry', room: 201});<br/>const [exams, setExams] = useState([{unit: 1, score: 91}, {unit: 2, score: 88}]);<br/>}</span><br/><br/>In the above code we have the same data however we have separated the various 'categories' into their own states which makes readability and amendments much easier to deal with in future.</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p>For additional tags and examples see the <a href="https://react.dev/reference/react" target="_blank">React Website</a> for more info.</p>
        </div>
    </body>
    <footer>

    </footer>
</html>