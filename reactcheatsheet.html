<!DOCTYPE html>
<html>
    <head>
        <title>React Cheat Sheet</title>
        <link href="./resources/css/index.css" type="text/css" rel="stylesheet">
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link rel="preconnect" href="https://fonts.googleapis.com">
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
    </head>
    <body>
        <header>
            <nav>
                <ul>
                    <li><a href="./htmlcheatsheet.html">HTML</a></li>
                    <li><a href="./csscheatsheet.html">CSS</a></li>
                    <li><a href="./commandlinecheatsheet.html">Command Line</a></li>
                    <li><a href="./javascriptcheatsheet.html">JavaScript</a></li>
                    <li><a href="./reactcheatsheet.html">React</a></li>
                    <li><a href="./markdowncheatsheet.html">Markdown</a></li>
                    <li><a href="./styleguide.html">Style Guide</a></li>
                </ul>
            </nav>
        </header>
        <div class="content">
            <h1>React Cheat Sheet</h1>
            <p>Below is a brief list of fundamental React tags/expressions and syntax including a brief description of what they do and any notes on correct syntax.</p>
            <div class="container" id="jsx">
                <h2>JSX</h2>
                <p>This section describes some fundamental properties of JSX.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td></td>
                            <td>Intro</td>
                            <td>JSX is a syntax extension for Javascript. It was written to be used with React. JSX code looks a lot like HTML.<br/>An important point to note is that JSX is not valid Javascript and web browsers cannot read it, it needs to be compiled before it reaches a web browser.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">const header = </span><span class="code">&lt;h1&gt;title&lt;/h1&gt;</span><span class="attribute">;</span></td>
                            <td>General JSX Syntax</td>
                            <td>JSX elements can be saved to variables.<br/>An example is shown below;<br/><br/><span class="attribute">const header = </span><span class="code">&lt;h1&gt;title&lt;/h1&gt;</span><span class="attribute">;</span><br/><br/>They can also be saved to objects.<br/>An example is shown below;<br/><br/><span class="attribute">const myTeam = {<br/>center: </span><span class="code">&lt;li&gt;Benzo Walli&lt;/li&gt;</span><span class="attribute">,<br/>powerForward: </span><span class="code">&lt;li&gt;Rasha Loa&lt;/li&gt;</span><span class="attribute">,<br/>smallForward: </span><span class="code">&lt;li&gt;Tayshaun Dasmoto&lt;/li&gt;</span><span class="attribute">,<br/>shootingGuard: </span><span class="code">&lt;li&gt;Colmar Cumberbatch&lt;/li&gt;</span><span class="attribute">,<br/>pointGuard: </span><span class="code">&lt;li&gt;Femi Billon&lt;/li&gt;</span><span class="attribute"><br/>};</span><br/><br/>Notice how the syntax looks like a hybrid of Javascript and HTML.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">const p1 = </span><span class="code">&lt;p id='paragraph'&gt;text&lt;/p&gt;</span><span class="attribute">;</span></td>
                            <td>JSX Attributes</td>
                            <td>JSX elements can also contain attributes much in the same way they are used in HTML.<br/>An example is shown below;<br/><br/><span class="attribute">const link = </span><span class="code">&lt;a href='www.google.com'&gt;Google&lt;/a&gt;</span><span class="attribute">;</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">const nav = (</span><br/><span class="code">&lt;div&gt;<br/>&lt;p&gt;text&lt;/p&gt;<br/>&lt;/div&gt;</span><br/><span class="attribute">);</span></td>
                            <td>Nested Elements in JSX</td>
                            <td>JSX elements can be nested much in the same that HTML is written.<br/>An example of this is shown below;<br/><br/><span class="attribute">const clickHeader = </span><span class="code">&lt;a href='www.google.com'&gt;&lt;h1&gt;Click Me!&lt;/h1&gt;&lt;/a&gt;</span><span class="attribute">;</span><br/><br/>An important point to note is that if a JSX expression takes up more than one line then it must be wrapped in parentheses.<br/>An example is shown below;<br/><br/><span class="attribute">const nav = (</span><br/><span class="code">&lt;div&gt;<br/>&lt;ul&gt;<br/>&lt;li&gt;item 01&lt;/li&gt;<br/>&lt;li&gt;item 02&lt;/li&gt;<br/>&lt;li&gt;item 03&lt;/li&gt;<br/>&lt;/ul&gt;<br/>&lt;/div&gt;</span><br/><span class="attribute">);</span><br/><br/>This way we can write our JSX in the same we would with HTML to give a visual representation of hierarchy.<br/><br/>Multi-line JSX items must also be wrapped in a single outer layer.<br/>Notice in the above example we have a containing <span class="code">&lt;div&gt;</span> element. This provides the single outer layer.<br/>An example of <strong>INCORRECT</strong> syntax using multiple outer layers is shown below;<br/><br/><span class="attribute">const nav = (</span><br/><span class="code">&lt;p&gt;item 01&lt;/p&gt;<br/>&lt;p&gt;item 02&lt;/p&gt;<br/>&lt;p&gt;item 03&lt;/p&gt;</span><br/><span class="attribute">);</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.render()</span></td>
                            <td>Rendering JSX</td>
                            <td>React as a language relies on 2 things in order to render elements to the screen correctly: What to render and where to place it.<br/>An example of syntax to render a simple header is shown below;<br/><br/><span class="attribute">const container = document.getElementById('container');<br/>const root = createRoot(container);<br/>root.render(</span><span class="code">&lt;h1&gt;Hello world&lt;/h1&gt;</span><span class="attribute">);</span><br/><br/>In the above code we have 2 variables and a function call.<br/>The first variable <span class="attribute">container</span> is a standard Javascript selection using the DOM. It is selecting the container element by its ID.<br/>This forms part of the 'where' that is required by React to place something.<br/>The second variable <span class="attribute">root</span> is an enabler for the upcoming function call. Note that we are using the <span class="attribute">createRoot()</span> method passing in <span class="attribute">container</span> as the argument.<br/>On the final line of the code snippet we call the <span class="attribute">.render()</span> method on the <span class="attribute">root</span> variable. This is telling React that we want to render something at the position of <span class="attribute">root</span>, which we have set up to be <span class="attribute">container</span>.<br/>Contained with the parentheses of the <span class="attribute">.render()</span> method is the content we want to render at this position which as you can see is a simple header element with the text 'Hello world'.</td>
                        </tr>
                        <tr>
                            <td><span class="code">className="text"</span></td>
                            <td>Classes in JSX</td>
                            <td>Classes can be used in the same way within JSX as they are in HTML however there is a slight difference in the syntax.<br/><span class="attribute">class</span> is a reserved word in Javascript so instead we use <span class="code">className</span>. It works in just the same way as it would in HTML but in order to avoid conflict between the languages it is refactored within JSX to <span class="code">className</span>.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const myDiv = </span><span class="code">&lt;div className="text"&gt;text&lt;/div&gt;</span><span class="attribute">;</span><br/><br/>Notice how we use it in the exact same way as we would do within HTML.</td>
                        </tr>
                        <tr>
                            <td><span class="code">&lt;br/&gt;</span></td>
                            <td>Self closing tags in JSX</td>
                            <td>Self closing tags in JSX are not optional.<br/>The forward slash after tags like <span class="code">&lt;br/&gt;</span> and <span class="code">&lt;img src="file_path.jpg" /&gt;</span> are required otherwise an error will be thrown.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">{  }</span></td>
                            <td>Javascript in JSX</td>
                            <td>When writing JSX, any text placed between JSX (HTML) tags will be treated as a JSX element.<br/>We can however insert Javascript elements between these tags using the curly braces <span class="attribute">{ }</span>.<br/>Doing this will tell our code that whatever is in between the curly braces should be treated in the same way as Javascript.<br/>For example, the code shown below will render a <span class="code">&lt;h1&gt;</span> element with the value of 5<br/><br/><span class="attribute">root.render(</span><span class="code">&lt;h1&gt;<span class="attribute">{ 2 + 3 }</span>&lt;/h1&gt;</span><span class="attribute">);</span></td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Javascript in JSX cont'd</td>
                            <td>Using the curly brace syntax, Javascript can be used throughout JSX code blocks to import previously declared variables or data stored in objects.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const goose = './image.jpg';<br/><br/>const gooseImg = </span><span class="code">&lt;img src=</span><span class="attribute">{goose}</span><span class="code"> /&gt;</span><span class="attribute">;<br/>root.render(gooseImg);</span><br/><br/>In the above code we have a variable declared that holds the value of a link to an image. This is standard Javascript.<br/>Underneath we have some JSX that is creating an <span class="code">&lt;img /&gt;</span> tag, however inside we use the curly braces syntax to use the variable (<span class="attribute">goose</span>) we declared at the top to be the value of the <span class="code">src</span> element.<br/><br/>Notice how we don't need to wrap quotation marks around this variable as they are contained in the original variable declaration.<br/><br/>The same methodology can be used if we stored various different bits of data in an object.<br/>An example of this is shown below;<br/><br/><span class="attribute">const pics = {<br/>bird: "./image01.jpg",<br/>fish: "./image02.jpg"<br/>};<br/><br/>const bird = (<br/></span><span class="code">&lt;img src=</span><span class="attribute">{pics.bird}<br/></span><span class="code">alt="picture of a bird"</span> <span class="code">/&gt;</span><br/><span class="attribute">);</span></td>
                        </tr>
                        <tr>
                            <td><span class="code">onClick=</span><span class="attribute">{function}</span></td>
                            <td>Event listeners in JSX</td>
                            <td>JSX elements can have event listeners just like HTML elements. Event listeners are created in JSX by giving the element an event listener attribute.<br/>An event listeners name should be the word <span class="attribute">on</span> plus the type of event that it is listening for such as <span class="attribute">Click</span> or <span class="attribute">MouseOver</span>. Further supported event names can be found on the <a href="https://react.dev/reference/react-dom/components/common#" target="_blank">React Website</a>.<br/>Event listener attributes should always be set to a valid function.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const container = document.getElementById('app');<br/>const root = createRoot(container);<br/><br/>function makeDog(value) {<br/>value.target.setAttribute('src', './photo-dog.jpeg');<br/>value.target.setAttribute('alt', 'dog');<br/>}<br/><br/>const cat = (<br/></span><span class="code">&lt;img <br/>onClick=</span><span class="attribute">{makeDog}</span><span class="code"><br/>src="./photo-cat.jpg" <br/>alt="cat" /&gt;</span><br/><span class="attribute">);<br/><br/>root.render(cat);</span><br/><br/>In the above example we have rendered a picture of a cat using the <span class="attribute">root.render()</span> method and passing the JSX variable named <span class="attribute">cat</span> as the argument, this variable has an event listener contained within that we will explain later.<br/>Above this variable we have also declared a function named <span class="attribute">makeDog</span> that targets the 'src' & 'alt' elements of the <span class="code">&lt;img&gt;</span> tag and changes their values.<br/>The event listener contained in the JSX element <span class="attribute">cat</span> is set to <span class="code">onClick</span> so when the picture is clicked the code will run the <span class="attribute">makeDog</span> function which in turn will alter the 'src' and 'alt' elements of the image so it will now appear to be a dog.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Conditional Statements in JSX</td>
                            <td><span class="attribute">if...else</span> statements cannot be inserted into JSX syntax. In order to write a conditional statement the logic needs to be held outside of the JSX and then the results can be JSX.<br/>An example of the syntax is shown below;<br/><br/><span class="attribute">let message;<br/><br/>if (user.age >= drinkingAge) {<br/>message = (<br/></span><span class="code">&lt;h1&gt;<br/>Hey, check out this alcoholic beverage!<br/>&lt;/h1&gt;</span><span class="attribute"><br/>);<br/>} else {<br/>message = (<br/></span><span class="code">&lt;h1&gt;<br/>Hey, check out these earrings I got at Claire's!<br/>&lt;/h1&gt;</span><span class="attribute"><br/>}<br/><br/>root.render(message);</span><br/><br/>Notice how we start by creating a <span class="attribute">let</span> variable called <span class="attribute">message</span> which ultimately ends up being the argument passed into the <span class="attribute">root.render()</span> call at the bottom.<br/>The <span class="attribute">if...else</span> statement is written underneath with the JSX elements being the value assigned to the <span class="attribute">let</span> variable based on the outcome of the conditional statement.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">?</span></td>
                            <td>Ternary Operators in JSX</td>
                            <td>Ternary operators can be used to write truthy or falsey conditional statements in JSX.<br/>Unlike <span class="attribute">if...else</span> conditionals, these are single line conditionals and they can be written within JSX using the curly braces (<span class="attribute">{ }</span>) syntax.<br/>An example of correct syntax is shown below;<br/><br/><span class="attribute">const headline = (<br/></span><span class="code">&lt;h1&gt;</span><br/><span class="attribute">{ age >= drinkingAge ? 'Buy Drink' : 'Do Teen Stuff' }</span><br/><span class="code">&lt;/h1&gt;</span><br/><span class="attribute">);</span><br/><br/>The reason we can use ternary operators in JSX is because it will result in a value whereas <span class="attribute">if...else</span> statements may not always provide a value as an outcome.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">&&</span></td>
                            <td>And Operators in JSX</td>
                            <td><span class="attribute">&&</span> operators can be used to write conditional statements in JSX that may or may not always evaluate to an action.<br/>As with ternary operators, these are single line conditionals and they can be written within JSX using the curly braces (<span class="attribute">{ }</span>) syntax.<br/>An example of correct syntax is shown below;<br/><br/><span class="attribute">const age = Math.random() * 10;<br/><br/>const education = (<br/></span><span class="code">&lt;ul&gt;<br/></span><span class="attribute">{ age > 4 && </span><span class="code">&lt;li&gt;Primary school&lt;/li&gt;</span><span class="attribute"> }<br/>{ age > 11 && </span><span class="code">&lt;li&gt;Secondary school&lt;/li&gt;</span><span class="attribute"> }<br/>{ age > 16 && </span><span class="code">&lt;li&gt;College&lt;/li&gt;</span><span class="attribute"> }<br/></span><span class="code">&lt;/ul&gt;</span><br/><span class="attribute">);</span><br/><br/>In the above example we have a variable declared that produces a random <span class="attribute">age</span>. We then have another variable named <span class="attribute">education</span> that contains our JSX elements including the <span class="attribute">&&</span> conditional statements all wrapped in curly braces.<br/>Each separate line has a conditional statement that will only be rendered if the condition is met, so in this example if our <span class="attribute">age</span> variable is below the number 4 then nothing will be rendered, if the <span class="attribute">age</span> value is 12 then both the first and second <span class="code">li</span> elements will be rendered showing 'Primary school' and 'Secondary school' however the <span class="code">li</span> containing 'College' will not be rendered because the condition has not been met.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.map</span></td>
                            <td>Map iterator in JSX</td>
                            <td>The <span class="attribute">.map()</span> array iterator can be used to create lists from existing arrays within JSX.<br/>An example showing correct syntax is shown below;<br/><br/><span class="attribute">const people = ['Rowe', 'Prevost', 'Gare'];<br/><br/>const peopleList = people.map((person) =><br/></span><span class="code">&lt;li&gt;</span><span class="attribute">{person}</span><span class="code">&lt;/li&gt;</span><span class="attribute"><br/>);<br/><br/>root.render(</span><span class="code">&lt;ul&gt;</span><span class="attribute">{peopleList}</span><span class="code">&lt;/ul&gt;</span><span class="attribute">);</span><br/><br/>In the above example we have an array named <span class="attribute">people</span> containing strings. Underneath we create another variable called <span class="attribute">peopleList</span>, in this we use the <span class="attribute">.map()</span> method to iterate through the array contained within <span class="attribute">people</span>, however within the argument of the <span class="attribute">.map()</span> method we include a function that contains JSX elements to additionally wrap each item in the array with <span class="code">&lt;li&gt;</span> tags.<br/>This results in <span class="attribute">peopleList</span> being populated with an array that matches the original array however each item is now wrapped in <span class="code">&lt;li&gt;</span> tags.<br/>We then use this to render a list of the names using the <span class="attribute">root.render()</span> call at the bottom.<br/>Notice how in the argument for <span class="attribute">.render()</span> we wrap the whole thing in <span class="code">&lt;ul&gt;</span> tags to create a valid JSX list.</td>
                        </tr>
                        <tr>
                            <td><span class="code">key="text"</span></td>
                            <td>Key attribute in JSX</td>
                            <td>A Key is a JSX attribute. It doesn't do anything visible however React uses them internlly to keep track of lists. If lists are not tracked then due to the way React handles re-rendering elements, a list might get scrambled if there is no 'ordering' in place.<br/>Not all lists needs to have keys however they are needed if;<br/>1 - The list items have memory from one render to the next. For example if a to-do list is re-rendered and each item must remember whether it has been checked off or not.<br/>2 - The order might be shuffled. For example search results might be re-rendered and the order may be scrambled in the re-rendering.<br/><br/>An example of the syntax of how to achieve this is shown below;<br/><br/><span class="attribute">const people = ['Rowe', 'Prevost', 'Gare'];<br/><br/>const peopleList = people.map((person,i) =><br/></span><span class="code">&lt;li key=</span><span class="attribute">{'person_' + i}</span><span class="code">&gt;</span> <span class="attribute">{person}</span><span class="code">&lt;/li&gt;</span><span class="attribute"><br/>);<br/><br/>root.render(</span><span class="code">&lt;ul&gt;</span><span class="attribute">{peopleList}</span><span class="code">&lt;/ul&gt;</span><span class="attribute">);</span><br/><br/>In the above example notice how we use javascript to add an increasing key to each item when it gets added to the array.<br/>In the argument for the <span class="attribute">.map()</span> method we include the <span class="attribute">person</span> attribute and a second <span class="attribute">i</span> attribute that we then use within the <span class="attribute">key</span> attribute we give to the <span class="code">&lt;li&gt;</span> tags that wrap around the iterated items.<br/>This results in the <span class="attribute">peopleList</span> array containing the results;<br/><span class="code">&lt;li key='person_0'&gt;Rowe&lt;/li&gt;</span><br/><span class="code">&lt;li key='person_1'&gt;Prevost&lt;/li&gt;</span><br/><span class="code">&lt;li key='person_2'&gt;Gare&lt;/li&gt;</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="container" id="react_fundamentals">
                <h2>React Fundamentals</h2>
                <p>This section describes some fundamental properties of React.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td></td>
                            <td>Intializing React on a project</td>
                            <td>React relies on a number of different libraries and folders. These can all be imported using some simple command line commands to auto install all the dependencies for a project.<br/>While in the relevant project root folder type in;<br/><br/><span class="code">npx create-react-app folder_name</span><br/><br/>This will create a folder with the name you put in instead of <span class="code">folder_name</span> and it will populate the folder with all of the necessary structure required to run a React app.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Starting a React development server</td>
                            <td>To start a development server (a web page preview of the app) you need to navigate to the app folder in terminal and type the command;<br/><br/><span class="code">npm start</span><br/><br/>This will start the react development server so you can view the app. To view the app navigate to http://localhost:3000 on any web browser.<br/><br/>To close the development server simply press ctrl+c to close the server down.<br/>If the terminal has been closed by mistake or it has shut on its own for some reason and the server is still running you can force close the server by typing the command;<br/><br/><span class="code">npx kill-port 3000</span> </td>
                        </tr>
                        <tr>
                            <td><span class="attribute">React</span></td>
                            <td>Importing React</td>
                            <td>React should be imported from the 'react' package, which in turn should be installed in each project as a dependency.<br/>When correctly imported the React library can be utilised to make use of various methods.<br/>An example of the syntax to import React is shown below;<br/><br/><span class="attribute">import React from 'react';</span><br/><br/>In a react application there are typically 2 .js files named App.js and Index.js (although these can be named whatever you wish).<br/>App.js is typically the top level of the application and index.js is the entry point (Think of app.js as a module that is separate from index.js).</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">ReactDOM</span></td>
                            <td>Importing ReactDOM</td>
                            <td>The methods imported from 'react-dom' interact with the DOM.<br/><br/>The methods imported from 'react' do not deal with the DOM at all. They don’t engage directly with anything that isn’t part of React.<br/><br/>To clarify: the DOM is used in React applications, but it isn’t part of React. After all, the DOM is also used in countless non-React applications. Methods imported from 'react' are only for pure React purposes, such as creating components or writing JSX elements.<br/>An example of correct syntax is shown below;<br/><br/><span class="attribute">import ReactDOM from 'react-dom/client';</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">function MyReactComponent()</span></td>
                            <td>Function Components</td>
                            <td>Function components in React are very similar to regular functions in Javascript, they operate in similar ways however there are slight differences.<br/>A function component in React must be defined using PascalCase otherwise React won't recognise it as a function component.<br/>Functions components must ALWAYS include a <span class="attribute">return</span>.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">function MyReactComponent() {<br/>return </span><span class="code">&lt;h1&gt;Hello!&lt;&gt;</span><span class="attribute">;<br/>}</span><br/><br/>A few further comments on function components is that the internal body of the function can contain all of the regular syntax rules of JSX. So for example multi-line code including images can be returned as part of the function body using JSX syntax which in turn can then use javascript and object selectors to target elements outside of the function.<br/>An example is shown below;<br/><br/><span class="attribute">function MyReactComponent() {<br/>return (</span><br/><span class="code">&lt;div&gt;<br/>&lt;h1&gt;Title&lt;&gt;</span><br/><span class="code">&lt;img src=</span><span class="attribute">{picture.src}</span> <span class="code"> alt=</span><span class="attribute">{picture.alt}</span><span class="code"> /&gt;<br/>&lt;/div&gt;</span><br/><span class="attribute">);<br/>};</span><br/><br/>Notice how the JSX has an outer most element that wraps everything, it is encased in parentheses and we use curly braces to use javascript selectors to populate the src and alt attributes of the image.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">export</span></td>
                            <td>Exporting</td>
                            <td>Exporting in React works in the same way as Javascript. The syntax is the same and works in the same way as it does when using modules in Javacsript.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">export default MyReactComponent;</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">&lt;MyComponent /&gt;</span></td>
                            <td>Using and Rendering Function Components</td>
                            <td>In the above JSX section we described how to render JSX elements contained within variables, we can also render function components however the setup and execution for this is slightly different.<br/>To render a component we need to use the <span class="attribute">.createRoot()</span> method from the React library and then chain the <span class="attribute">.render()</span> method to the end of it.<br/>An important point about the syntax here is that the component, when used as an argument in rendering, is written in syntax that looks like HTML rather than Javascript.<br/><br/>An example of how to render a function component is shown below;<br/>We write this call in the index.js file once the function component has been imported into it from the app.js file.<br/><br/><span class="attribute">ReactDOM.createRoot(document.getElementById('app')).render(</span><span class="code">&lt;MyComponent /&gt;</span><span class="attribute">);</span><br/><br/>In the above example we use the <span class="attribute">ReactDOM.createRoot()</span> method to create the root of where we want something to be rendered on the screen.<br/> The argument we are passing in is an element on the page with the Id of 'app' as you can see by the syntax we are using, we are using traditional DOM manipulation to select that element.<br/>We then chain the <span class="attribute">.render()</span> method after this which has the function component as the argument.<br/>Notice how the function component syntax is very similar to a self closing HTML tag.<br/>Also notice how it doesn't contain parentheses either after the function name.</td>
                        </tr>
                        <tr>
                            <td><span class="code">onHover=</span><span class="attribute">{handleHover}</span></td>
                            <td>Event Listeners and Handlers in Function Components</td>
                            <td>React function components can also include event listeners in basically the same way as Javascript. Attributes added to JSX elements like <span class="attribute">&lt;div&gt;</span> or <span class="attribute">&lt;img /&gt;</span> tags can have event listener attributes added into them so that events like <span class="attribute">onClick</span> or <span class="attribute">onHover</span> can trigger some functionality.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">function SubmitButton() {<br/>function handleClick() {<br/>alert('Submission Successful.');<br/>}<br/>return </span><span class="code">&lt;button onClick=</span><span class="attribute">{handleClick}</span><span class="code">&gt;Submit&lt;/button&gt;</span><span class="attribute">;<br/>}</span><br/><br/>The above function component includes a nested function (<span class="attribute">handleClick()</span>) that handles the event that is being listened for.<br/>The listener is contained within the JSX being returned, you can notice the <span class="code">onClick</span> attribute forming part of the <span class="code">&lt;button&gt;</span> tag.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="container" id="props">
                <h2>Props (Properties)</h2>
                <p>This section describes the use of props (Properties) including notes on usages and correct syntax.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">props.value</span></td>
                            <td>Assigning and accessing props</td>
                            <td>Every component has <span class="attribute">props</span>, these are similar to attributes in HTML. They take on a similar syntax, however they can be named whatever you like dependant on what you need to use them for.<br/>An example of a button with some standard props is shown below;<br/><br/><span class="code">&lt;button type="submit" value="submit"&gt;Submit&lt;button /&gt;</span><br/><br/>A components <span class="attribute">props</span> is an object, it holds information about that component.<br/>To access a components <span class="attribute">props</span> object you can reference the <span class="attribute">props</span> object and the dot notation for its properties much in the same way as accessing the key-value pairs of an object.<br>So for example if we had a component that had the props <span class="attribute">name: "Steve"</span> we could access this by using dot notation on the <span class="attribute">props</span> object. <br/>The syntax for this is shown below;<br/><br/><span class="attribute">props.name</span><br/><br/><span class="attribute">props</span> serve the same purpose for components as arguments do for functions.<br/><br/><span class="attribute">function App() {<br/>return </span><span class="code">&lt;PropsDisplayer name="Steve" /&gt;</span><span class="attribute">;<br/>}<br/><br/>function PropsDisplayer(props) {<br/>return </span><span class="code">&lt;p&gt;</span><span class="attribute">{props.name}</span><span class="code">&lt;/p&gt;</span><span class="attribute"><br/>}</span><br/><br/>In the example above we have 2 components. The first is returning the second and at the same time it is giving it the <span class="attribute">props</span> with the value <span class="code">name="Steve"</span>.<br/>The reason for this is because props travel from parent to child. So in the example <span class="attribute">App()</span> is the parent component which is returning the child component <span class="attribute">PropsDisplayer()</span>.<br/><br/>So when <span class="attribute">App()</span> is called, it passes the <span class="attribute">props</span> of <span class="code">name="Steve"</span> to <span class="attribute">PropsDisplayer()</span> which in turn then uses <span class="attribute">props</span> as its argument and then within its code body references this using dot notation to return a <span class="code">&lt;p&gt;</span> tag with the value <span class="attribute">{props.name}</span> back up through the chain.<br/>Lets say we are rendering this to the page so the final outcome will be <span class="code">Steve</span> is rendered to the page.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Props Attribute values</td>
                            <td>The values of props can be anything however there is specific syntax for enabling them to be read correctly.<br/>The hard and fast rule is that attributes that are strings need to be surrounded by double quotation marks (" ") and everything else needs to be contained within curly braces ({ }).<br/>Examples of the various attribute values are shown below;<br/><br/><span class="code">name="Steve"<br/>age={38}<br/>married={true}</span><br/><br/>Attributes can also be arrays. An example of syntax is shown below;<br/><br/><span class="code">list={["Steve", 38, true]}</span><br/><br/>The individual values of an array can be accessed in the traditional manner. So in order to access the age value of the array in the example above, we would use <span class="attribute">props.list[1]</span>.<br/>If we were to access the same thing directly within the parent component we would prefix it with <span class="attribute">this.</span> so it would become <span class="attribute">this.props.list[1]</span><br/><br/>Objects can also be props. An example of this is shown below;<br/><br/><span class="code">list={<br/>{name: "Steve",<br/>age: 38,<br/>married: true}<br/>}</span><br/><br/>These are also accessed in the same way we would normally access an objects values. To access the age value we would use <span class="attribute">props.list.age</span> or <span class="attribute">props.list["age"]</span> and again if we were accessing this directly within the component we would prefix the call with the <span class="attribute">this.</span> keyword.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">function({attribute})</span></td>
                            <td>Destructuring Syntax</td>
                            <td>A destructured syntax can be used when a specific attribute is required for use within a component.<br/>Below is an example of structured syntax;<br/><br/><span class="attribute">function App() {<br/>return </span><span class="code">&lt;PropsDisplayer name="Steve"</span><span class="code"> /&gt;</span><span class="attribute">;<br/>}<br/><br/>function PropsDisplayer(props) {<br/>return </span><span class="code">&lt;p&gt;</span><span class="attribute">{props.name}</span><span class="code">&lt;/p&gt;</span><span class="attribute"><br/>}</span><br/><br/>We can destructure this if we know we want to access a specific prop.<br/>An refactored version of the above code is shown below using destructured syntax;<br/><br/><span class="attribute">function App() {<br/>return </span><span class="code">&lt;PropsDisplayer name="Steve" /&gt;</span><span class="attribute">;<br/>}<br/><br/>function PropsDisplayer({name}) {<br/>return </span><span class="code">&lt;p&gt;</span><span class="attribute">{name}</span><span class="code">&lt;/p&gt;</span><span class="attribute"><br/>}</span><br/><br/>Notice how instead of using the keyword of <span class="attribute">props</span> as the argument in the <span class="code">PropsDisplayer</span> component we use the attribute name directly and wrap it in curly braces, we then use this in the specific section of code we want it to appear within the code block itself.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Using Props in conditional statements</td>
                            <td>Props can be used as the input/deciding factor in a conditional statement. So we can use them to provide different outcomes dependant on the code blocks we are using them with.<br/>An example of how props can be used in a conditional statment to provide alternate outcomes is shown below;<br/><br/><span class="attribute">function App() {<br/>return (<br/></span><span class="code">&lt;div&gt;<br/>&lt;h1&gt;MovieFlix&lt;/h1&gt;<br/>&lt;Greeting name="Alison" signedIn={true} /&gt;<br/>&lt;/div&gt;</span><span class="attribute"><br/>);<br/>}<br/><br/>function Greeting(props) {<br/>if (props.signedIn == false) {<br/>return </span><span class="code">&lt;h1&gt;Please login.&lt;/h1&gt;</span><span class="attribute">;<br/>} else {<br/>return (<br/></span><span class="code">&lt;div&gt;<br/>&lt;h1&gt; back, </span><span class="attribute">{props.name}</span><span class="code">!&lt;/h1&gt;<br/>&lt;article&gt;<br/>Latest Movie: A Computer Bug's Life<br/>&lt;/article&gt;<br/>&lt;/div&gt;</span><span class="attribute"><br/>)<br/>}<br/>}</span><br/><br/>In the example above we have 2 components, the first <span class="attribute">App()</span> component is providing props to be filtered down into the <span class="attribute">Greeting()</span> child component.<br/>Within the code body of <span class="attribute">Greeting()</span> we have a conditional statement that alters what is displayed on the page dependant on whether the <span class="attribute">props.signedIn</span> is <span class="attribute">true</span> or <span class="attribute">false.<br/></span></td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Event Listeners and defining Event Handlers</td>
                            <td>Props can be used as Event Listeners. As with other <span class="attribute">props</span> they need to be passed down from parent to child, they also need to have in-built handler functions so React knows what to do when the event is triggered.<br/>There are a few differences in Event Listeners and the Event handlers within React compared to Javascript, an example of syntax is shown below;<br/><br/><span class="attribute">function Clicker() {<br/>function handleClick() {<br/>let speech = 'Button Clicked!';<br/>alert(speech);<br/>}<br/>return </span><span class="code">&lt;Button onClick=</span><span class="attribute">{handleClick}</span><span class="code">/&gt;</span><span class="attribute">;<br/>}<br/><br/>function Button(props) {<br/>return (<br/></span><span class="code">&lt;button onClick=</span><span class="attribute">{props.onClick}</span><span class="code">&gt;<br/>Click me!<br/>&lt;/button&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/>In the example above we have 2 components. The parent component <span class="attribute">Clicker()</span> contains the handler function <span class="attribute">handleClick()</span> inside of its code body which creates an alert with the text 'Button Clicked!' when invoked. Underneath this it returns the <span class="attribute">Button()</span> component with <span class="attribute">props</span>. The <span class="attribute">props</span> assigned to it is an attribute named <span class="attribute">onClick</span> which references the <span class="attribute">handleClick()</span> function. A key point to note here is that the parent component creates an attribute and note an event listener. This is because the event listener can only go on HTML like JSX and the parent is returning a component not HTML like JSX. The easy way to tell this is due to the capitlisation of the <span class="code">&lt;Button&gt;</span> tag. Capitals at the start of a tag show that its a React component and not a HTML like JSX tag.<br/><br/>Underneath all of this we have the second component <span class="attribute">Button()</span> which returns HTML like JSX with an event listener named <span class="attribute">onClick</span> which itself references the <span class="attribute">props</span> that have been passed down via the parent component.<br/>React has several <span class="attribute">on</span> keywords that create event listeners and this is how the event listener is created within React, its a more compact way of creating an event listener rather than having to select specific things in the DOM.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">onClick</span></td>
                            <td>Click - Event listener</td>
                            <td>This triggers when the user clicks on an element.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">onChange</span></td>
                            <td>Change - Event listener</td>
                            <td>This triggers when the user changes the value of an input field.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">onSubmit</span></td>
                            <td>Submit - Event listener</td>
                            <td>This triggers when the user submits a form.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">onMouseOver</span></td>
                            <td>Mouse Over - Event listener</td>
                            <td>This triggers when the mouse pointer moves over an element.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">onMouseOut</span></td>
                            <td>Mouse Out - Event listener</td>
                            <td>This triggers when the mouse pointer moves out of an element.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">props.children</span></td>
                            <td>Children</td>
                            <td>Components in React when referenced by other components are typically written as self closing tags such as <span class="code">&lt;Button /&gt;</span>.<br/>However they can be written in the same way most HTML tags are by including opening and closing tags such as <span class="code">&lt;Button&gt;&lt;/Button&gt;</span>.<br/>The reason for using opening and closing tags over self closing tags is that the <span class="attribute">props.children</span> attribute.<br/><br/><span class="attribute">props.children</span> returns everything between the opening and closing tags it has been called on.<br/>This allows the outer component to be seperated from its internal content making it flexible and reusable.<br/>A further point to note is that if the internal content is only a single element this gets returned as it is however if there are more elements, for example multiple <span class="code">&lt;li&gt;</span> tags, then these will be returned as an array. If there is nothing inbetween then <span class="attribute">undefined</span> will be returned.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">function App() {<br/>return (<br/></span><span class="code">&lt;div&gt;<br/>&lt;List type='Living Musician'&gt;<br/>&lt;li&gt;Oasis&lt;/li&gt;<br/>&lt;li&gt;The Black Keys&lt;/li&gt;<br/>&lt;/List&gt;<br/>&lt;List type='Dead Musician'&gt;<br/>&lt;li&gt;Jimi Hendrix&lt;/li&gt;<br/>&lt;/List&gt;<br/>&lt;/div&gt;</span><span class="attribute"><br/>);<br/>}<br/><br/>function List(props) {<br/>let titleText = `Favorite ${props.type}`;<br/>if (props.children instanceof Array) {<br/>titleText += 's';<br/>}<br/>return (<br/></span><span class="code">&lt;div&gt;<br/>&lt;h1&gt;</span><span class="attribute">{titleText}</span><span class="code">&lt;/h1&gt;<br/>&lt;ul&gt;</span><span class="attribute">{props.children}</span><span class="code">&lt;/ul&gt;<br/>&lt;/div&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/>In the above example the first component <span class="attribute">App()</span> returns some JSX including the component <span class="attribute">List()</span> however, notice that each <span class="attribute">List()</span> has been written with opening and closing tags containing different levels of information as well as different <span class="attribute">props</span> attributes.<br/>The second component, <span class="attribute">List()</span>, has been written to be a reusable component that renders different information based on the <span class="attribute">props</span> it has been passed. It also has a conditional statement that allows for the pluralization of the <span class="attribute">{titleText}</span> dependant on whether the <span class="attribute">props.children</span> returns a single value or an array.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Props Default Values</td>
                            <td>In the instance of elements requiring input to render something we can provide default values as part of the component declaration.<br/>There are 3 ways to provide this, they have been outlined below;<br/><br/><span class="attribute">function Example(props) {<br/>return </span><span class="code">&lt;h1&gt;</span><span class="attribute">{props.text}</span><span class="code">&lt;/h1&gt;</span><span class="attribute"><br/>}<br/><br/>Example.defaultProps = {<br/>text: 'This is default text',<br/>};</span><br/><br/>The above example creates a <span class="attribute">defaultProps</span> static property to component which has whatever value is assigned to it as an object.<br/><br/><span class="attribute">function Example({text='This is default text'}) {<br/>return </span><span class="code">&lt;h1&gt;</span><span class="attribute">{text}</span><span class="code">&lt;/h1&gt;</span><span class="attribute"><br/>}</span><br/><br/>The above example here provide the default values directly as part of the component definition parameters.<br/><br/><span class="attribute">function Example(props) {<br/>const {text = 'This is default text'} = props;<br/>return </span><span class="code">&lt;h1&gt;</span><span class="attribute">{text}</span><span class="code">&lt;/h1&gt;</span><span class="attribute"><br/>}</span><br/><br/>The final example sets a default value as part of the component body.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="container" id="hooks">
                <h2>Hooks</h2>
                <p>This section describes the use of hooks including notes on usages and correct syntax.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">useState()</span></td>
                            <td>The State Hook</td>
                            <td>The state hook is the most commonly used hook for building React components.<br/>It is a named export from the React library which means we need to import it using object destructuring. An example of this is shown below;<br/><br/><span class="attribute">import React, {useState} from 'react'</span><br/><br/>The <span class="attribute">useState()</span> function we import from the react library returns an array with 2 values, we can assign these values to variables using array destructuring.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const [currentState, setCurrentState] = useState();</span><br/><br/>The first value returned by <span class="attribute">useState()</span> allows us to track the current state of a data value or property. Its best thought of as a <span class="attribute">let</span> variable.<br/>The second value returned by <span class="attribute">useState()</span> is a <span class="attribute">function</span> that can set the state of something. So while the variable doesnt contain parentheses when we assign it to a variable in the destructuring portion outlined above, when we call it we use parentheses and pass in an argument as the state for it to set.<br/>A practical example of both in use is shown below;<br/><br/><span class="attribute">function Toggle() {<br/>const [toggle, setToggle] = useState();<br/><br/>return (<br/></span><span class="code">&lt;div&gt;<br/>&lt;p&gt;The toggle is {toggle}&lt;/p&gt;<br/>&lt;button onClick=</span><span class="attribute">{() => setToggle("On")}</span><span class="code">&gt;On&lt;/button&gt;<br/>&lt;button onClick=</span><span class="attribute">{() => setToggle("Off")}</span><span class="code">&gt;Off&lt;/button&gt;<br/>&lt;/div&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/>In the example above we name the state tracker value as <span class="attribute">toggle</span> and the set state variable as <span class="attribute">setToggle</span>. You can then see we use <span class="attribute">toggle</span> within the JSX to inform the user of the state and then provide 2 separate buttons each with event listeners attached that use the <span class="attribute">setToggle</span> function to change the state of <span class="attribute">toggle</span>. Notice how we pass different strings as the argument for each instance of <span class="attribute">setToggle</span>. This is how we can interactively change the state of the <span class="attribute">toggle</span> value.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">useState(value)</span></td>
                            <td>Starting state value</td>
                            <td>In the above examples the starting value of the state is empty and requires some kind of input to then contain a value. This is not always the required behaviour, sometimes we want the state to have a starting value.<br/>We can give the state an initial value when defining the state and set state variables.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const [currentState, setCurrentState] = useState('On');</span><br/><br/>Notice how in the above code we pass an argument of 'On' into the <span class="attribute">useState()</span> function when we are declaring the variables. This argument is used to populate the first value and give an initial state. So without doing anything else we have already set the <span class="attribute">currentState</span> to 'On'.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Using state setters outside of JSX</td>
                            <td>So far the state setters we have been using have been located within the JSX that we are returning. To make the code easier to read, test and modify we can locate the state setters oustide of the JSX.<br/>Locating these elements outside of the JSX helps with our general coding philosophy known as the separation of concerns where we try to keep things modular to a degree, enabling easier problem finding and solving.<br/><br/>Below is an example of syntax showing how we can separate the setters from the JSX.<br/><br/><span class="attribute">function EmailTextInput() {<br/>const [email, setEmail] = useState('');<br/><br/>const handleChange = (event) => {<br/>const updatedEmail = event.target.value;<br/>setEmail(updatedEmail);<br/>}<br/><br/>return (<br/></span><span class="code">&lt;div&gt;<br/>&lt;label for='email-input'&gt;E-mail address:&lt;/label&gt;<br/>&lt;input value=</span><span class="attribute">{email}</span><span class="code"> onChange=</span><span class="attribute">{handleChange}</span><span class="code"> /&gt;<br/>&lt;/div&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/>In the example above we have our state and setter defined at the top of the function component body then underneath we have another function that is an event handler function. This is invoked by a targetted event and when that event happens you can see that something is logged to a variable and then that variable is used as the argument for the state setter.<br/><br/>Underneath this function we have our JSX which shows that we are returning a simple text input box with the label 'E-mail address:'.<br/>Notice how the values for the attributes are the state and event handler function. We use them in a very similar way to the way we use <span class="attribute">props</span> to handle events and give values to things.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Simplification of event handlers</td>
                            <td>In the above example we have the long hand version of the event handler function.<br/><br/><span class="attribute">const handleChange = (event) => {<br/>const newEmail = event.target.value;<br/>setEmail(newEmail);<br/>}</span><br/><br/>This can be refactored to a more concise version.<br/>This is shown below;<br/><br/><span class="attribute">const handleChange = (event) => setEmail(event.target.value);</span><br/><br/>This can be further broken down by using object destructuring.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const handleChange = ({target}) => setEmail(target.value);</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Setting a state using a callback function</td>
                            <td>The setter value of <span class="attribute">useState()</span> can use callback functions to set new states.<br/><br/>So, for example, let's say we want to create a manual counting tracker on a website and we provide the user with 2 buttons, one that will increase the count and one that will decrease the count.<br/>Within our component function we call <span class="attribute">useState()</span> to create the state and the setter.<br/>Lets start the counter off with an initial state of 2.<br/><br/><span class="attribute">const [count, setCount] = useState(2);</span><br/><br/>Underneath this we want to create 2 separate event handler functions, one that will increase the count and another that will decrease the count.<br/>We can do this using concise arrow function syntax. We'll start with the increment function.<br/><br/><span class="attribute">const increase = () => setCount(prevCount => prevCount + 1);</span><br/><br/>In this function we call <span class="attribute">setCount()</span> to set a new state, however, in order to get the functionality we are looking for we need to use a callback function.<br/>The call back function is used as the argument within <span class="attribute">setCount()</span>.<br/>we use a placeholder text (<span class="attribute">prevCount</span>) to call back the current state (<span class="attribute">count</span>) which we know is 2 because that's what we set it to be, then within the callback function we say "take <span class="attribute">prevCount</span> (which is actually <span class="attribute">count</span>) and + 1 to it, and that will be the new state."<br/>When this runs the new state will be 3.<br/><br/>Now we can create the reduction function.<br/><br/><span class="attribute">const decrease = () => setCount(prevCount => prevCount - 1);</span><br/><br/>Now that we have both handler functions defined using call back functions we can write our JSX to include them as the values of our event listeners for each button.<br/><br/><span class="attribute">return (<br/></span><span class="code">&lt;div&gt;<br/>&lt;button onClick=</span><span class="attribute">{increase}</span><span class="code">&gt;Increase!&lt;/button&gt;<br/>&lt;button onClick=</span><span class="attribute">{decrease}</span><span class="code">&gt;Decrease!&lt;/button&gt;<br/>&lt;/div&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Using an array as a state</td>
                            <td>Arrays can be used as states.<br/>A practical example would be creating shopping lists or selecting toppings for a pizza.<br/>An important part to note here is that when an array state is updated the existing array is replaced with a new array, so there are a few things to be aware of in instances where existing state arrays are intended to be added to or have things removed. This is explained further down.<br/><br/>Setting an array as the state can be done in the same way as anything else, you use the setter method with the array as the argument.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">setState(['tomatoes', 'lemons', 'onions', 'mushrooms']);</span><br/><br/>If we want to add something to the state array we need to use a callback function in conjunction with something called the spread syntax. The spread syntax looks like 3 dots (<span class="attribute">...</span>). The way this is used is that it is prefixed to our original array and it makes a copy.<br/>For example, we have an array contained in a variable and we want to copy that into another variable for use later on without affecting the original. The syntax for this would be as below;<br/><br/><span class="attribute">const arr = [1, 2, 3];<br/>const arr2 = [...arr];</span><br/><br/>In the above example <span class="attribute">arr2</span> still has the value of <span class="attribute">[1, 2, 3]</span> but it has been copied over from <span class="attribute">arr</span> using the spread syntax.<br/>So how we can use this in conjunction with a callback function to add items to an array is shown below;<br/><br/><span class="attribute">const addItem = (item) => {<br/>setState((previousArray) => {<br/>return [item, ...previousArray];<br/>});<br/>};</span><br/><br/>In the above example we create a function component that accepts <span class="attribute">item</span> as its argument. Then within the component function we call <span class="attribute">setState()</span> passing in a callback function as the argument. The callback function creates a placeholder (<span class="attribute">previousArray</span>) that references the current state which we know is an array.<br/> Then the code we run in the callback function is to return a new array with the <span class="attribute">item</span> argument from the function component as a new item to be added to a new array, after this we use the spread syntax followed by the <span class="attribute">previousArray</span> reference to copy over the original state array.<br/>This results in a new state which is the new item and the previous array combined into a new array.<br/><br/>To remove an item from an array we need to use the <span class="attribute">.filter()</span> method. The filter method returns an array that is equal to the argument passed in.<br/>Because of this we write the logic to filter through everything that is NOT the item we want removed and the <span class="attribute">.filter()</span> method will then return a new array that excludes the item we want to remove. This is because truthy values are returned and to remove a specific item we need it to equate to falsey when evaluated by the code.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const removeItem = (targetIndex) => {<br/>setState((previousArray) => {<br/>return previousArray.filter((item, index) => index !== targetIndex);<br/>});<br/>};</span><br/><br/>In the above example we again create a function component that accepts <span class="attribute">targetIndex</span> as its argument. Within the function component we call <span class="attribute">setState()</span> again passing in a callback function as that argument. The callback function again creates a placeholder (<span class="attribute">previousArray</span>) that references the current state.<br/>The code we run in the callback function filters through the <span class="attribute">previousArray</span> checking that each item passes the evaluation condition. Because of the way we need the logic to work the evaluation logic checks that each <span class="attribute">index</span> does NOT equate to the <span class="attribute">targetIndex</span>. Every item that passes this test is put into a new array that will be returned as the new state.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">[value]</span></td>
                            <td>Computed Property Names</td>
                            <td>Computed Property Names is a feature which allows the names of object properties in JavaScript object literal notation to be determined dynamically, i.e. computed.<br/>An example is shown below;<br/><br><span class="attribute">const myPropertyName = 'c'<br/><br/>const myObject = {<br/>a: 5,<br/>b: 10,<br/>[myPropertyName]: 15<br/>} <br/><br/>console.log(myObject.c) // prints 15</span><br/><br/>In the above example notice how we define <span class="attribute">myPropertyName</span> at the top of the code with the value of 'c'.<br/>We then create an object and use computed property naming syntax within the object to give the 3rd key a value of 'c'.<br/><br/>This syntax can be thought of in a similar way to that of template literals.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Using an object as a state</td>
                            <td>Objects can also be used as states.<br/>A practical example might be a user registering on a website and needing to enter some information about themselves into a form.<br/>The information would be best handled by creating an object for later use in a database.<br/><br/>Setting an object state can be done much in the same way as declaring an object variable.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">setState({key:value, key:value});</span><br/><br/>An object state has some similiarites in terms of its behaviour to that of an array state. Changes overwrite the previous state so if we want to alter an existing object by adding to it, we need to use spread syntax (<span class="attribute">...</span>) to copy the previous state to form part of our new object.<br/><br/>In order to explain how we add to an existing object there is an example of syntax shown below.<br/><br/><span class="attribute">export default function EditProfile() {<br/>const [profile, setProfile] = useState({});<br/><br/>const handleChange = ({ target }) => {<br/>const {name, value} = target;<br/>setProfile((prev) => ({<br/>...prev,<br/>[name]: value<br/>}));<br/>};<br/><br/>const handleSubmit = (event) => {<br/>event.preventDefault();<br/>alert(JSON.stringify(profile, '', 2));<br/>};<br/><br/>return (<br/></span><span class="code">&lt;form onSubmit=</span><span class="attribute">{handleSubmit}</span><span class="code">&gt;<br/><br/>&lt;input<br/>value=</span><span class="attribute">{profile.firstName || ''}</span><span class="code"><br/>name="firstName"<br/>type="text"<br/>placeholder="First Name"<br/>onChange=</span><span class="attribute">{handleChange}</span><span class="code"><br/>/&gt;<br/><br/>&lt;input<br/>value=</span><span class="attribute">{profile.lastName || ''}</span><span class="code"><br/>type="text"<br/>name="lastName"<br/>placeholder="Last Name"<br/>onChange=</span><span class="attribute">{handleChange}</span><span class="code"><br/>/&gt;<br/><br/>&lt;button type="submit"&gt;Submit&lt;/button&gt;<br/>&lt;/form&gt;</span><span class="attribute"><br/><br/>);<br/>}</span><br/><br/>The example above creates 2 input fields and a submit button.<br/>Whenever a user types something into one of the fields the state is updated. This is because we have an event listener on both field inputs. The event listener triggers <span class="code">onChange</span> and calls the <span class="attribute">handleChange</span> function component each time.<br/>We do this because we want to get to a point where the user has typed all of their information, we have a state that reflects this information in an object and then it gets submitted.<br/>We won't go into the <span class="attribute">handleSubmit</span> function in this section so you can essentially ignore that in this example.<br/><br/>The next thing to explain is how the <span class="attribute">handleChange</span> function component works in conjunction with the text fields to update the state.<br/>So in the <span class="attribute">handleChange</span> function we have <span class="attribute">{target}</span> as the argument (this is destructured syntax for <span class="attribute">event.target</span>).<br/>Directly underneath and forming the first bit of the code body we have 2 variables being declared using destructured syntax, <span class="attribute">name</span> and <span class="attribute">value</span>. Both of those variables have the value of <span class="attribute">target</span>.What this does is that when a callback function is invoked later on in the code, both of these variables are targetting whatever the value is of the attribute that matches their name in whatever input box the user has made a change in.<br/>The <span class="attribute">name</span> variable accesses the <span class="code">name</span> attribute to get a value to be assigned as the key in the state object. In the above example, dependant on what box the user is typing into, this would be either <span class="code">firstName</span> or <span class="code">lastName</span>.<br/>The <span class="attribute">value</span> variable is accessing the <span class="code">value</span> attribute. <br/>The <span class="code">value</span> attribute in this instance works the opposite way that it normally works, this is because there is Javascript code as the property rather than a string. Instead of it filling out the text box with whatever property is assigned to it in the code, it actually puts whatever is typed into the textbox by the user into wherever the Javascript code is directing it to. So in this example it's putting whatever is typed by the user into the state object (<span class="attribute">profile</span>) under either the <span class="code">firstName</span> or <span class="code">lastName</span> key dependant on which box is being changed. The Javascript in this particular example also has an <span class="attribute">Or</span> (<span class="attribute">||</span>) operator followed by and empty string (<span class="attribute">' '</span>), this means that if a user deletes everything in the textbox and submits the form the key value pair will have a key with an empty value.<br/><br/>Underneath the unpacked variables we have the state setter function which contains a callback function as its argument. The callback function copies the existing state object (<span class="attribute">profile</span>) using a placeholder (<span class="attribute">prev</span>) and overwrites the existing object, using spread syntax (<span class="attribute">...</span>) in the same way we did with the array example before, using the copied elements. We then follow this with a comma and then the key-value pair with the variables we unpacked above containing the new information. The way this works is that if a key-value pair already exists in the copied over elements, it gets updated with what has been changed by the user and what they have typed in the text box, if it doesn't exist the function creates a new key-value pair in the state object.<br/><br/>Notice how in the key-value pair declared after the spread syntax we have the key section of the key-value pair surrounded by square brackets. This is called computed property name. Essentially this helps to keep the code modular and usable in multiple instances. The computed property naming code takes whatever value is stored in the variable contained within the square brackets, in this instance the variable is <span class="attribute">name</span> so the value will be <span class="code">firstName</span> or <span class="code">lastName</span>, and it uses that value as the name for the key. This is why the same bit of code works for various inputs that have different names. This why we can call the same callback function on the input for <span class="code">firstName</span> and again on <span class="code">lastName</span>.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Separating into multiple states</td>
                            <td>When many pieces of data are in use and things need to be changed its often best for readability and debugging to separate things out into multiple states.<br/><br/><span class="attribute">function Subject() {<br/>const [state, setState] = useState({<br/>currentGrade: 'B',<br/>classmates: ['Hasan', 'Sam', 'Emma'],<br/>classDetails: {topic: 'Math', teacher: 'Ms. Barry', room: 201},<br/>exams: [{unit: 1, score: 91}, {unit: 2, score: 88}]<br/>})}</span><br/><br/>The code above contains an object as the state. It is a very complex state with many pieces of data that may need amending. This could require very complex handler functions in order to amend the data.<br/><br/>Instead of keeping everything within one state it is best practice to try and separate these elements out into different states so we can more easily handle changes with simpler handler functions.<br/>See the refactored code below;<br/><br/><span class="attribute">function Subject() {<br/>const [currentGrade, setGrade] = useState('B');<br/>const [classmates, setClassmates] = useState(['Hasan', 'Sam', 'Emma']);<br/>const [classDetails, setClassDetails] = useState({topic: 'Math', teacher: 'Ms. Barry', room: 201});<br/>const [exams, setExams] = useState([{unit: 1, score: 91}, {unit: 2, score: 88}]);<br/>}</span><br/><br/>In the above code we have the same data however we have separated the various 'categories' into their own states which makes readability and amendments much easier to deal with in future.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">useEffect()</span></td>
                            <td>The Effect Hook</td>
                            <td>The effect hook is a function that has no return value. We import it from the React library in the same way we import the <span class="attribute">useState()</span> method.<br/>This is shown below;<br/><br/><span class="attribute">import React, { useState, useEffect } from 'react';</span><br/><br/>The effect hook is used to tell our component to do something every time it is rendered or re-rendered. It is usually combined with states enabling the webpage to becoming dynamic and allow for high interactivity for the user.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">function PageTitle() {<br/>const [name, setName] = useState('');<br/><br/>useEffect(() => {<br/>document.title = `Hi, ${name}`;<br/>});<br/><br/>return (<br/></span><span class="code">&lt;div&gt;<br/>&lt;p&gt;Use the input field below to rename this page!&lt;/p&gt;<br/>&lt;input onChange=</span><span class="attribute">{({target}) => setName(target.value)}</span><span class="code"> value=</span><span class="attribute">{name}</span><span class="code"> type='text' /&gt;<br/>&lt;/div&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/>In the example above we create a function component named <span class="attribute">PageTitle()</span>. Within this component we have a state and state setter and following this we have our effect hook followed by some JSX that is being returned by the component.<br/>Working through the code we can see that our effect hook has an anonymous function that accesses the DOM and assigns a value to the <span class="attribute">title</span>. This is the effect that will be applied. It is being applied <span class="attribute">onChange</span> because in the JSX being returned there is an <span class="attribute">onChange</span> event listener with a callback function as its value.<br/>The callback function uses destructured syntax to unpack and use <span class="attribute">target</span> to target whatever is being typed into the <span class="code">&lt;input&gt;</span> textbox and set that as the state using the value attribute within the same <span class="code">&lt;input&gt;</span> tag.<br/><br/>So because everything is applied <span class="attribute">onChange</span> the <span class="attribute">title</span> element on the page will be re-rendered with the content of the textbox every time a new character is entered or deleted.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Clean Up Effects</td>
                            <td>Some effects require a clean up step to be included within the code body.<br/><br/>For example lets say we create an event listener as part of the <span class="attribute">useEffect()</span> call. If we do not clean this up after the <span class="attribute">useEffect()</span> function has been executed then we continue to add event listeners every time the <span class="attribute">uesEffect()</span> function is called. So if we call it a second time there will now be 2 event listeners, if we call it a third time there will be 3 event listeners, all of them listening and then carrying out the effect they are listening for.<br/>This can lead to unexpected effects and even cause the programme to crash due to the ever increasing number of effects it is attempting to execute.<br/><br/>Below there is an example of a simple counting tracker that displays the correct syntax for clean up of the effect hook.<br/><br/><span class="attribute">export default function Counter() {<br/>const [clickCount, setClickCount] = useState(0);<br/><br/>const increment = () => {setClickCount(clickCount => clickCount + 1)};<br/><br/>useEffect(() => {<br/>document.addEventListener('mousedown', increment);<br/>return () => {<br/>document.removeEventListener('mousedown', increment);<br/>}<br/>});<br/><br/>return <br/></span><span class="code">&lt;h1&gt;Document Clicks: </span><span class="attribute">{clickCount}</span><span class="code">&lt;/h1&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/>The code above has an event listener as part of the <span class="attribute">useEffect()</span> function call but it also <span class="attribute">return</span>'s the removal of the event listener. While this doesn't seem to make sense it works because of the way that React handles the rendering/unmounting process of running its code.<br/>When the component is rendered for the very first time, the following happens;<br/><br/>1 - An event listener is attached to the document, this is the 'mousedown' event that triggers the increment function to be called.<br/><br/>2 - The cleanup section of the function is not executed but <span class="attribute">useEffect()</span> stores the knowledge that if the component is re-rendered or unmounted then the cleanup function must be executed before re-rendering.<br/><br/>Whats important to note here also is that whatever effects are contained within <span class="attribute">useEffect()</span>, they are carried out after rendering. So the general order of things is....<br/> The page is rendered and then the event listener is attached after which React makes a note about needing to remove the event listener when the page gets re-rendered. So the next time a page is re-rendered the stored removal of the listener is carried out, the page is rendered and a new listener is attached and another note about removing the listener is made.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">useEffect(value, [])</span></td>
                            <td>Effect dependency - Single use</td>
                            <td>The <span class="attribute">useEffect()</span> function calls its first argument after each time a component renders. This is the default behaviour, however the <span class="attribute">useEffect()</span> can take 2 arguments. The second argument is called the dependency array.<br/><br/>The dependency array is used to tell <span class="attribute">useEffect()</span> when to call the effect and when to skip it. The effect is always called after the first render but only called again if something in our dependency array has changed values between renders.<br/><br/>With the above in mind we can make the <span class="attribute">useEffect()</span> function trigger every time, on defined times or only once.<br/><br/>To make the effect trigger once we can pass in an empty array as the second argument. This will ensure that it triggers on the first render and will not trigger again. Any cleanup actions included within the code body will still take place but because we have an empty array as our second argument it essentially makes it single use.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">export default function Timer() {<br/>const [time, setTime] = useState(0);<br/>const [name, setName] = useState("");<br/><br/>useEffect(() => {<br/>const interval = setInterval(() => {<br/>setTime((prev) => prev + 1);<br/>}, 1000);<br/>return () => {<br/>clearInterval(interval);<br/>};<br/>}, []);<br/><br/>const handleChange = ({ target }) => {<br/>setName(target.value);<br/>};<br/><br/>return (<br/></span><span class="code">&lt;&gt;<br/>&lt;h1&gt;Time: </span><span class="attribute">{time}</span><span class="code">&lt;/h1&gt;<br/>&lt;input value=</span><span class="attribute">{name}</span><span class="code"> onChange=</span><span class="attribute">{handleChange}</span><span class="code"> /&gt;<br/>&lt;/&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/>In the example above we have created a timer that begins counting up every second as soon as the page first renders. There is also some JSX that creates an input textbox for the user to type into which has its own state and event listener that will re-render the page whenever the user types into the text box.<br/>In the <span class="attribute">useEffect()</span> code body we define the timer and include a single use dependency. The reason we do this is because elsewhere in the code there are elements that will re-render the page. Every time the page re-renders the timer will pause until the page has finished rendering before it then begins counting again. Therefore the intervals would no longer be 1 second as we want it to be, it will be a little longer.<br/>So our single use dependency in this example essentially says start counting on the first render and continue counting until whatever is defined within the <span class="attribute">[ ]</span> brackets changes. Because there is nothing contained within the brackets, the timer will carry on counting at the defined 1000ms pace regardless of whether the page re-renders or not.<br/><br/>A side point to note here also which is equally as important in this specific example is the cleanup step. In the <span class="attribute">useEffect()</span> code body even though we are using a single dependency effect we still need to add in a cleanup step otherwise every time the page re-renders as a result of the timer (remeber it is still re-rendering to show the count on the page) a new iteration of the of the effect is created so every second a new + 1 is added to the same state. This means the timer will get exponentially larger. We still need to cleanup up the effects to prevent exponential growth in terms of the effect.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">useEffect(value, [value])</span></td>
                            <td>Effect dependency - Controlled use</td>
                            <td>In contrast to the single use behaviour of the <span class="attribute">useEffect()</span> dependency, we can include a value for the function to check against upon the page re-rendering to determine whether the effect needs to be called again or not.<br/>An example of how this might be achieved is shown in the example below;<br/><br/><span class="attribute">import React, { useState, useEffect } from "react";<br/>import { get } from './mockBackend/fetch';<br/><br/>export default function Forecast() {<br/>const [data, setData] = useState();<br/>const [notes, setNotes] = useState({});<br/>const [forecastType, setForecastType] = useState('/daily');<br/><br/>useEffect(() => {<br/>alert('Requested data from server...');<br/>get(forecastType).then((response) => {<br/>alert('Response: ' + JSON.stringify(response,'',2));<br/>setData(response.data);<br/>});<br/>}, [forecastType]);<br/><br/>const handleChange = (index) => ({ target }) =><br/>setNotes((prev) => ({<br/>...prev,<br/>[index]: target.value<br/>}));<br/><br/>if (!data) {<br/>return</span><span class="code">&lt;p&gt;Loading...&lt;/p&gt;</span><span class="attribute"><br/>}<br/><br/>if (data) {<br/>return (<br/></span><span class="code">&lt;div className='App'&gt;<br/>&lt;h1&gt;My Weather Planner&lt;/h1&gt;<br/>&lt;div&gt;<br/>&lt;button onClick=</span><span class="attribute">{() => setForecastType('/daily')}</span><span class="code">&gt;5-day&lt;/button&gt;<br/>&lt;button onClick=</span><span class="attribute">{() => setForecastType('/hourly')}</span><span class="code">&gt;Today&lt;/button&gt;<br/>&lt;/div&gt;<br/>&lt;table&gt;<br/>&lt;thead&gt;<br/>&lt;tr&gt;<br/>&lt;th&gt;Summary&lt;/th&gt;<br/>&lt;th&gt;Avg Temp&lt;/th&gt;<br/>&lt;th&gt;Precip&lt;/th&gt;<br/>&lt;th&gt;Notes&lt;/th&gt;<br/>&lt;/tr&gt;<br/>&lt;/thead&gt;<br/>&lt;tbody&gt;<br/></span><span class="attribute">{data.map((item, i) => (</span><br/><span class="code">&lt;tr key=</span><span class="attribute">{item.id}</span><span class="code">&gt;<br/>&lt;td&gt;</span><span class="attribute">{item.summary}</span><span class="code">&lt;/td&gt;<br/>&lt;td&gt;</span><span class="attribute">{item.temp.avg}</span><span class="code">°F&lt;/td&gt;<br/>&lt;td&gt;</span><span class="attribute">{item.precip}</span><span class="code">%&lt;/td&gt;<br/>&lt;td&gt;<br/>&lt;input<br/>value=</span><span class="attribute">{notes[item.id] || ''}</span><span class="code"><br/>onChange=</span><span class="attribute">{handleChange(item.id)}</span><span class="code"><br/>/&gt;<br/>&lt;/td&gt;<br/>&lt;/tr&gt;</span><span class="attribute"><br/>))}<br/></span><span class="code">&lt;/tbody&gt;<br/>&lt;/table&gt;<br/>&lt;/div&gt;</span><span class="attribute"><br/>);<br/>}<br/>}</span><br/><br/>In the above example we are fetching some weather data from an external source and looking to return this information for use on our page.<br/>We want to give functionality to look at a faily forecast and a 5 day forecast, each time we will need to fetch the data from the external source.<br/>We are also creating some textboxes beside each forecast for the user to make notes. The textboxes have their own event listeners that will re-render the page.<br/>This is important to note because we only want our effect to run its effect (which is to fetch new data) when the user switches between the single day forecast and the 5 day.<br/>The reason we dont want it to fetch new data on every render is because it takes up a lot of computing resources and uses the users bandwith as well as potentially incurs API service fees.<br/><br/>A large portion of this example we can ignore because its the dressing around the code to make the code work, we want to focus on our <span class="attribute">useEffect()</span> code block.<br/>In the <span class="attribute">useEffect()</span> we fetch the data and then on the last line of the code body we use our state setter to <span class="attribute">setData</span> to be the data we have fetched. This stores it in our state object (<span class="attribute">data</span>).<br/>We create the <span class="attribute">useEffect()</span> with a dependency named <span class="attribute">forecastType</span>. This is a state object which is toggled by the <span class="code">&lt;button&gt;</span> tags defined within the JSX portion of the code later on so the user can switch between single day and 5 day forecasts.<br/><br/>This is important because that state (<span class="attribute">forecastType</span>) is what defines when our effect is called because it is our dependency.<br/><br/>With that in mind the functionality now works in such a way that the first render creates the <span class="attribute">forecastType</span> state object with a state. This happens to be the daily forecast, so that is what is rendered on the page.<br/>If the user decides to switch to a 5 day forecast, the <span class="code">&lt;button&gt;</span> tags invoke a callback function which updates the state of <span class="attribute">forecastType</span>. The page is re-rendered and the <span class="attribute">useEffect()</span> dependency is checked and notices that it has changed which then causes the <span class="attribute">useEffect()</span> function to be called which in turn fetches the new 5 day forecast data and displays that.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Rules of Hooks</td>
                            <td>Hooks require 2 rules to be followed.<br/><br/>1 - Only call hooks at the top level.<br/>2 - Only call hooks from React functions.<br/><br/>React keeps track of the data and functions that we are managing with Hooks based on their order in the function component’s definition. For this reason, we always call our Hooks at the top level; we never call hooks inside of loops, conditions, or nested functions.<br/><br/>An example of bad syntax is shown below;<br/><br/><span class="attribute">if (userName !== '') {<br/>useEffect(() => {<br/>localStorage.setItem('savedUserName', userName);<br/>});<br/>}</span><br/><br/>The above code should be refactored so the conditional is within the hook.<br/>An example of correct syntax is shown below;<br/><br/><span class="attribute">useEffect(() => {<br/>if (userName !== '') {<br/>localStorage.setItem('savedUserName', userName);<br/>}<br/>});</span><br/><br/>The conditional statement still works but it is located inside the hook to prevent confusion.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Container and Presentational Components</td>
                            <td>In React there is a programming pattern of separating out concerns with regards to the different components.<br/>What this essentially means is that we dont want to have a component that tries to deal with too much on its own. This creates difficult to read code, it also makes it more difficult to debug because the source of the problem is not immediately obvious.<br/><br/>The programming pattern that is regularly employed is to separate components into 2 overarching categories.<br/>These are;<br/><br/>1 - Container components<br/>These are generally parent components.<br/><br/>2 - Presentation components<br/>These are generally the child components.<br/><br/>Container components focus on logic, states and effects as well as props based calcultions.<br/>An example of a container component is shown below;<br/><br/><span class="attribute">function Container() {<br/>const [isActive, setIsActive] = useState(false);<br/><br/>return (<br/></span><span class="code">&lt;&gt;<br/>&lt;Presentational active=</span><span class="attribute">{isActive}</span><span class="code"> toggle=</span><span class="attribute">{setIsActive}</span><span class="code">/&gt;<br/>&lt;OtherPresentational active=</span><span class="attribute">{isActive}</span><span class="code">/&gt;<br/>&lt;/&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/>Presentation components are stateless and only render JSX.<br/>An example of a presentation component is shown below;<br/><br/><span class="attribute">function Presentational(props) {<br/>return (<br/></span><span class="code">&lt;h1&gt;Engines are active? </span><span class="attribute">{props.active}</span><span class="code">&lt;/h1&gt;<br/>&lt;button onClick=</span><span class="attribute">{() => props.toggle(!props.active)}</span><span class="code">&gt;Engine Toggle&lt;/button&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/>Notice how in the 2 components there is a clear separation of logic and JSX. The code within the tags in the container component may look like JSX but its actually the props calculation. The props are being passed down to the child function component and then the child presentation component is rendering the JSX.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>Parent/Child Function Communication</td>
                            <td>Communication between function components can be quite tricky generally container components communicate with presentation components by passing <span class="attribute">props</span>.<br/><br/>Presentation components can communicate back up the hierarchy but the method of communication needs to be passed down to it through the props it receives in the form of change handler functions.<br/>An example of this is shown below;<br/><br/>The code below is the container component in its own file.<br/><br/><span class="attribute">function Container() {<br/>const [isActive, setIsActive] = useState(false);<br/><br/>return (<br/></span><span class="code">&lt;&gt;<br/>&lt;Presentational active=</span><span class="attribute">{isActive}</span><span class="code"> toggle=</span><span class="attribute">{setIsActive}</span><span class="code">/&gt;<br/>&lt;OtherPresentational active=</span><span class="attribute">{isActive}</span><span class="code">/&gt;<br/>&lt;/&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/>The code below is the presentation component contained in its own separate file.<br/><br/><span class="attribute">function Presentational(props) {<br/>return (<br/></span><span class="code">&lt;h1&gt;Engines are active? </span><span class="attribute">{props.active}</span><span class="code">&lt;/h1&gt;<br/>&lt;button onClick=</span><span class="attribute">{() => props.toggle(!props.active)}</span><span class="code">&gt;Engine Toggle&lt;/button&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/>The container component is a state based component that communicates down to the presentation component by providing it with <span class="attribute">props</span>. In this example the communication it is sending is the state. The presentation component uses the state in its <span class="code">&lt;h1&gt;</span> tag to display whether the engines are active or not.<br/>The <span class="attribute">{props.active}</span> Javascript in the presentation component references the <span class="code">active=</span><span class="attribute">{isActive}</span> prop being passed down in the container component, which in turn is referencing the state (<span class="attribute">isActive</span>) at the top level of the container component.<br/><br/>The flow of information is from parent to child.<br/><br/>We can also see in the code that the container component passes a state setter function as another prop (<span class="code">toggle=</span><span class="attribute">{setIsActive}</span>). This is what will enable the presentation component to communicate back up the hierarchy.<br/>Within the JSX of the presentation component the prop of the state setter is used within an anonymous function as an <span class="attribute">onClick</span> event.<br/>So when the button is clicked the presentation component communicates back to the container component that the state has changed which means that the page needs to re-render and the new state needs to be passed down to the presentation component again.<br/><br/>Here the initiating component is the presentation component as it tells the parent component something has changed and the information needs to flow back down again.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        <div class="container" id="styles">
            <h2>Styles and styling in React</h2>
            <p>This section describes how to style elements in React including notes on usages and correct syntax.</p>
            <table>
                <thead>
                    <tr>
                        <th>Tag/Expression</th>
                        <th>Name</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td></td>
                        <td>Inline Styles</td>
                        <td>Styles can be written inline in React.<br/>They should be applied as an attribute.<br/>An example of syntax is shown below;<br/><br/><span class="code">&lt;h1 style=</span><span class="attribute">{{ color: 'red', backgroundColor: 'green', fontSize: '25px' }}</span><span class="code">&gt;Hello world&lt;/h1&gt;</span><br/><br/>Notice that it has double curly braces. The outer curly braces are to note that everything between should be read as JavaScript. The inner curly braces create a JavaScript object literal, this is so all the inline styles being applied are grouped together as an object.<br/>One further point to note is the syntax of the styling elements. The names are the same as CSS names however they are camelCased instead of hyphenated (background-color becomes backgroundColor) the values are also all wrapped in quotations.</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>Style Object Variables</td>
                        <td>Inline styles can become quite messy and difficult to read, the alternative is to store the style in a variable as an object and then use that as the property of the attribute.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const style = {<br/>color: 'red',<br/>backgroundColor: 'green',<br/>fontSize: '25px'<br/>};</span><br/><br/><span class="code">&lt;h1 style=</span><span class="attribute">{style}</span><span class="code">&gt;Hello world&lt;/h1&gt;</span><br/><br/>This keeps the JSX portion of the code much cleaner and easier to read.</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>Multiple Stylesheets</td>
                        <td>Keeping things modular is a key philosophy of React. Therefore styling can be carried out in the same way. It keeps things cleaner, easier to read and easier to debug.<br/>Inline styling and object variable styling is fine however, a better way to style things in react is for each individual component to have its own stylesheet.<br/><br/>Multiple stylesheets can inevitably cause naming conflicts when things are modular, projects become large and keeping track of what specific things are named or not named can be difficult. As a result React uses modular stylesheets to get around this.<br/>By importing CSS stylesheets as modules, the styles will only be available for the component that imported the style therefore its contents can have the same selector names as another component but there will not be any conflict because that specific stylesheet is not available for other components.<br/><br/>CSS stylesheets are defined as modules in their filename.<br/><br/><span class="code">filename.module.css</span><br/><br/>The naming convention of these stylesheets usually follows that their filename is the same as the component that they are going to be imported into and then used by. So for example if we had a component named <span class="code">talker.js</span> then our CSS module would be named <span class="code">talker.module.css</span><br/><br/>In a similar fashion to importing components for use in React we also need to import the stylesheet for use into the component it will be used in.<br/>So for example in our <span class="code">talker.js</span> module we would need to import the style sheet.<br/><br/><span class="attribute"> import styles from './talker.module.css';</span><br/><br/>The import name can be whatever you want but convention is that you name it <span class="attribute">styles</span>.<br/>Also in a similar fashion to normal CSS you dont need to export anything in the actual CSS file like you do with function components.<br/><br/>Finally to use the styles contained within <span class="code">talker.module.css</span> you use dot notation as the property value of an attribute.<br/>An example of syntax is shown below;<br/><br/>The below code is our styling element contained within <span class="code">talker.module.css</span><br/>Notice how it follows normal CSS naming conventions and syntax because it is a CSS file and not a React file.<br/><span class="attribute">.h1 {<br/>color: red;<br/>background-color: green;<br/>font-size: 40px<br/>}</span><br/><br/>The below code is how we use this in the JSX of our React component.<br/><br/><span class="code">&lt;h1 className=</span><span class="attribute">{styles.h1}</span><span class="code">&gt;Hello World!&lt;/h1&gt;</span><br/><br/></td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div class="container" id="front_end_routing">
            <h2>Front End Routing</h2>
            <p>This section describes how to route in React including notes on usages and correct syntax.</p>
            <table>
                <thead>
                    <tr>
                        <th>Tag/Expression</th>
                        <th>Name</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td></td>
                        <td>Core Concept</td>
                        <td>The core concept of routing in React is to provide front end navigation throughout a single page web app whilst preventing window refreshes. This helps to manage the page state which could be crucial to the operation of the app.<br/><br/>In a traditional web page you would typically provide a navbar that links to multiple different pages. For example you might have an About page, a Contact page etc. and with each nagivational click the page gets refreshed and the user is sent to the page linked.<br/><br/>Routing works by providing the content requested on the same page, it simply replaces the previous content or adds to it.<br/>The best analogy is think of it as an overhead projector. The slide is replaced by another component, the browser is not refreshed but the user is able to move around the app and view their desired content.</td>
                    </tr>
                    <tr>
                        <td><span class="attribute">'react-route-dom'</span></td>
                        <td>Installation</td>
                        <td>In order to use React Router it needs to be installed into the project folder before any methods or functions can be used.<br/><br/>Installation is carried out in the project directory using the command line. The code below will install react router into the project file.<br/><br/><span class="code">npm install --save react-router-dom@6</span><br/><br/></td>
                    </tr>
                    <tr>
                        <td><span class="attribute">RouterProvider</span>,<br/><span class="attribute">createBrowserRouter</span>,<br/><span class="attribute">createRoutesFromElements</span></td>
                        <td>Providing a Router</td>
                        <td>Before we get into how to provide routes we need to tell our App that we want to use routing as a method of displaying content.<br/><br/>To do this we need to import some methods that provide the framework we will be working within. We import the methods in the same way that we import React.<br/>An example of the syntax is shown below;<br/><br/><span class="attribute">import { RouterProvider, createBrowserRouter, createRoutesFromElements } from 'react-router-dom';</span><br/><br/>Below there is a brief explanation of what each method does.<br/><br/><span class="attribute">RouterProvider</span> is best thought of as the rendering component of the React routing framework. In our App component it replaces the JSX we would normally return to be rendered as the web page content. This is because the JSX will be passed into it by <span class="attribute">createBrowserRouter</span><br/><br/><span class="attribute">createBrowserRouter</span> is best thought of as a redirect element that prevents the page from reloading whilst also passing the target content through to the <span class="attribute">RouterProvider</span> for it to be rendered. It needs to be populated with redirect paths but this is explained later.<br/><br/><span class="attribute">createRoutesFromElements</span> is best thought of as a configuration method. It gets passed into <span class="attribute">createBrowserRouter</span> as an argument. Within its own parentheses you then pass JSX elements to be used as the redirect pathways. These pathways will be explained in more detail later but essentially this method configures whatever JSX being passed into it into a readable format for <span class="attribute">createBrowserRouter</span>.<br/>Just as a side note <span class="attribute">createBrowserRouter</span> accepts objects or JSX as input but as explained above the JSX needs to be configured first.<br/><br/>An example of how these 3 elements are typically inserted into a React application is demonstrated below;<br/><br/><span class="attribute">import About from './About.js';<br/>import { RouterProvider, createBrowserRouter, createRoutesFromElements, Route } from 'react-router-dom';<br/><br/>const router = createBrowserRouter(createRoutesFromElements(<br/></span><span class="code">&lt;Route path='/about' element=</span><span class="attribute">{ &lt;About/&gt; }</span><span class="code"> /&gt;</span><span class="attribute"><br/>));<br/><br/>function App () {<br/>return (<br/></span><span class="code">&lt;RouterProvider router=</span><span class="attribute">{ router }</span><span class="code"> /&gt;</span><span class="attribute"><br/>);<br/>}<br/><br/>export default App;</span><br/><br/>In the above example we have a very simple App that demonstrates how we import the methods and how we declare and use them within a React application.<br/>Notice how we define a variable called <span class="attribute">router</span> which contains the methods of <span class="attribute">createBrowserRouter</span> and <span class="attribute">createRoutesFromElements</span>. It also contains a <span class="attribute">Route</span> element that will be explained later but just know that this is what is being routed and ultimately rendered.<br/>Within the <span class="attribute">App</span> function we then have the JSX element of <span class="code">RouterProvider</span> with the attribute of <span class="attribute">router</span> defining the previously declared <span class="attribute">router</span> variable as a property. This enables the rendering of whatever is being redirected to this element by <span class="attribute">createBrowserRouter</span>. It works in the same way as <span class="attribute">props</span> in function components.</td>
                    </tr>
                    <tr>
                        <td><span class="code">&lt;Route&gt;</span></td>
                        <td>Route</td>
                        <td>The <span class="code">&lt;Route&gt;</span> component needs to be imported into the file before it can be used. This is done in the same way as the other methods and components we have imported in previous examples.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">import { Route } from 'react-router-dom';</span><br/><br/>The <span class="code">&lt;Route&gt;</span> component is passed into and populates the <span class="attribute">createRoutesFromElements</span> method. This in turn provides the <span class="code">RouterProvider</span> component with the pathway it needs to find whatever it is that is intending to be rendered to the page.<br/><br/>In order to do this the <span class="code">&lt;Route&gt;</span> component requires 2 attributes.<br/>The <span class="attribute">path</span> attribute that tells the <span class="code">RouterProvider</span> the path location it needs to render.<br/>The <span class="attribute">element</span> attribute which tells the <span class="code">RouterProvider</span> the component that it needs to render.<br/><br/>The <span class="code">&lt;Route&gt;</span> tag can be self closing.<br/>An example of syntax is shown below;<br/><br/><span class="code">&lt;Route path='/about' element=</span><span class="attribute">{ &lt;About/&gt; }</span><span class="code"> /&gt;</span><br/><br/>In many cases, there may be certain components, like sidebars, navigation bars, and footers, that we want to render with every page view. We can achieve this by defining a root-level component that contains layout elements we want to render consistently. We can then nest the rest of our routes within this root-level component. This is done by using a closing tag when defining the <span class="code">&lt;Route&gt;</span>.<br/>An example of this syntax is shown below;<br/><br/><span class="code">&lt;Route path='/' element=</span><span class="attribute">{ &lt;Root/&gt; }</span><span class="code"> &gt;<br/>&lt;Route path='about' element=</span><span class="attribute">{ &lt;About/&gt; }</span><span class="code"> /&gt;<br/>&lt;/Route&gt;</span><br/><br/>Notice how the nested <span class="code">&lt;Route&gt;</span> is defined with a self closing tag and is located inbetween the other <span class="code">&lt;Route&gt;</span> tags.</td>
                    </tr>
                    <tr>
                        <td><span class="code">&lt;Outlet/&gt;</span></td>
                        <td>Outlet</td>
                        <td><span class="code">&lt;Outlet/&gt;</span> must be imported like the previous methods and components before using in our app. Example syntax is shown below;<br/><br/><span class="attribute">import { Outlet } from 'react-router-dom';</span><br/><br/>When using <span class="code">&lt;Route&gt;</span> we tell the code what to redirect and what to render. However we haven't specified where we want the code to be rendered.<br/>For this we need to use the <span class="code">&lt;Outlet/&gt;</span> component.<br/><br/>This is a simple self closing JSX component that should be treated in a similar fashion of a function component.<br/>It should be declared in returned JSX and will effectively act as an outlet for the routed data as the name suggests.<br/><br/>An example of its use is shown below;<br/><br/><span class="attribute">function Root() {<br/>return (</span><span class="code"><br/>&lt;&gt;<br/>&lt;Header/&gt;<br/>&lt;main&gt;<br/><br/>&lt;Outlet/&gt;<br/><br/>&lt;/main&gt;<br/>&lt;Footer/&gt;<br/>&lt;/&gt;<br/>)</span><span class="attribute"><br/>}</span><br/><br/>In the example above we are returning our <span class="code">&lt;Root&gt;</span> component which contains our Navigation elements that we wish to stay constant.<br/>Within our <span class="code">&lt;Root&gt;</span> component we want to render the routed data that will change and update as the user moves around the site. This is where we place the <span class="code">&lt;Outlet/&gt;</span> tag so that the changing content will be rendered here.</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>Nested Routes</td>
                        <td>When nesting routes within one another we need to be careful to ensure the paths are declared properly.<br/><br/>In our first route declaration the path is declared as shown below;<br/><br/><span class="code">&lt;Route path="/" element=</span><span class="attribute">{ &lt;Root/&gt; }</span><span class="code">&gt;</span><br/><br/>The path starts with a <span class="code">/</span> and defines the beginning of the URL pathway.<br/>If we wanted the users to begin on the about page for instance the pathway would be <span class="code">/about</span> however we want to have a <span class="attribute">&lt;Root&gt;</span> component rendered first to create a static navigation starting point for our site.<br/><br/>We can then nest our routes inside of this using the method described previously which would give us some code that looks like the below;<br/><br/><span class="code">&lt;Route path="/" element=</span><span class="attribute">{ &lt;Root/&gt; }</span><span class="code">&gt;<br/>&lt;Route path="articles" element=</span><span class="attribute">{ &lt;Articles/&gt; }</span><span class="code"> /&gt;<br/>&lt;/Route&gt;</span><br/><br/>In the above code we have nested a <span class="code">&lt;Route&gt;</span> to the <span class="attribute">Articles</span> component within the <span class="code">&lt;Root&gt;</span>.<br/>This will generate the URL <span class="attribute">website.com/articles</span><br/><br/>If we wanted to nested a further route we would nest it in the same way as we did above, remembering to add an <span class="code">&lt;Outlet/&gt;</span> tag to the relevant component so it renders the content properly, and we would provide the pathway in the routing.<br/>We could end up something like the below;<br/><br/><span class="code">&lt;Route path="/" element=</span><span class="attribute">{ &lt;Root/&gt; }</span><span class="code">&gt;<br/>&lt;Route path="articles" element=</span><span class="attribute">{ &lt;Articles/&gt; }</span><span class="code">&gt;<br/>&lt;Route path="author" element=</span><span class="attribute">{ &lt;Author/&gt; }</span><span class="code"> /&gt;<br/>&lt;/Route&gt;<br/>&lt;/Route&gt;</span><br/><br/>In the above code we have nested the <span class="attribute">Author</span> component within the <span class="attribute">Articles</span> component which in turn is nested within the <span class="attribute">Root</span> component.<br/>This generates the URL <span class="attribute">website.com/articles/author</span>.<br/>Notice how each nested element doesn't need to be prefixed with a <span class="attribute">/</span> as it is taken care of automatically.</td>
                    </tr>
                    <tr>
                        <td><span class="code">&lt;Link&gt;</span>,<br/><span class="code">&lt;NavLink&gt;</span></td>
                        <td>Linking</td>
                        <td>Both the <span class="code">&lt;Link&gt;</span> and <span class="code">&lt;NavLink&gt;</span> components must be imported into the file before being used.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">import { Link, NavLink } from 'react-router-dom';</span><br/><br/>The purpose of these components is to, essentially, replace the <span class="code">&lt;a&gt;</span> tag used to create hyperlinks within traditional HTML.<br/>Why? The default behaviour of an <span class="code">&lt;a&gt;</span> tag will refresh the browser when the link is clicked. We want to avoid this so that we can create a seamless experience for the user.<br/><br/>The syntax for using both <span class="code">&lt;Link&gt;</span> and <span class="code">&lt;NavLink&gt;</span> tags is basically the same but they differ slightly from the traditional <span class="code">&lt;a&gt;</span> tag.<br/>Instead of defining the path location with the href attribute as you would in the <span class="code">&lt;a&gt;</span> tag we replace this with the new <span class="code">to=""</span> attribute.<br/>An example of syntax is shown below;<br/><br/><span class="code">&lt;Link to="/about"&gt;About&lt;/Link&gt;</span><br/><span class="code">&lt;NavLink to="/about"&gt;About&lt;/NavLink&gt;</span><br/><br/>So, what’s the difference between a <span class="code">&lt;Link&gt;</span> and a <span class="code">&lt;NavLink&gt;</span>? When the URL path matches a <span class="code">&lt;NavLink&gt;</span> component’s <span class="code">to</span> prop, the link will automatically have an <span class="attribute">.active</span> class applied to it. This can be quite useful for building navigation menus, as we can define CSS styles for the <span class="attribute">.active</span> class name to differentiate between active and inactive links, enabling users to quickly see which content they are viewing.<br/><br/>We can also pass a function to <span class="attribute">className</span> to further customize the styling of an active (or inactive) <span class="code">&lt;NavLink&gt;</span><br/><br/><span class="code">&lt;NavLink to="about" <br/>className=</span><span class="attribute">{ ({ isActive }) => isActive? 'activeNavLink' : 'inactiveNavLink'}</span><span class="code"><br/>&gt; About &lt;/NavLink&gt;</span><br/><br/>In the example above we pass a function to the <span class="attribute">className</span> prop which applies the <span class="attribute">.activeNavLink</span> class if the <span class="code">&lt;NavLink&gt;</span> is active and <span class="attribute">.inactiveNavLink</span> if its inactive.</td>
                    </tr>
                    <tr>
                        <td><span class="attribute">path="/articles/:title"</span></td>
                        <td>Dyanmic Linking</td>
                        <td>If we are building a large website that can potentially contain many different pages, having to manually specify each individual route to each individual article or page that we want to display can become extremley time consuming. It will also create a huge amount of code that will inevitably lead to errors and high maintenance.<br/><br/>This is where we can utilise dynamic routing to create a template for routing that will handle all of this automatically without the need for hard coding each path individually.<br/><br/>React router allows us to create dynamic routes using URL parameters.<br/>URL parameters are dynamic segments of a URL that act as placeholders for more specific resources. They appear in a dynamic route as a colon followed by a variable name.<br/>An example is shown below;<br/><br/><span class="code">&lt;Route path='/articles/:title' element=</span><span class="attribute">{ &lt;Article /&gt; }</span><span class="code">/&gt;</span><br/><br/>In the above example the path <span class="code">'/articles/:title'</span> contains the URL parameter <span class="code">:title</span>. This means that when the user navigates to pages such as <span class="code">'/articles/what-is-react'</span> or <span class="code">'/articles/html-and-css'</span> the <span class="attribute">&lt;Article /&gt;</span> component will render.<br/>When the <span class="attribute">&lt;Article /&gt;</span> component is rendered in this way, it can access the actual value of that <span class="code">:title</span> (<span class="code">what-is-react</span> or <span class="code">html-and-css</span>) to determine which article to display.<br/><br/>A practical example is shown below;<br/><br/>Lets say we are creating a news website that has many different articles and we want to use dynamic linking to be able to display those different articles.<br/><br/>In our top level <span class="attributecode">App</span> component we would create our routing framework and include a route to the article component with a dynamic link. This is shown below;<br/><br/><span class="attribute">const router =  createBrowserRouter( createRoutesFromElements(<br/></span><span class="code">&lt;Route path="/" element=</span><span class="attribute">{ &lt;Root/&gt; }</span><span class="code">&gt;<br/>&lt;Route path="articles" element=</span><span class="attribute">{ &lt;Articles/&gt; }</span><span class="code"> /&gt;<br/>&lt;Route path="articles/:title" element=</span><span class="attribute">{ &lt;Article/&gt; }</span><span class="code"> /&gt;<br/>&lt;/Route&gt;</span><span class="attribute"><br/>)<br/>)<br/><br/>function App() {<br/>return (<br/></span><span class="code">&lt;RouterProvider router=</span><span class="attribute">{router}</span><span class="code"> /&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/>Notice how we have our URL parameter of <span class="code">:title</span> defined as the pathway.<br/>In our <span class="attribute">Articles</span> component we have several links to various different articles each with different links.<br/>This is shown below;<br/><br/><span class="code">&lt;h1&gt;Articles&lt;/h1&gt;<br/>&lt;ul&gt;<br/>&lt;li&gt;<br/>&lt;Link to=</span><span class="attribute">{`article_01`}</span><span class="code">&gt;Article 01&lt;/Link&gt;<br/>&lt;Link to=</span><span class="attribute">{`article_02`}</span><span class="code">&gt;Article 02&lt;/Link&gt;<br/>&lt;Link to=</span><span class="attribute">{`article_03`}</span><span class="code">&gt;Article 03&lt;/Link&gt;<br/>&lt;Link to=</span><span class="attribute">{`article_04`}</span><span class="code">&gt;Article 04&lt;/Link&gt;<br/>&lt;/li&gt;<br/>&lt;/ul&gt;</span><br/><br/>Now when we click on an article link, lets say we click on Article 04 for example, the path that is currently routed through as <span class="code">path="/articles/:title"</span> will be altered to read as <span class="code">path="/articles/article_04"</span> this is because the <span class="code">:title</span> operates just like a normal variable.<br/><br/>The above example still shows a lot of hardcoded content in the <span class="attribute">Articles</span> component however, the principles would still work if we had some logic that created links.<br/>Lets say we have some logic that filters through a vast number of articles and we want to only display and provide links to the filtered ones. We can use the same routing method but instead of the hardcoded links as displayed above the links might look something more like the below;<br/><br/><span class="code">&lt;h1&gt;Articles&lt;/h1&gt;<br/>&lt;ul&gt;<br/></span><span class="attribute">{ filteredArticles.map(article =&gt; (<br/>&lt;li key={article.id}&gt;<br/>&lt;Link to={`${article.id}`}&gt;<br/>{article.title}<br/>&lt;/Link&gt;<br/>&lt;/li&gt;<br/>))}</span><span class="code"><br/>&lt;/ul&gt;</span><br/><br/>In the above code we have some logic that maps over a previously created variable called <span class="attribute">filteredArticles</span> that contains objects with various key-value pairings relating to numerous different articles. For our dynamic links to work we don't need to know all of that information we just need to pick out the pathway to that specific article to then feed into our dynamic routing pathway.<br/>As you can see in the code we have targetted a key in the object called <span class="attribute">id</span> whose value will give us the pathway suffix we need to feed into the dynamic route to take the place of the <span class="code">:title</span> URL parameter.<br/><br/>In this logic we use a template literal within the <span class="code">Link</span> that uses the value gained from <span class="attribute">id</span> to provide the relevant pathway.<br/><br/>This is very powerful because this small amount of logic allows us to potentially provide dynamic routing links to hundreds of different articles without needing to hard code the pathway to each one.</td>
                    </tr>
                    <tr>
                        <td><span class="attribute">useParams</span></td>
                        <td>URL Parameters</td>
                        <td><span class="attribute">useParams</span> must be imported like the previous methods and components before using in our app. Example syntax is shown below;<br/><br/><span class="attribute">import { useParams } from 'react-router-dom';</span><br/><br/>In the previous note about Dynamic linking we created dynamic routes using URL parameters (placeholder variables included in the URL path defined by prefixing with a colon).<br/>We can use the <span class="attribute">useParams</span> hook from React Router to access these placeholder variables to use the data contained within them for other elements of our webpage.<br/><br/><span class="attribute">function Article() {<br/><br/>let { title } = useParams();<br/><br/>return (</span><span class="code"><br/>&lt;article&gt;<br/>&lt;h1&gt;</span><span class="attribute">{title}</span><span class="code">&lt;/h1&gt;<br/>&lt;/article&gt;</span><span class="attribute"><br/>);<br/>}</span><br/><br/>In the above example we use the <span class="attribute">useParams()</span> hook to extract the <span class="code">:title</span> URL parameter from the active route. This is stored in a variable within the <span class="attribute">Article</span> function using destructuring syntax. It is then referenced between the <span class="code">&lt;h1&gt;</span> tags to provide a title on the page.<br/><br/>The content is obviously situation dependent however if we are using routing as we did in the previous excercise where we are dealing with many different potential articles and such then the <span class="attribute">useParams</span> hook can be a useful way to extract information for other uses in our code.</td>
                    </tr>
                    <tr>
                        <td><span class="attribute">Navigate</span></td>
                        <td>Navigate</td>
                        <td><span class="attribute">Navigate</span> must be imported like the previous methods and components before using in our app. Example syntax is shown below;<br/><br/><span class="attribute">import { Navigate } from 'react-router-dom';</span><br/><br/>The <span class="attribute">Navigate</span> component is essentially a redirect element that we can insert into various scenarios.<br/>It is a self closing tag that has a <span class="code">to=""</span> parameter contained within.<br/><br/>We can insert the <span class="attribute">Navigate</span> component into various sections of logic to create redirect actions as needed.<br/>An example of it in use is shown below;<br/><br/><span class="attribute">import { Navigate } from 'react-router-dom';<br/><br/>const UserProfile = ({ loggedIn }) =&gt; {<br/>if (!loggedIn) {<br/>return (</span><span class="code"><br/>&lt;Navigate to='/Login' /&gt;</span><span class="attribute"><br/>)<br/>}<br/><br/>return (<br/>// ... additional function content here<br/>)<br/>}</span><br/><br/>In the code above we have a function that accepts a destructured parameter as its argument.<br/>It immediately checks to see if the argument returns a truthy or falsey value, in this case its checking if the user is logged in or not.<br/>If the check returns a falsey value then the logic runs the <span class="attribute">Navigate</span> component which redirects the user to the Login page as defined in the <span class="attribute">Navigate</span> components attributes.</td>
                    </tr>
                    <tr>
                        <td><span class="attribute">useNavigate</span></td>
                        <td>useNavigate</td>
                        <td><span class="attribute">useNavigate</span> must be imported like the previous methods and components before using in our app. Example syntax is shown below;<br/><br/><span class="attribute">import { useNavigate } from 'react-router-dom';</span><br/><br/>The <span class="attribute">Navigate</span> component described above redirects declaratively by rendering a <span class="attribute">Navigate</span> component that updates the browser's location.<br/>Though this approach follows React Router’s declarative coding style, it does introduce a few extra steps in the React rendering lifecycle: The <span class="attribute">Navigate</span> component must be returned, it is then rendered, the URL is updated and then finally the appropriate route is rendered.<br/><br/>React Router also provides a mechanism for updating the browser’s location imperatively using the <span class="attribute">useNavigate</span> hook.<br/><br/>The <span class="attribute">useNavigate</span> function returns a <span class="attribute">navigate</span> function that allows us to specify a path where we’d like to navigate.<br/>The example below shows how the function redirects the user back to the root after a user successfully submits a <span class="code">&lt;form&gt;</span>.<br/><br/><span class="attribute"><br/>export const ExampleForm = () => {<br/><br/>const navigate = useNavigate()<br/><br/>const handleSubmit = e => {<br/>e.preventDefault();<br/>navigate('/')<br/>}<br/><br/>return (</span><span class="code"><br/>&lt;form onSubmit=</span><span class="attribute">{handleSubmit}</span><span class="code">&gt;<br/>// form elements<br/>&lt;/form&gt;</span><span class="attribute"><br/>)<br/>}</span><br/><br/>The <span class="attribute">useNavigate()</span> function also gives us the ability to programmatically navigate our users through their history stack. Scenarios like enabling users to go forward or backward in an application, or redirecting users to their previous page after they’ve logged in, are great use cases for this functionality. To navigate a user through their history stack using <span class="attribute">useNavigate()</span>, we’d pass in an integer to indicate where in the history we’d like to travel. A positive integer navigates forward and a negative integer navigates backward.<br/>An example of this in a practical application is shown below;<br/><br/><span class="attribute">const BackButton = () => {<br/>const navigate = useNavigate()<br/><br/>return (</span><span class="code"><br/>&lt;button onClick=</span><span class="attribute">{() => navigate(-1)}</span><span class="code">&gt;<br/>Go Back<br/>&lt;/button&gt;</span><span class="attribute"><br/>)<br/>}</span><br/><br/>Larger integers can be used to provide larger steps in navigation for example <span class="attribute">() => navigate(3)</span> would result in moving forward 3 times in the history stack.</td>
                    </tr>
                    <tr>
                        <td><span class="attribute">useSearchParams</span></td>
                        <td>Query Parameters</td>
                        <td><span class="attribute">useSearchParams</span> must be imported like the previous methods and components before using in our app. Example syntax is shown below;<br/><br/><span class="attribute">import { useSearchParams } from 'react-router-dom';</span><br/><br/>Query parameters appear in URLs beginning with a question mark (?) and are followed by a parameter name assigned to a value. They are optional and are most often used to search, sort and/or filter resources.<br/>An example is shown below;<br/><br/><span class="code">https://www.google.com/search?q=tottenham</span><br/><br/>The URL above directs the user to Google's <span class="code">/search</span> page displaying the results for the search term "tottenham". In this example the name of the query parameter is <span class="code">q</span>.<br/><br/>The <span class="attribute">useSearchParams()</span> hook enables us to get these query parameters for use in our application. The hook itself returns a <span class="attribute">URLSearchParams</span> object and a function we can use to update it.<br/><br/><span class="attribute">// Rendered when a user visits "/list?order=DESC"<br/><br/>export const SortedList = (numberList) => {<br/>const [ searchParams, setSearchParams ] = useSearchParams();<br/>const sortOrder = searchParams.get('order');<br/>console.log(sortOrder); // Prints "DESC"<br/>};</span><br/><br/>In the example above we import <span class="attribute">useSearchParams()</span> and call it within <span class="attribute">SortedList</span> to get the <span class="attribute">URLSearchParams</span> object. This object has a <span class="attribute">.get()</span> method for retrieving query parameter values.<br/>Finally, to get the value of a specific query parameter, we pass in the name of the query parameter whose value we want to obtain, as a string (<span class="attribute">'order'</span>), to the <span class="attribute">searchParams.get()</span> method. The value (<span class="attribute">'DESC'</span>) is then stored in the variable <span class="attribute">sortOrder</span>.<br/><br/>Utilising this method we can then use the query parameters within conditional statement logic to determine various things within our application.<br/>An example is shown below;<br/><br/><span class="attribute">//Rendered when a user visits "/list"<br/><br/>const SortedList = (numberList) => {<br/>const [ searchParams, setSearchParams ] = useSearchParams();<br/>const sortOrder = searchParams.get('order');<br/><br/>//other bits of function logic and return statements etc...<br/><br/>if (sortOrder === 'ASC') {<br/>// render the numberList in ascending order<br/>} else if (sortOrder === 'DESC') {<br/>// render the numberList in descending order<br/>} else {<br/>// render the numberList as is<br/>}<br/>}</span><br/><br/>Following on from this we can use logic to alter the query parameters by utilising the <span class="attribute">setSearchParams</span> method.<br/><br/>Imagine we have a <span class="code">&lt;List&gt;</span> component with a sort button that we wanted to use to update the URL to <span class="code">/list?order=ASC</span>, then render <span class="attribute">SortedList</span>. We can use the <span class="attribute">setSearchParams()</span> function to do this.<br/>An example is shown blelow;<br/><br/><span class="attribute">// Rendered when a user visits "/list"<br/>const List = (numberList) => {<br/>const [ searchParams, setSearchParams ] = useSearchParams();<br/><br/>//other bits of function logic and return statements etc...<br/><br/>// render the numberList in ascending order<br/></span><span class="code">&lt;button click=</span><span class="attribute">{ () => setSearchParams( {order: 'ASC'} ) }</span><span class="code">&gt;<br/>Sort<br/>&lt;/button&gt;</span><span class="attribute"><br/>}</span><br/><br/>When a user clicks on the Sort button we’ll update the path to <span class="code">/list?order=ASC</span>, which will cause our <span class="attribute">SortedList</span> component to render.</td>
                    </tr>
                    <tr>
                        <td><span class="attribute">createSearchParams</span></td>
                        <td>Create Query Parameters</td>
                        <td><span class="attribute">createSearchParams</span> must be imported like the previous methods and components before using in our app. Example syntax is shown below;<br/><br/><span class="attribute">import { createSearchParams } from 'react-router-dom';</span><br/><br/><span class="attribute">useSearchParams</span> works great when we want to access the current path’s query parameters or alter them but what if we want to navigate to a path and include query parameters too? Well, for this scenario we’ll need to use the <span class="attribute">createSearchParams()</span> utility function from <span class="attribute">react-router-dom</span> with the <span class="attribute">useNavigate</span> hook.<br/><br/>For example, if we wanted to directly navigate to <span class="code">/list?order=ASC</span> from the root (<span class="attribute">/</span>) path we’d do something like this;<br/><br/><span class="attribute">import { useNavigate, createSearchParams } from 'react-router-dom';<br/>// get navigate function<br/>const navigate = useNavigate();<br/><br/>// define an object where the key is is the query parameter name and value is query parameter value<br/>const searchQueryParams = {<br/>order: 'ASC'<br/>}<br/><br/>// use createSearchParams which takes an object and transforms it to a query string of the form order=ASC<br/>const searchQueryString = createSearchParams(searchQueryParams);<br/><br/>// force a navigate by passing in an object with pathname indicating that path to navigate and search indicating the query parameters to append<br/>navigate({<br/>pathname:'/list',<br/>search: `?${searchQueryString}`<br/>})</span><br/><br/>The important things to note about the example above are that we define an object representing the query parameters we want and call it <span class="attribute">searchQueryParams</span>.<br/>Then we pass <span class="attribute">searchQueryParams</span> to <span class="attribute">createSearchParams</span> which will transform it from an object to a query string form.<br/>Then we call <span class="attribute">useNavigate</span> and pass an object with <span class="attribute">pathname</span> and <span class="attribute">search</span> keys where <span class="attribute">pathname</span> is a string indicating where to navigate to and <span class="attribute">search</span> is a string indicating the query string to append to the path.<br/>Note that we need to include the <span class="attribute">?</span> which is why we use a template literal string here.</td>
                    </tr>
                </tbody>
            </table>
        </div>

            <p>For additional tags and examples see the <a href="https://react.dev/reference/react" target="_blank">React Website</a> for more info.</p>
        </div>
    </body>
    <footer>

    </footer>
</html>