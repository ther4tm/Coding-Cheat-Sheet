<!DOCTYPE html>
<html>
    <head>
        <title>Node.js Cheat Sheet</title>
        <link href="./resources/css/index.css" type="text/css" rel="stylesheet">
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link rel="preconnect" href="https://fonts.googleapis.com">
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
    </head>
    <body>
        <header>
            <nav>
                <div class="dropdown">
                    <button class="dropdownBtn">Front End</button>
                    <div class="dropdownContent">
                        <a href="./htmlcheatsheet.html">HTML</a>
                        <a href="./csscheatsheet.html">CSS</a>
                        <a href="./javascriptcheatsheet.html">JavaScript</a>
                        <a href="./reactcheatsheet.html">React</a>
                        <a href="./reduxcheatsheet.html">Redux</a>
                    </div>
                </div>
                <div class="dropdown">
                    <button class="dropdownBtn">Back End</button>
                    <div class="dropdownContent">
                        <a href="./nodecheatsheet.html">Node.js</a>
                    </div>
                </div>
                <div class="dropdown">
                    <button class="dropdownBtn">Other</button>
                    <div class="dropdownContent">
                        <a href="./commandlinecheatsheet.html">Command Line</a>
                        <a href="./markdowncheatsheet.html">Markdown</a>
                        <a href="./styleguide.html">Style Guide</a>
                    </div>
                </div>
            </nav>
        </header>
        <div class="content">
            <h1>Node.js Cheat Sheet</h1>
            <p>Below is a list of commands, methods and fundamental principles regarding the Node.js runtime including a brief description of what they do and any notes on correct syntax.</p>
            <div id="fundamentals">
                <h2>Fundamentals</h2>
                <p>This section describes some fundamental properties of the Node.js runtime.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">node</span></td>
                            <td>Node REPL</td>
                            <td>When installed, Node comes with a built in Javascript REPL that can be accessed by typing <span class="attribute">node</span> into the terminal and pressing enter.<br><br/>The node Read Eval Print Loop (REPL) is a programme that can read, evaluate and then print its evaluation to the console.<br/>By default you begin an evaluation of the input by pressing enter, therefore giving the appearance of the REPL being a single line programme, however it can evaluate multiple lines by entering editor mode.<br/>While in the REPL type in <span class="attribute">.editor</span> and then the enter button acts a return element allowing for multi line input. To evaluate multi line input you need to press <span class="attribute">ctrl + d</span>.<br/><br/>This is useful for many things including performing calculations or developing code.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">global</span></td>
                            <td>Node global object</td>
                            <td>The node environment contains many node specific global elements in addition to those built in Javascript as a language. These elements can all be accessed within the node <span class="attribute">global</span> object.<br/>To see all of these you could simply type <span class="attribute">console.log(global)</span><br/><br/>This object contains many different properties and methods that can be used in many different ways.<br/>remember that its also simply a javascript object so these keys can all be accessed using standard dot notation such as:<br/><span class="attribute">global.exampleKey</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">node exampleProgramme.js</span></td>
                            <td>Running a programme with node</td>
                            <td>Node allows for Javascript programmes to be run outside of the browser environment and negates the need for them to be embedded into HTML.<br/><br/>So for example, you could write a simple Javascript arithmetic programme that adds the values of 2 variables together to get an answer. To run this without Node you would need to wrap this into HTML in order for it to be executed and have the answer computed. It's a lot of extra coding.<br/><br/>The Node environment allows us to execute a programme without having to embed it.<br/>In the terminal we simply enter the Node environment (by typing <span class="attribute">node</span>) and then enter the file name we wish to execute.<br/><br/><span class="attribute">node exampleProgramme.js</span><br/><br/>One thing to bear in mind here is that we need to be aware of our location in the file system, the file name to be executed will only be whatever directory you are in within the terminal, so if you wanted to execute a file in another folder from the one you are in within terminal you would need to enter the rest of its location parameters (for example something like <span class="attribute">/users/documents/exampleFile.js</span>)</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">require()</span></td>
                            <td>Requiring in other modules</td>
                            <td>Node's global module contains some key elements that are always accessible throughout the programme however, it also contains many other useful modules that are not 'loaded' in by default.<br/>To access these other modules we need to bring them into the programme using the <span class="attribute">require()</span> function.<br/>The syntax for this is the same as defining a variable.<br/><br/><span class="attribute">const events = require('events');</span><br/><br/>You simply add in the module as a string within the require parentheses.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="core_modules">
                <h2>Core Modules</h2>
                <p>This section describes some properties of various core modules within Node.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">require('module').builtinModules</span></td>
                            <td>The Core modules</td>
                            <td>Node.js has several core modules, some of these are global and are accessible straight away while others need to be required in before use.<br/><br/>To see a full list of these modules make sure you are in the node environment by typing <span class="attribute">node</span> followed by <span class="attribute">require('module').builtinModules</span>. This will then display a list of all the core modules.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">console</span></td>
                            <td>The Console module</td>
                            <td>The Console module is a global module within node and can be accessed without the need to be required in first.<br/><br/>The most common method used with this module is the <span class="attribute">.log()</span> method. This is used to print whatever is within the parentheses to the terminal.<br/><br/>The <span class="attribute">.assert()</span> method prints a message to the terminal if the value within the parentheses is falsey. This can quickly check on the truthy or falsey nature of something.<br/><br/>The <span class="attribute">.table()</span> method prints out a table in the terminal based on whatever array or object is enclosed within the parentheses. This is a easy visual way to see the hierarchy of an object or array.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">process</span></td>
                            <td>The Process module</td>
                            <td>The process module is also a global module within node and can be accessed without the need to be required in first.<br/><br/>This module has tools for evaluating the current process, things like assessing the memory usage, the development phase or the file location.<br/><br/>The <span class="attribute">process.env</span> property is an object which stores and controls information about the environment in which the process is currently running. For example, the <span class="attribute">process.env</span> object contains a <span class="attribute">PWD</span> property which holds a string with the directory in which the current process is located. It can be useful to have some if/else logic in a program depending on the current environment.<br/>For example, a web application in a development phase might perform different tasks than when it’s live to users. We could store this information on the <span class="attribute">process.env</span>.<br/>A common convention is to add a property to <span class="attribute">process.env</span> with the key <span class="attribute">NODE_ENV</span> and a value of either production or development.<br/> This is done in the same way that Javascript objects are amended, if a key does not exist it will be created and if it exists it will be mutated.<br/>So we could write <span class="attribute">process.env.NODE_ENV = 'development';</span> which will then create the <span class="attribute">NODE_ENV</span> key and assign it the property of <span class="attribute">'development'</span>. We can then apply some if/else logic to something that we are working on in the background as a quick check against development or production deployment.<br/>For example;<br/><span class="attribute">if (process.env.NODE_ENV === 'development'){<br/>console.log('Testing! Testing! Does everything work?');<br/>}</span><br/><br/>The <span class="attribute">.memoryUsage()</span> method returns information on the CPU demands of the current process in the form of an object. The object looks like the following;<br/><br/><span class="attribute">{ rss: 26247168,<br/>heapTotal: 5767168,<br/>heapUsed: 3573032,<br/>external: 8772 }</span><br/><br/>The values of the properties will differ however we can use this information to assess CPU usage.<br/><br/><span class="attribute">process.argv</span> holds an array of command line values.<br/>This means that whatever we type into the command line can then be used back in whatever programme we are executing.<br/>For example if we have a javascript file (app.js) that simply has the line <span class="attribute">console.log(process.argv[3]);</span>, if we type into the command line <span class="attribute">node app.js testing feature</span> the following will happen;<br/>node will execute the file app.js which in turn runs the <span class="attribute">console.log()</span> method which logs the 3rd index item to the terminal found with the <span class="attribute">process.argv</span> method contained within its parentheses. the 3rd index item refers to the 4th word written in the command line which is held in the <span class="attribute">process.argv</span> array. This means the word feature will be printed to the terminal.<br/><br/>There are additional methods for this module which are explained in greater depth <a href="https://nodejs.org/api/process.html" target="_blank">here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">os</span></td>
                            <td>The Os module</td>
                            <td>The os module is not a global module and therefore needs to be required in before use.<br/><br/><span class="attribute">const os = require('os');</span><br/><br/>The os module allows for information about the computer, operating system and network to be retrieved when debugging/developing an app.<br/><br/><span class="attribute">os.type()</span> returns information about the computer's operating system.<br/><br/><span class="attribute">os.arch()</span> returns information about the computer's CPU architecture.<br/><br/><span class="attribute">os.networkInterfaces()</span> returns information about the computer's network interfaces such as IP and MAC addresses.<br/><br/><span class="attribute">os.homedir()</span> returns information about the current user's home directory.<br/><br/><span class="attribute">os.hostname()</span> returns the hostname of the operating system.<br/><br/><span class="attribute">os.uptime()</span> returns the length of time, in seconds, since the computer was last rebooted.<br/><br/>An example of how we might utilize this would be as follows;<br/><br/><span class="attribute">const local = {<br/>'Home Directory': os.homedir(),<br/>'Operating System': os.type(),<br/>'Last Reboot': os.uptime()<br/>}</span><br/><br/>When logged to the console, this could return an object that looked something like;<br/><br/><span class="attribute">{<br/>'Home Directory': '/Users/dave',<br/>'Operating System': 'Windows_NT',<br/>'Time since reboot': 94973.12<br/>}</span><br/><br/>There are additional methods for this module which are explained in greater depth <a href="https://nodejs.org/api/os.html" target="_blank">here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">util</span></td>
                            <td>The Util module</td>
                            <td>The util module is also not a global module and therefore needs to be required in before use.<br/><br/><span class="attribute">const util = require('util');</span><br/><br/>The util module is focused on providing utility based methods and objects for debugging and code maintenance.<br/><br/>One important object is <span class="attribute">.types</span> which contains many different methods that can be used to check truthy or falsey values.<br/>For example we could have 2 different variables defined in our file, one that contains a valid date object and another that contains a date written out as a string. We could then use the <span class="attribute">.types</span> object appended with the <span class="attribute">.isDate()</span> method to check the truthy or falsey-ness of those variables in the following way;<br/><span class="attribute">console.log(util.types.isDate(dateObject))<br/>console.log(util.types.isDate(string))</span><br/>The result would print true for the date object and false for the string to the terminal.<br/><br/>There are additional methods for this module which are explained in greater depth <a href="https://nodejs.org/api/util.html" target="_blank">here</a></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="essential_modules">
                <h2>Essential Modules</h2>
                <p>This section describes some properties of various other essential modules within Node.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">events</span></td>
                            <td>The Events module</td>
                            <td>The events module is not a global module and therefore needs to be required in before use.<br/><br/><span class="attribute">const events = require('events');</span><br/><br/>The events module is focused on providing methods that provide functionality on the back end for when there is no set time frame or determined point of them triggering. On the front end we doing this with things like onClick events and the like.<br/><br/>An example of this in action would be if we wanted to trigger a welcome message to someone who just created a new user account with our website.<br/><br/>In our Javascript file (app.js) we <span class="attribute">require</span> in the <span class="attribute">events</span> module at the top and then create a new emitter variable using one of the built in methods in the events module.<br/>It would look like the following;<br/><span class="attribute">let myEmitter = new events.EventEmitter();</span><br/>Notice how we include the keyword <span class="attribute">new</span>, this is because the <span class="attribute">.EventEmitter()</span> method is a <span class="attribute">class</span> which creates new instances when invoked. This means we can make multiple emitters in the same file to listen out for different events.<br/><br/>Because <span class="attribute">.EventEmitter()</span> is a class it means our new variable <span class="attribute">myEmitter</span> also has the methods <span class="attribute">.on()</span> and <span class="attribute">.emit()</span>.<br/>The <span class="attribute">.on()</span> method is the listener portion in a similar way to <span class="attribute">onClick</span>. It takes 2 arguments, the first is the name of the event in string form and the second argument is a listener callback function (This is basically what you want it to do when it hears the event).<br/>The <span class="attribute">.emit()</span> method is the announcement or the 'click' of an onClick event. This also takes 2 arguments. The first is the name of the event in string form so it can match up with the listener, the second argument is essentially the payload, also in string form. This is what will be passed into the listener callback function to be processed.<br/><br/>So in our example we have an emitter (<span class="attribute">myEmitter</span>), lets create a simple callback function the prints a welcome message to the terminal when is is invoked.<br/><span class="attribute">let welcomeNewUser = (data) => {<br/>console.log(`Welcome to the group ${data}!`);<br/>};</span><br/>Then lets create our listener and announcer;<br/><span class="attribute">myEmitter.on('new user', welcomeNewUser);<br/>myEmitter.emit('new user', 'Dave');</span><br/><br/>Now our listener and callback functions are all set up when we run this in node by typing <span class="attribute">node app.js</span> into the terminal we should receive a message back that says 'Welcome to the group Dave!'.<br/><br/>In our example Dave is just a placeholder and would likely be replaced by some sort of user input however for this example it helps to explain the chain of events.<br/>The emitter is invoked with the event name ('new user') and the user input ('Dave'), the listener matches the event ('new user') and fires off the call back function (<span class="attribute">welcomeNewUser</span>) with the payload of 'Dave' from the emitter.<br/>The template literal of <span class="attribute">${data}</span> in the callback function is replaced with the payload of 'Dave' and prints the full message to the terminal.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">process.stdout.write()<br/>process.stdin.on()</span></td>
                            <td>User input and output</td>
                            <td>User input is any kind of data provided to the computer and output is any data or feedback provided by the computer.<br/>For example the <span class="attribute">console.log()</span> method prompts an output from the computer.<br/><br/>In the node environment the <span class="attribute">console.log()</span> method is essentially a thin container on a built in method of the <span class="attribute">process</span> global module. This method is actually <span class="attribute">process.stdout.write()</span> where <span class="attribute">stdout</span> stands for standard output.<br/>One point to note here also is that <span class="attribute">process.stdout.write()</span> does not handles numbers, its only buffer and strings. If you want to write a number the <span class="attribute">console.log()</span> method handles all types.<br/><br/>In node input can be received from a user through the terminal using <span class="attribute">process.stdin.on()</span>.<br/>This <span class="attribute">.on()</span> method is the same method described in the <span class="attribute">events</span> module. It should receive the name of the event ('data') and then the listener callback function.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">error</span></td>
                            <td>The Errors module</td>
                            <td>The error module is a global module and can be accessed without the need to be required in.<br/><br/>Node contains all of the same errors as Javascript <span class="attribute">EvalError</span>, <span class="attribute">SyntaxError</span>, <span class="attribute">RangeError</span>, <span class="attribute">ReferenceError</span>, <span class="attribute">TypeError</span>, <span class="attribute">URIError</span> and <span class="attribute">Error</span> (The custom error instance).<br/><br/>In synchronous code error handling techniques such as try and catch statements can be used, however when using asynchronous code these try and catch statements will not catch the error correctly. In this instance an error first callback function is more commonly used.<br/><br/>An example of how this might work is shown below;<br/><br/>Lets say we have an API that looks like the following;<br/><br/><span class="attribute">errorProneAsyncApi: (input, callback) => {<br/>console.log(`Running errorProneAsyncApi with input: ${input}...\n`)<br/>setTimeout(() => {<br/>let myErr;<br/>if (input === 'problematic input') {<br/>myErr = new Error('whoops')<br/>callback(myErr)<br/>} else {<br/>let responseData = `Received valid input "${input}"`<br/>callback(myErr, responseData)<br/>}<br/>}, 0)<br/>}</span><br/><br/>And we have an app which looks like the following;<br/><br/><span class="attribute">const api = require('./api.js');<br/><br/>let errorFirstCallback = (err, data) => {<br/>if (err) {<br/>console.log(`Something went wrong. ${err}\n`);<br/>} else {<br/>console.log(`Something went right. Data: ${data}\n`);<br/>}<br/>};<br/><br/>api.errorProneAsyncApi('problematic input', errorFirstCallback);</span><br/><br/>In our app we require in the API at the top, state our error first callback function and then at the bottom we call the API with the 'problematic input' and our error first callback function.<br/>The API is written to throw an error on the matching input value of 'problematic input' but it is our callback function that does an if/else check for errors first that spots this before it allows the code to progress.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">buffer</span></td>
                            <td>The Buffer module</td>
                            <td>The buffer module is also a global module and can be accessed without the need to be required in.<br/><br/>In Node, the <span class="attribute">buffer</span> module is used to handle binary data. A <span class="attribute">buffer</span> object represents a fixed amount of memory that cannot be resized, they are similar to an array of integers in that each element in the array represents a byte of data. The buffer object can have a range of integers from 0 to 255.<br/><br/>There are a few important methods in the <span class="attribute">buffer</span> module to be aware of, the first is <span class="attribute">.alloc()</span>.<br/>This creates a new <span class="attribute">buffer</span> object with the first argument required and the other 2 arguments being optional includes.<br/>The first argument is the size of the buffer in numerical format.<br/>The second argument is what to fill the buffer with. The default value is 0.<br/>The third argument is the type of encoding, the default being UTF-8.<br/>An example of the syntax is shown below;<br/><br/><span class="attribute">const buffer = Buffer.alloc(5, 'a');<br/>console.log(buffer);<br/>//Output: [97, 97, 97, 97, 97]</span><br/>Notice how the output is not the letter a but the UTF-8 code for the letter a which is 97.<br/><br/>The next method is <span class="attribute">.toString()</span>.<br/>This method translates <span class="attribute">buffer</span> objects into human readable format..<br/>It has 3 optional arguments.<br/>The first is the type of encoding, the default is UTF-8.<br/>The second argument is the index offset from when you wish to begin translation. The default is 0. If you want to being translation at the 3rd element in a 5 element long object you could define this argument as 2.<br/>The third argument is when you wish to stop translation. The default is the total length of the buffer. As with the previous argument you could define this as another index to stop translation early if required.<br/>An example of the syntax and effect is as shown below;<br/><br/><span class="attribute">const buffer = Buffer.alloc(5, 'a');<br/>console.log(buffer.toString());<br/>//Output: [a, a, a, a, a]</span><br/>Notice how this time the output is the letter a rather than the UTF-8 code.<br/><br/>The next method if <span class="attribute">.from()</span>.<br/>This creates a new <span class="attribute">buffer</span> from a string, array or another buffer.<br/>This accepts 2 arguments. The first is required and it is either a string, array or buffer from which to create a buffer from.<br/>The second argument is the encoding type, the default is UTF-8.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const buffer = Buffer.from('hello');<br/>console.log(buffer);<br/>//Output: [104, 101, 108, 108, 111]</span><br/>Notice how the output is the UTF-8 encoded version of the word 'hello'.<br/><br/>The final method is <span class="attribute">.concat()</span>.<br/>This joins all buffer objects passed in an array into one <span class="attribute">buffer</span> object. This is particularly useful because a buffer object cannot be resized.<br/>This method accepts 2 arguments, the first is required and it is an array from which to create the new buffer object from.<br/>The second argument is length, this specifies the length of the concatenated buffer.<br/>An example of syntax is shown below;<br/><br/><span class="attribute">const buffer1 = Buffer.from('hello');<br/>const buffer2 = Buffer.from('world');<br/>const array = [buffer1, buffer2];<br/>const bufferConcat = Buffer.concat(array);<br/><br/>console.log(bufferConcat);<br/>//Output: [104, 101, 108, 108, 111, 119, 111, 114, 108, 100]</span><br/>Notice how the output is the UTF-8 encoded version of 'helloworld', if we added a <span class="attribute">.toString()</span> method onto the end of <span class="attribute">bufferConcat</span> in the <span class="attribute">console.log()</span> it would output 'helloworld' instead.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">fs</span></td>
                            <td>The FS module</td>
                            <td>The FS module is not a global module and therefore it must be required in before it can be used.<br/><br/><span class="attribute">const fs = require('fs');</span><br/><br/>All of the data on a computer is organized and accessed through a filesystem. When running JavaScript code on a browser, it’s important for a script to have only limited access to a user’s filesystem. This technique of isolating some applications from others is known as sandboxing. Sandboxing protects users from malicious programs and invasions of privacy.<br/>In the back-end, however, less restricted interaction with the filesystem is essential. The Node <span class="attribute">fs</span></span> core module is an API for interacting with the file system. It was modeled after the POSIX standard for interacting with the filesystem.<br/>Each method available through the <span class="attribute">fs</span> module has a synchronous version and an asynchronous version. One method available on the <span class="attribute">fs</span> core module is the <span class="attribute">.readFile()</span> method which reads data from a provided file.<br/><br/>An example of syntax and application is shown below;<br/><br/><span class="attribute">const fs = require('fs');<br/><br/>let readDataCallback = (err, data) => {<br/>if (err) {<br/>console.log(`Something went wrong: ${err}`);<br/>} else {<br/>console.log(`Provided file contained: ${data}`);<br/>}<br/>};<br/><br/>fs.readFile('./file.txt', 'utf-8', readDataCallback);</span><br/><br/>In the example above the <span class="attribute">fs</span> module is required in.<br/>We define an error first callback function.<br/>The then invoked the <span class="attribute">.readFile()</span> on the <span class="attribute">fs</span> object with 3 arguments, the first is the file we want it to access and read, the 2nd is the encoding type and the 3rd is the callback function we want it all to be processed through.<br/>The result is that the contents of the file will be evaluated by the module and displayed in the terminal as a result of the <span class="attribute">console.log()</span> method in the callback function.<br/><br/>There are additional methods for this module which are explained in greater depth <a href="https://nodejs.org/api/fs.html" target="_blank">here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">readline</span></td>
                            <td>The Readline module</td>
                            <td>The readline module is not a global module and therefore it must be required in before it can be used.<br/><br/><span class="attribute">const readline = require('readline');</span><br/><br/>There are numerous methods for this module which are explained in greater depth <a href="https://nodejs.org/api/readline.html" target="_blank">here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.createInterface()</span> & <span class="attribute">.createReadStream()</span></td>
                            <td>Readable Streams</td>
                            <td>The previous <span class="attribute">fs</span> module gave an example of reading an entire file. However, reading an entire file requires processing and therefore increased RAM. In simple scenarios this isn't so much of an issue but once we begin to process increasingly complex files and their subsequent data, the required RAM can become a choke point that will slow the whole thing down.<br/>Instead of processing the entire file in bulk, a more efficient method is to stream the data. Streaming allows the data to be processed piece by piece instead of en mass.<br/>A simple use of streaming is the reading and writing of files line-by-line. This allows each line of code to be processed one by one, methodically working through the entire file.<br/><br/>An example of this is shown below;<br/><br/>In this example we have a file that contains a shopping list (<span class="attribute">shoppingList.txt</span>) with individual items on the list each occupying a separate line.<br/>In our javascript file we require in the <span class="attribute">readline</span> and <span class="attribute">fs</span> modules at the top.<br/><br/><span class="attribute">const readline = require('readline');<br/>const fs = require('fs');</span><br/><br/>Underneath this we create a new variable. This variable invokes a <span class="attribute">readline</span> method called <span class="attribute">createInterface()</span>. Within this method we create an object with the key <span class="attribute">input</span> that has the property of the <span class="attribute">fs</span> method called <span class="attribute">createReadStream()</span>.<br/>This what creates the stream.<br/><br/><span class="attribute">const myInterface = readline.createInterface({<br/>input: fs.createReadStream('shoppingList.txt')<br/>});</span><br/><br/>Notice how within the stream method we define the file that we wish to stream, in our case this is the <span class="attribute">shoppingList.txt</span> file.<br/><br/>Now at the minute in this example we have a stream but it is not doing anything.<br/>We want to print each individual item on the shopping list to the console prefixed by another piece of text so that we can see the items on our shopping list.<br/>To do this we need to create a listener callback function that will trigger every time a line is processed.<br/><br/><span class="attribute">const printData = (data) => {<br/>console.log(`Item: ${data}`);<br/>};</span><br/><br/>Now that we have a listener callback function, which operates as the 'do this action' part of our programme, we need to define our listener that will fire off the callback function when the relevant event happens.<br/><br/>These work in the exact same way as the listener and emitter examples above. The stream emits a <span class="attribute">'line'</span> event after each line is read by the stream meaning that our listener should have the argument <span class="attribute">'line'</span> as its first argument and the listener callback function we just defined as the second argument.<br/><br/>Following that logic, after each <span class="attribute">'line'</span> has been processed by the stream our callback function will <span class="attribute">console.log()</span> the data and print it to the terminal.<br/>It should look something like the below;<br/><br/><span class="attribute">myInterface.on('line', printData);</span><br/><br/>Now when we type <span class="attribute">node app.js</span> into our terminal we should get a shopping list printed out line by line that would look something like;<br/><br/><span class="attribute">Item: Apples<br/>Item: Shampoo<br/>Item: Bread<br/>Item: Milk<br/>Item: Toothpaste</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.createWriteStream()</span>, <span class="attribute">.write()</span> & <span class="attribute">.end()</span></td>
                            <td>Writeable Streams</td>
                            <td>In the example above on readable streams we were simply reading from a stream however it is also possible to write to a stream.<br/>The <span class="attribute">.createWriteStream()</span> method of the <span class="attribute">fs</span> module allows to do such an action.<br/><br/><span class="attribute">const fs = require('fs')<br/><br/>const fileStream = fs.createWriteStream('output.txt');<br/><br/>fileStream.write('This is the first line');<br/>fileStream.write('This is the second line');<br/>fileStream.end();</span><br/><br/>In the short example above the output file is set to <span class="attribute">'output.txt'</span> as shown between the <span class="attribute">.createWriteStream()</span> method parentheses.<br/>Unlike a readable stream, which ends when it has no more data to read, a writable stream can remain open indefinitely. The <span class="attribute">.end()</span> method closes the stream.<br/><br/>To build on this further we can reference another file to read from and create a new file that will be written to.<br/>If we use our previous shopping list example we can create a new file that states we are all out of stock of the items on the list. The syntax for this is shown below;<br/><br/><span class="attribute">const readline = require('readline');<br/>const fs = require('fs');<br/><br/>const myInterface = readline.createInterface({<br/>input: fs.createReadStream('shoppingList.txt')<br/>});<br/><br/>const fileStream = fs.createWriteStream('shoppingResults.txt');<br/><br/>const transformData = (line) => {<br/>fileStream.write(`They were out of: ${line}\n`)<br/>};<br/><br/>myInterface.on('line', transformData);</span><br/><br/>The output for this once run in the terminal would be a new text file named <span class="attribute">shoppingResults.txt</span> and within it would read;<br/><br/><span class="attribute">They were out of: Apples<br/>They were out of: Shampoo<br/>They were out of: Bread<br/>They were out of: Milk<br/>They were out of: Toothpaste</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.setImmediate()</span></td>
                            <td>The Timers module</td>
                            <td>There are times when we want some of our code to be executed at a specified point in time. This is what the timers module is used for. Like the Buffer module, it is not necessary to use the <span class="attribute">require()</span> import statement as the methods of the timer module are global.<br/><br/>You may already be familiar with some timer functions such as, <span class="attribute">setTimeout()</span> and <span class="attribute">setInterval()</span>. Timer functions in Node.js behave similarly to how they work in front-end JavaScript programs, but the difference is that they are added to the Node.js event loop. This means that the timer functions are scheduled and put into a queue. This queue is processed at every iteration of the event loop. If a timer function is executed outside of a module, the behavior will be random (non-deterministic).<br/><br/>The <span class="attribute">setImmediate()</span> function is often compared with the <span class="attribute">setTimeout()</span> function. When <span class="attribute">setImmediate()</span> is called, it executes the specified callback function after the current (poll phase) is completed. The method accepts two parameters: the callback function (required) and arguments for the callback function (optional). If you instantiate multiple <span class="attribute">setImmediate()</span> functions, they will be queued for execution in the order that they were created.<br/><br/><span class="attribute">setImmediate(() => {<br/>console.log('Hello world!')<br/>});</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="exporting_modules">
                <h2>Exporting Modules</h2>
                <p>This section describes the basic principles of exporting, importing and generally working with modules within Node.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">module.exports</span></td>
                            <td>Modular exports</td>
                            <td><span class="attribute">module.exports</span> is a global object built in to node. While this means it is accessible without needing to <span class="attribute">.require()</span> it in, the actual exports do need to be required in before use.<br/><br/>As an example, lets say we have a simple converter function in a file named <span class="attribute">converter.js</span>.<br/>We wish to use that function in a modular fashion elsewhere in our app without needing to constantly write it out or maintain multiple copies of the same function.<br/>Below is an example of syntax showing how the <span class="attribute">module.exports</span> object is assigned that function for use elsewhere.<br/><br/><span class="attribute">function cToF(celsius) {<br/>return celsius * (9/5) + 32;<br/>}<br/><br/>module.exports.cToF = cToF;</span></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.require()</span></td>
                            <td>Importing modular exports</td>
                            <td>The <span class="attribute">.require()</span> function is used to import all kinds of modules throughout node.<br/>In previous examples we've used it to bring in built-in modules, you use it in the same way to bring in custom modules.<br/><br/>In the example below lets say we are working in a new file called <span class="attribute">waterTemp.js</span>.<br/>In this file we wish to make use of the converter function we made in the previous example.<br/>An example of how we might do this is shown below;<br/><br/><span class="attribute">const converter = require('./converter.js');<br/><br/>const freezingPointCelsius = 0;<br/>const boilingPointCelsius = 100;<br/><br/>const freezingPointFahrenheit = converter.cToF(freezingPointCelsius);<br/>const boilingPointFahrenheit = converter.cToF(boilingPointCelsius);</span><br/><br/>Notice how when we required in the converter the filepath is relative, meaning the converter file is in the same folder. This may not always be the case and the filepath should reflect the reality of the file system in place.<br/><br/>Another point to note here is that the <span class="attribute">module.exports</span> object has been imported fully meaning that exports in the original file have been required in.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.require()</span></td>
                            <td>Deconstructed modular imports</td>
                            <td>As with front end style imports in Javascript we can use deconstructed syntax to bring in specific functions if there are multiple exports in a single file.<br/><br/><span class="attribute">const { cToF } = require('./converter.js');</span></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>For additional tags and examples see the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference" target="_blank">MDN Website</a> for more info.</p>
        </div>
    </body>
    <footer>

    </footer>
</html>