<!DOCTYPE html>
<html>
    <head>
        <title>PostgreSQL Cheat Sheet</title>
        <link href="./resources/css/index.css" type="text/css" rel="stylesheet">
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link rel="preconnect" href="https://fonts.googleapis.com">
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <!-- this is a section of code from google fonts that imports the poppins font type for use on the page --><link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
    </head>
    <body>
        <header>
            <nav>
                <div class="dropdown">
                    <button class="dropdownBtn">Front End</button>
                    <div class="dropdownContent">
                        <a href="./htmlcheatsheet.html">HTML</a>
                        <a href="./csscheatsheet.html">CSS</a>
                        <a href="./javascriptcheatsheet.html">JavaScript</a>
                        <a href="./reactcheatsheet.html">React</a>
                        <a href="./reduxcheatsheet.html">Redux</a>
                    </div>
                </div>
                <div class="dropdown">
                    <button class="dropdownBtn">Back End</button>
                    <div class="dropdownContent">
                        <a href="./nodecheatsheet.html">Node.js</a>
                        <a href="./expresscheatsheet.html">Express.js</a>
                        <a href="./postgresqlcheatsheet.html">PostgreSQL</a>
                    </div>
                </div>
                <div class="dropdown">
                    <button class="dropdownBtn">Other</button>
                    <div class="dropdownContent">
                        <a href="./commandlinecheatsheet.html">Command Line</a>
                        <a href="./markdowncheatsheet.html">Markdown</a>
                        <a href="./styleguide.html">Style Guide</a>
                    </div>
                </div>
            </nav>
        </header>
        <div class="content">
            <h1>PostgreSQL Cheat Sheet</h1>
            <p>Below is a list of commands, methods and fundamental principles regarding the PostgreSQL and databases in general including a brief description of what they do and any notes on correct syntax.</p>
            <div id="fundamentals">
                <h2>Fundamentals</h2>
                <p>This section describes some fundamental properties of databases.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Relational databases</td>
                            <td>A relational database is a database that organises information into one or more tables.<br/><br/>A table is a collection of data that is organised into columns and rows. Tables are often referred to as relations.<br/><br/>A column is a set of data values of a particular type such as <span class="attribute">id</span>, <span class="attribute">name</span> or <span class="attribute">age</span>.<br/><br/>A row is a single record in a table that would usually include all or some of the data to populate the columns such as and <span class="attribute">id</span> of <span class="attribute">1</span>, a <span class="attribute">name</span> of <span class="attribute">Jeremy</span> or an <span class="attribute">age</span> of <span class="attribute">36</span>.<br/><br/>All data stored in relational databases is of a certain data type.<br/>The most common data types are;<br/><br/><span class="attribute">INTEGER</span> - A Positive or negative whole number.<br/><span class="attribute">TEXT</span> - A text string.<br/><span class="attribute">DATE</span> - The date formatted as 'YYY-MM-DD'.<br/><span class="attribute">REAL</span> - A decimal value.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">CREATE TABLE</span></td>
                            <td>Statements</td>
                            <td>A statement is text that the database recognizes as a valid command. Statements always end in a semi colon much like JavaScript.<br/><br/><span class="attribute">CREATE TABLE table_name (<br/>column_1 data-type,<br/>column_2 data-type,<br/>column_3 data-type<br/>);</span><br/><br/>In the above code block <span class="attribute">CREATE TABLE</span> is a clause.<br/>Clauses perform specific tasks in SQL. The general convention is to write them in capitals. Clauses can also be referred to as commands.<br/><br/><span class="attribute">table_name</span>< refers to the name of the table that the command is applied to.<br/><br/><span class="attribute">column_1 data_type</span> is a parameter. A parameter is a list of columns, data types or values that are passed to a clause as an argument.<br/>In the example above the parameter is a list of column names and the associated data type.<br/><br/>Below is an example of a simple table being created using the correct syntax;<br/><br/><span class="attribute">CREATE TABLE users (<br/>id INTEGER,<br/>name TEXT,<br/>age INTEGER<br/>);</span><br/><br/>Notice how we make use of capitals to improve readability within our code.<br/>The code will work perfectly fine if everything was written in lowercase however when the code is written in this fashion it makes understanding what elements of the code are what much quicker and easier.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Data types</td>
                            <td>There are many data types that we can use in creating tables, below is a table displaying the most commonly used types and how the would be displayed.<br/><br/><table><thead><tr><th>Data Type</th><th>Representation</th><th>Value</th><th>Display</th></tr></thead><tbody><tr><td>integer</td><td>Whole number</td><td>4345</td><td>4345</td></tr><tr><td>decimal</td><td>Floating point number</td><td>23.263</td><td>23.263</td></tr><tr><td>money</td><td>Fixed floating point number with 2 decimal places</td><td>1.56</td><td>$1.56</td></tr><tr><td>boolean</td><td>Logic</td><td>TRUE, FALSE</td><td>t, f</td></tr><tr><td>char(n)</td><td>fixed length string, removes trailing blanks</td><td>834trh</td><td>834trh</td></tr><tr><td>varchar(n)</td><td>Variable length string</td><td>oijhfvrf</td><td>oijhfvrf</td></tr><tr><td>text</td><td>Unlimited length string</td><td>oiuyaf</td><td>oiuyaf</td></tr></tbody></table><br/><br/>When using the <span class="attribute">char(n)</span> data type, the <span class="attribute">(n)</span> denotes a fixed number of characters that must be used, for example if the <span class="attribute">(n)</span> is 9, then the input must be 9 characters long, no longer and no shorter.<br/><br/>When using the <span class="attribute">varchar(n)</span> data type, the <span class="attribute">(n)</span> denotes a maximum length of characters that can be used. For example if the <span class="attribute">(n)</span> is 15, then the input can be a maximum of 15 characters long, it cannot be longer but it can be shorter, so 3 characters or even no characters are valid unless other logic is employed.<br/><br/><a href="https://www.postgresql.org/docs/10/datatype.html" target="_blank">A full list of data types can be found here</a></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">INSERT INTO</span> & <span class="attribute">VALUES</span></td>
                            <td>Adding records to a table</td>
                            <td>Manually adding records into a table can be done with the following syntax;<br/><br/><span class="attribute">INSERT INTO users (id, name, age) <br/>VALUES (1, 'Jeremy', 36);</span><br/><br/>Lets explain the code above.<br/><span class="attribute">INSERT INTO</span> is a clause that adds the specified row or rows.<br/><span class="attribute">users</span> is the table we wish to add the row to.<br/><span class="attribute">(id, name, age)</span> is a parameter identifying the columns that data will be inserted into.<br/><span class="attribute">VALUES</span> is another clause that indicates the data being inserted.<br/><span class="attribute">(1, Jeremy, 36)</span> is a parameter identifying the values being inserted.<br/><br/>So as a result our table might look something like the following;<br/><br/><table><thead><tr><th>Id</th><th>Name</th><th>Age</th></tr></thead><tbody><tr><td>1</td><td>Jeremy</td><td>36</td></tr></tbody></table><br/><br/>Notice how our table now has a single row with all columns populated with the inserted values we defined.<br/><br/>A further point to note is that if you are populating a table with new information, provided the information matches and you fill in the correct columns in order, the parameters section of the query does not need to be included, so for example the above query could look like the following;<br/><br/><span class="attribute">INSERT INTO users VALUES (<br/>1,<br/>'Jeremy',<br/>36<br/>);</span><br/><br/>You can also enter multiple records within one statement.<br/>For example lets say we wanted to enter 3 users all at once, the following syntax would achieve this;<br/><br/><span class="attribute">INSERT INTO users (id, name, age) <br/>VALUES<br/>(2, 'Jeffrey', 31),<br/>(3, 'Kelly', 24)<br/>(4, 'Shona', 28);</span><br/><br/>Notice how we define the values we are entering in the initial parentheses and then each separate record is contained within its own parentheses and simply separated by a comma.<br/>The resulting table would look like the following;<br/><br/><table><thead><tr><th>Id</th><th>Name</th><th>Age</th></tr></thead><tbody><tr><td>1</td><td>Jeremy</td><td>36</td></tr><tr><td>2</td><td>Jeffrey</td><td>31</td></tr><tr><td>3</td><td>Kelly</td><td>24</td></tr><tr><td>4</td><td>Shona</td><td>28</td></tr></tbody></table><br/><br/></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">SELECT</span> & <span class="attribute">FROM</span></td>
                            <td>Viewing elements from a table</td>
                            <td><span class="attribute">SELECT</span> statements are used to fetch data from a database. We can use it fetch all data from a single column or even the entire database.<br/><br/><span class="attribute">SELECT age FROM users;</span><br/><br/>The above code fetches all data in the <span class="attribute">age</span> column from the <span class="attribute">users</span> table.<br/><br/>If we wanted to fetch all data from a table we could use the <span class="attribute">*</span> special character.<br/><br/><span class="attribute">SELECT * FROM users;</span><br/><br/>The above code would fetch all data from the <span class="attribute">users</span> table and return it.<br/><span class="attribute">SELECT</span> statements always return a new table called the result set.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">ALTER TABLE</span> & <span class="attribute">ADD COLUMN</span></td>
                            <td>Adding columns to an existing table</td>
                            <td>The <span class="attribute">ALTER TABLE</span> statement provides us with a way to add a new column to a table.<br/>Lets say we wish to add a country to our previous table, we could use the following code;<br/><br/><span class="attribute">ALTER TABLE users<br/>ADD COLUMN country TEXT;</span><br/><br/>In the above code we declare on the first line that we want to alter the <span class="attribute">users</span> table.<br/>On the second line we then declare we want to add a column by using the <span class="attribute">ADD COLUMN</span> command. We follow this up with the name of the column (<span class="attribute">country</span>) and the data type (<span class="attribute">TEXT</span>) we want this column to contain.<br/><br/>Once this has been done, the column will be added to the table and will be immediately populated with <span class="attribute">NULL</span> (<span class="attribute">∅</span>).<br/>This is a special value in SQL as it represents missing or unknown data.<br/><br/>Our updated table would look like the following;<br/><br/><table><thead><tr><th>Id</th><th>Name</th><th>Age</th><th>Country</th></tr></thead><tbody><tr><td>1</td><td>Jeremy</td><td>36</td><td>∅</td></tr></table><br/><br/>Notice that we now have a <span class="attribute">Country</span> column but it contains the <span class="attribute">NULL</span> (<span class="attribute">∅</span>) character indicating that there is no data in that column as yet.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">ALTER TABLE</span> & <span class="attribute">DROP COLUMN</span></td>
                            <td>Removing columns from an existing table</td>
                            <td>The <span class="attribute">DROP COLUMN</span> statement provides us with a way to remove an existing column from a table.<br/>Lets say we've added further tables as our database increases in complexity and now we remove some of the surplus information from one table to prevent clashes and duplication, we could use the following code;<br/><br/><span class="attribute">ALTER TABLE users<br/>DROP COLUMN country;</span><br/><br/>In the above code we declare on the first line that we want to alter the <span class="attribute">users</span> table.<br/>On the second line we then declare we want to remove a column by using the <span class="attribute">DROP COLUMN</span> command. We follow this up with the name of the column (<span class="attribute">country</span>).<br/><br/>Once this has been done, the column will be removed from the table.<br/><br/>Our updated table would look like the following;<br/><br/><table><thead><tr><th>Id</th><th>Name</th><th>Age</th></tr></thead><tbody><tr><td>1</td><td>Jeremy</td><td>36</td></tr></table><br/><br/>Notice that we now no longer have a <span class="attribute">Country</span> column.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">UPDATE</span>, <span class="attribute">SET</span> & <span class="attribute">WHERE</span></td>
                            <td>Updating an existing table</td>
                            <td>The <span class="attribute">UPDATE</span> statement provides us with a way to update an existing entry within a table.<br/>Lets say we wish to update the country column we just added in our previous table, we could use the following code;<br/><br/><span class="attribute">UPDATE users<br/>SET country = 'England'<br/>WHERE id = 1;</span><br/><br/>In the above code we declare that we want to <span class="attribute">UPDATE</span> the <span class="attribute">users</span> table.<br/>We then use the <span class="attribute">SET</span> clause to indicate which column we want to edit (<span class="attribute">country</span>) including the value we wish to have it updated to (<span class="attribute">'England'</span>).<br/>Finally we use the <span class="attribute">WHERE</span> clause to indicate that we want the row with a value of <span class="attribute">1</span> in the <span class="attribute">Id</span> column to be the target of the update.<br/><br/>Our new table would look like the following;<br/><br/><table><thead><tr><th>Id</th><th>Name</th><th>Age</th><th>Country</th></tr></thead><tbody><tr><td>1</td><td>Jeremy</td><td>36</td><td>England</td></tr></tbody></table><br/><br/>Notice that the <span class="attribute">Country</span> column has been updated to show the new string of <span class="attribute">England</span> as its value.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">DELETE</span></td>
                            <td>Deleting an entry in an existing table</td>
                            <td>The <span class="attribute">DELETE</span> statement provides us with a way to delete entire entries within a table based on specific criteria.<br/>Lets say we have a table with a few users, some of which do not contain any data within the <span class="attribute">country</span> column.<br/>It might look something like the following;<br/><br/><table><thead><tr><th>Id</th><th>Name</th><th>Age</th><th>Country</th></tr></thead><tbody><tr><td>1</td><td>Jeremy</td><td>36</td><td>England</td></tr><tr><td>2</td><td>Kelly</td><td>31</td><td>∅</td></tr><tr><td>3</td><td>Steve</td><td>19</td><td>∅</td></tr></tbody></table><br/><br/>We can use the following statement to delete all entries that do not contain any information in the <span class="attribute">country</span> column;<br/><br/><span class="attribute">DELETE FROM users<br/>WHERE country IS NULL;</span><br/><br/><span class="attribute">DELETE FROM</span> lets us delete rows from a table.<br/><span class="attribute">users</span> is the name of the table we want to target.<br/><span class="attribute">WHERE</span> provides the target for deletion whereby we add in the name of the column (<span class="attribute">country</span>) and the value we want to match to (<span class="attribute">NULL</span> or <span class="attribute">∅</span>). Anything that matches this criteria will be deleted.<br/><br/>Our new table would look like the following;<br/><br/><table><thead><tr><th>Id</th><th>Name</th><th>Age</th><th>Country</th></tr></thead><tbody><tr><td>1</td><td>Jeremy</td><td>36</td><td>England</td></tr></tbody></table><br/><br/>Notice how the entries for Kelly and Steve were deleted because they matched the criteria for deletion.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">PRIMARY KEY</span>, <span class="attribute">UNIQUE</span>, <span class="attribute">NOT NULL</span> & <span class="attribute">DEFAULT</span></td>
                            <td>Placing constraints on a table</td>
                            <td>In addition to adding data types into the creation of a table we can also provide constraints about how a column can be used.<br/>These help to tell the database what data is acceptable and what is not and needs to be rejected.<br/><br/>Below is an example of a table being created with these constraints;<br/>The constraint elements have been highlighted for clarity.<br/><br/><span class="code">CREATE TABLE users (<br/>id INTEGER </span><span class="attribute">PRIMARY KEY</span><span class="code">,<br/>username TEXT </span><span class="attribute">UNIQUE</span><span class="code">,<br/>date_of_birth TEXT </span><span class="attribute">NOT NULL</span><span class="code">,<br/>date_of_death TEXT </span><span class="attribute">DEFAULT 'Not Applicable'</span><span class="code"><br/>);</span><br/><br/><span class="attribute">PRIMARY KEY</span> columns can be used to uniquely identify the row. Attempts to insert a row with an identical value to a row already in the table will result in a constraint violation which will not allow you to insert a new row.<br/>Things like indexes are perfect for this as its likely that there will never be a duplicate index within a database.<br/><br/><span class="attribute">UNIQUE</span> columns have a different value for every row. This is similar to <span class="attribute">PRIMARY KEY</span> except that a table can have many different <span class="attribute">UNIQUE</span> columns.<br/>Things like usernames are also perfect for this as it is also likely you would never want 2 users to have the same username.<br/><br/><span class="attribute">NOT NULL</span> prevents columns from being defined without a value. Any attempts to insert a row without a value that has this constraint applied with result in a constraint violation and the new row will not be inserted.<br/><br/><span class="attribute">DEFAULT</span> columns take an additional argument that will be the default value applied to an inserted row if the new row does not specify a value for that column.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">ADD CONSTRAINT</span></td>
                            <td>Adding constraints on an existing column in a table</td>
                            <td>If we need to retroactively add a constraint to a column that already exists we can do so with the following code;<br/><br/><span class="attribute">ALTER TABLE table_name<br/>ADD CONSTRAINT constraint_name<br/>constraint_type (column_name)</span><br/><br/>The <span class="attribute">ADD CONSTRAINT</span> clause lets us define a constraint on an existing column. We define the constraint name, something short and descriptive of what the constraint is so its easy to pinpoint the issue in the event of an error.<br/>Then we define the constraint type, something like <span class="attribute">UNIQUE</span> in the event of an index or username.<br/>After this we have the column being targetted contained within parentheses.<br/><br/>A practical example is shown below;<br/><br/><span class="attribute">ALTER TABLE users<br/>ADD CONSTRAINT unique_username<br/>UNIQUE (username)</span><br/><br/>In the above example we add in a <span class="attribute">UNIQUE</span> constraint on the <span class="attribute">username</span> column to prevent new users from picking identical usernames.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="queries">
                <h2>Queries</h2>
                <p>This section describes some database queries.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Selecting specific columns</td>
                            <td>The <span class="attribute">SELECT</span> keyword can be used to fetch certain data from our database. Previously we used the <span class="attribute">*</span> selector to choose all columns however, we can specify columns by name rather than returning the entire database.<br/>This is clearly beneficial when we have large data sets and don't need to sift through every piece of information.<br/><br/>In the example below we have a table with several columns.<br/><br/><table><thead><tr><th>Id</th><th>Name</th><th>Age</th><th>Country</th></tr></thead><tbody><tr><td>1</td><td>Jeremy</td><td>36</td><td>England</td></tr><tr><td>2</td><td>Kelly</td><td>31</td><td>USA</td></tr><tr><td>3</td><td>Steve</td><td>19</td><td>∅</td></tr></tbody></table><br/><br/>Let say we wish to return the list of users showing only their name and age. We can specify this in our <span class="attribute">SELECT</span> query by naming the columns in our query in the following way;<br/><br/><span class="attribute">SELECT name, age<br/>FROM users;</span><br/><br/>We simply name the columns we wish to be returned, separated by a comma.<br/>The above query would return a table that looked like the following;<br/><br/><table><thead><tr><th>Name</th><th>Age</th></tr></thead><tbody><tr><td>Jeremy</td><td>36</td></tr><tr><td>Kelly</td><td>31</td></tr><tr><td>Steve</td><td>19</td></tr></tbody></table><br/><br/>Notice how the table only contains the name and age columns.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">AS</span></td>
                            <td>Using an alias for column names</td>
                            <td>The <span class="attribute">AS</span> keyword allows you to set an alias for a column name.<br/><br/><span class="attribute">SELECT name AS 'User'<br/>FROM users;</span><br/><br/>The code above renames the <span class="attribute">name</span> column as <span class="attribute">User</span>.<br/>There are a few things to note about the syntax here. The alias is contained within single quotes (<span class="attribute">' '</span>) This is the default syntax in SQLite however in PostgreSQL you'll need to include double quotes (<span class="attribute">" "</span>).<br/>Also the alias doesn't actually rename the column, it just returns the column with the alias as the title.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">DISTINCT</span></td>
                            <td>Filtering content</td>
                            <td>The <span class="attribute">DISTINCT</span> keyword allows you to filter content into unique values based on the data within the column.<br/>This is quite powerful when we have a large database of values and we might want to filter out things into categories or something similar.<br/><br/>For example in our users database we could filter the country column to see how many differing countries are represented by our users.<br/><br/>The syntax below shows the keyword in use;<br/><br/><span class="attribute">SELECT DISTINCT country<br/>FROM users;</span><br/><br/>The following results would be returned;<br/><br/><table><thead><tr><th>Country</th></tr></thead><tbody><tr><td>England</td></tr><tr><td>USA</td></tr><tr><td>∅</td></tr></tbody></table><br/><br/>In our example it's quite basic but in much larger databases this powerful filtering can help us quickly narrow things down.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">WHERE</span></td>
                            <td>Conditional filtering</td>
                            <td>The <span class="attribute">WHERE</span> keyword allows you to filter content based on a condition.<br/><br/>The following code demonstrates syntax;<br/><br/><span class="attribute">SELECT *<br/>FROM users<br/>WHERE age > 25;</span><br/><br/>The code above filters the <span class="attribute">users</span> table using the condition that the value in the <span class="attribute">age</span> column should be above 25.<br/>We would received the following results;<br/><br/><table><thead><tr><th>Id</th><th>Name</th><th>Age</th><th>Country</th></tr></thead><tbody><tr><td>1</td><td>Jeremy</td><td>36</td><td>England</td></tr><tr><td>2</td><td>Kelly</td><td>31</td><td>USA</td></tr></tbody></table><br/><br/>Steve is not included in the results as his age value does not meet the conditional criteria.<br/><br/>Common operators are described below;<br/><br/><span class="attribute">=</span> - Equal to.<br/><span class="attribute">!=</span> - Not equal to.<br/><span class="attribute">&gt;</span> - Greater than.<br/><span class="attribute">&lt;</span> - Less than.<br/><span class="attribute">&gt;=</span> - Greater than or equal to.<br/><span class="attribute">&lt;=</span> - Less than or equal to.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">LIKE</span></td>
                            <td>Retrieving similar patterns</td>
                            <td>The <span class="attribute">LIKE</span> keyword allows you to compare similar values with the use of a wildcard character.<br/><br/>For example, lets say we have a movie database that contains 2 films in it <span class="attribute">Seven</span> and <span class="attribute">Se7en</span>, the films are named distinctly differently according to a computer so a search for one would not return the other.<br/>If we use the <span class="attribute">LIKE</span> operator in conjunction with the <span class="attribute">WHERE</span> keyword, we can create an evaluation pattern to search our database with.<br/><br/>Example syntax is shown below;<br/><br/><span class="attribute">SELECT *<br/>FROM movies<br/>WHERE name LIKE 'SE_en';</span><br/><br/>In the above code we use both the <span class="attribute">WHERE</span> and <span class="attribute">LIKE</span> keywords to evaluate the <span class="attribute">name</span> column from the <span class="attribute">movies</span> table.<br/>We place the evaluation pattern of <span class="attribute">'SE_en'</span> as the condition so it will return any movie that follows the pattern of having <span class="attribute">Se</span> at the start and <span class="attribute">en</span> at the end with any type of character in the middle.<br/>In our example both the films <span class="attribute">Seven</span> and <span class="attribute">Se7en</span> would be returned as valid results.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">%</span></td>
                            <td>Retrieving matched elements</td>
                            <td>The <span class="attribute">%</span> operator allows you to return matched values with the use of a somewhat open ended wildcard character.<br/><br/>Example syntax is shown below;<br/><br/><span class="attribute">SELECT *<br/>FROM users<br/>WHERE name LIKE 'J%';</span><br/><br/>The statement above filters the <span class="attribute">users</span> table and returns all users whose <span class="attribute">name</span> begins with <span class="attribute">J</span>.<br/><br/>The position of the <span class="attribute">%</span> character also determines the match.<br/>For example, placing the <span class="attribute">%</span> before a letter would return every entry that ends with that letter.<br/><br/><span class="attribute">SELECT *<br/>FROM users<br/>WHERE name LIKE '%e';</span><br/><br/>The above would return every user whose name ended with <span class="attribute">e</span>.<br/><br/>You can also bookend a query to return every entry containing a phrase or collection of characters.<br/><br/><span class="attribute">SELECT *<br/>FROM users<br/>WHERE name LIKE '%eve%';</span><br/><br/>The above would return every user whose name contained <span class="attribute">eve</span>. The query itself is not case sensitive so if we have a user whose name was <span class="attribute">Eve</span> then that would also get returned within the results.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">IS NULL</span> & <span class="attribute">IS NOT NULL</span></td>
                            <td>Filtering for missing elements</td>
                            <td>While we can filter for characters, our database might contain missing values or Null (<span class="attribute">∅</span>) values.<br/>We cannot filter for these using the same methods. We need to use the <span class="attribute">IS NULL</span> or <span class="attribute">IS NOT NULL</span> operator to do this.<br/><br/><span class="attribute">SELECT name<br/>FROM users<br/>WHERE country IS NULL;</span><br/><br/>The above code will filter the <span class="attribute">users</span> table and return all users <span class="attribute">name</span>s whose <span class="attribute">country</span> column value <span class="attribute">IS NULL</span>.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">BETWEEN</span> & <span class="attribute">AND</span></td>
                            <td>Filtering within a range</td>
                            <td>We can use the <span class="attribute">BETWEEN</span> clause to filter search results to be within a range and return those results.<br/><br/>The following syntax demonstrates how;<br/><br/><span class="attribute">SELECT *<br/>FROM users<br/>WHERE age BETWEEN 30 AND 35;</span><br/><br/>The above code will filter the <span class="attribute">users</span> table and return all (<span class="attribute">*</span>) records who's <span class="attribute">age</span> falls <span class="attribute">BETWEEN</span> the range of <span class="attribute">30</span> and <span class="attribute">35</span>.<br/>The range works to include the figures noted so anyone with the age of 30 or 35 would also be included.<br/><br/>Text ranges work a little differently.<br/><br/><span class="attribute">SELECT *<br/>FROM users<br/>WHERE name BETWEEN 'A' AND 'J';</span><br/><br/>In the above code the statement filters the result to include <span class="attribute">users</span> with the <span class="attribute">name</span> that begins with <span class="attribute">'A'</span> but not including ones that begin with <span class="attribute">'J'</span><br/>HOWEVER! if a user has the name that is just <span class="attribute">J</span> then this would match and be returned. This is because <span class="attribute">BETWEEN</span> goes up to the second value.<br/>So <span class="attribute">J</span> would match but <span class="attribute">Jay</span> would not.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">AND</span></td>
                            <td>Combining parameters for specificity</td>
                            <td>We used the <span class="attribute">AND</span> clause to join 2 elements together to create a range in the previous example, however, we can use it to also chain multiple clauses together to create an even more specific search.<br/><br/><span class="attribute">SELECT *<br/>FROM users<br/>WHERE age BETWEEN 30 AND 35<br/>AND country = 'England';</span><br/><br/>The above code uses the <span class="attribute">AND</span> clause to first create a range with the use of the <span class="attribute">BETWEEN</span> clause.<br/>Additional specificity is provided by using the <span class="attribute">AND</span> clause to then require the results to filter those results on a second condition.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">OR</span></td>
                            <td>Combining parameters for generality</td>
                            <td>We used the <span class="attribute">AND</span> clause to join 2 elements together to create a results set that would return specific elements.<br/>We can also do the opposite to return a more general results set by using the <span class="attribute">OR</span> clause.<br/><br/><span class="attribute">SELECT *<br/>FROM users<br/>WHERE age BETWEEN 30 AND 35<br/>OR country = 'USA';</span><br/><br/>The above code uses the <span class="attribute">OR</span> clause to open the query to have a wider set of results that would be returned by way of providing 2 possible conditions that could be met to provide a result rather than providing 2 conditions that MUST be met to provide a result.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">ORDER BY</span>, <span class="attribute">DESC</span> & <span class="attribute">ASC</span></td>
                            <td>Ordering results</td>
                            <td>We can use clauses to help us make sense of returned data by organising it in a certain way.<br/>The <span class="attribute">ORDER BY</span> clauses allows us to do this either alphabetically or numerically.<br/><br/><span class="attribute">SELECT *<br/>FROM users<br/>ORDER BY name</span><br/><br/>The code above would return results ordered by the <span class="attribute">name</span> column.<br/>We can add to this and tell the database whether we want this to be either ascending or descending;<br/><br/><span class="attribute">SELECT *<br/>FROM users<br/>ORDER BY name DESC</span><br/><br/>In the above code we order the results in descending order.<br/>An interesting point about the ordering of results is that we can organise the data we are displaying by elements we are not displaying.<br/><br/><span class="attribute">SELECT *<br/>FROM users<br/>WHERE country = 'USA'<br/>ORDER BY age DESC;</span><br/><br/>In the above code we display all <span class="attribute">users</span> who match to <span class="attribute">'USA'</span> in the <span class="attribute">country</span> column.<br/>We display the information however in a descending order that is determined by the <span class="attribute">age</span> property.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">LIMIT</span></td>
                            <td>Limiting results</td>
                            <td>When returning a query we might hit more results than we require. We can use the <span class="attribute">LIMIT</span> keyword to define how many results we get back.<br/>This speeds up the query as well as making things slightly easier to deal with on screen.<br/><br/><span class="attribute">SELECT *<br/>FROM users<br/>LIMIT 10;</span><br/><br/>The above code limits the results to only <span class="attribute">10</span>.<br/>The <span class="attribute">LIMIT</span> clause also always comes at the end of a query.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">CASE</span></td>
                            <td>Database version of If...Else</td>
                            <td>A <span class="attribute">CASE</span> statement allows us to create different outputs against our database entries.<br/>for example lets say we want to organise our users into 3 groups that defined whether they were too young, just right or too old.<br/>We could write something like the following;<br/><br/><span class="attribute">SELECT name,<br/>CASE<br/>WHEN age < 20 THEN 'Too young'<br/>WHEN age > 35 THEN 'Too old'<br/>ELSE 'Just right'<br/>END<br/>FROM users;</span><br/><br/>In the above code we select which row we want to display (<span class="attribute">name</span>), we then use the <span class="attribute">CASE</span> clause to begin an evaluation based on the values in the <span class="attribute">age</span> column.<br/>We use the <span class="attribute">END</span> clause to close the evaluation and then state which table we want to use as the data source (<span class="attribute">users</span>).<br/><br/>Our table might look something like the following as a result;<br/><br/><table><thead><tr><th>Name</th><th>CASE WHEN age < 20 THEN 'Too young' WHEN age > 35 THEN 'Too old' ELSE 'Just right' END</th></tr></thead><tbody><tr><td>Jeremy</td><td>Too old</td></tr><tr><td>Kelly</td><td>Just right</td></tr><tr><td>Steve</td><td>Too young</td></tr></tbody></table><br/><br/>Notice how the column name is the evaluation code.<br/>We can change this by altering the <span class="attribute">END</span> clause;<br/><br/><span class="attribute">SELECT name,<br/>CASE<br/>WHEN age < 20 THEN 'Too young'<br/>WHEN age > 35 THEN 'Too old'<br/>ELSE 'Just right'<br/>END AS 'In the club'<br/>FROM users;</span><br/><br/>Our table will now like the following;<br/><br/><table><thead><tr><th>Name</th><th>In the club</th></tr></thead><tbody><tr><td>Jeremy</td><td>Too old</td></tr><tr><td>Kelly</td><td>Just right</td></tr><tr><td>Steve</td><td>Too young</td></tr></tbody></table><br/><br/></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="aggregate_functions">
                <h2>Aggregate Functions</h2>
                <p>This section describes Aggregate functions in relation to databases and notes on syntax.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">COUNT()</span></td>
                            <td>Counting</td>
                            <td>The <span class="attribute">COUNT()</span> function takes the name of a column as an argument and counts the number of non empty values in that column.<br/><br/><span class="attribute">SELECT COUNT(*)<br/>FROM users;</span><br/><br/>The above code would count all rows because we use the select all character (<span class="attribute">*</span>) as the argument.<br/><br/>Conditions can be added on to this through the use of the <span class="attribute">WHERE</span> clause.<br/>For example;<br/><br/><span class="attribute">SELECT COUNT(*)<br/>FROM users<br/>WHERE country = 'USA';</span><br/><br/>The above code would return how many rows there are that contain the value <span class="attribute">USA</span> in the country column.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">SUM()</span></td>
                            <td>Totals</td>
                            <td>The <span class="attribute">SUM()</span> function takes the name of a column as an argument and returns the sum of all of the values in that column.<br/><br/><span class="attribute">SELECT SUM(age)<br/>FROM users;</span><br/><br/>The above code would total up all of the age's of our users to give a combined age.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">MAX()</span></td>
                            <td>Maximum value</td>
                            <td>The <span class="attribute">MAX()</span> function takes the name of a column as an argument and returns the highest value in that column.<br/><br/><span class="attribute">SELECT MAX(age)<br/>FROM users;</span><br/><br/>The above code would find the highest age within our users and return this value.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">MIN()</span></td>
                            <td>Minimum value</td>
                            <td>The <span class="attribute">MIN()</span> function takes the name of a column as an argument and returns the lowest value in that column.<br/><br/><span class="attribute">SELECT MIN(age)<br/>FROM users;</span><br/><br/>The above code would find the lowest age within our users and return this value.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">AVG()</span></td>
                            <td>Average value</td>
                            <td>The <span class="attribute">AVG()</span> function takes the name of a column as an argument and returns the average value from all of the data found within that column.<br/><br/><span class="attribute">SELECT AVG(age)<br/>FROM users;</span><br/><br/>The above code would find the average age of our users and return this value.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">ROUND()</span></td>
                            <td>Rounding the value</td>
                            <td>The <span class="attribute">ROUND()</span> function takes 2 arguments. The first is the column and the second is an integer that indicates how many decimal places we wish the function to round to.<br/>Lets say we have a column that contains values that include decimals and we want to make this easier to read by rounding that information.<br/>Our table might look like the following;<br/><br/><table><thead><tr><th>Id</th><th>Product</th><th>Price</th></tr></thead><tbody><tr><td>1</td><td>Television</td><td>999.99</td></tr><tr><td>2</td><td>Mop</td><td>24.99</td></tr><tr><td>3</td><td>Sunglasses</td><td>199.99</td></tr></tbody></table><br/><br/>We could then use the code below to return a rounded version of these values;<br/><br/><span class="attribute">SELECT product, ROUND(price, 0)<br/>FROM products;</span><br/><br/>The above code would return a table that looked like the following;<br/><br/><table><thead><tr><th>Product</th><th>Price</th></tr></thead><tbody><tr><td>Television</td><td>1000</td></tr><tr><td>Mop</td><td>25</td></tr><tr><td>Sunglasses</td><td>200</td></tr></tbody></table><br/><br/>Notice how we use the <span class="attribute">SELECT</span> clause to return the <span class="attribute">product</span> column we then use a comma to separate the next query which is to <span class="attribute">ROUND()</span> and return the results of that function on the <span class="attribute">price</span> column.<br/><br/>If we wanted to Lets say we wanted to return the average price of our products, we could combine the <span class="attribute">AVG()</span> function with the <span class="attribute">ROUND()</span> to provide this information, we would just need to use the <span class="attribute">AVG()</span> as the first argument within the <span class="attribute">ROUND()</span>function.<br/>It would look something like the following;<br/><br/><span class="attribute">SELECT ROUND(AVG(price), 0)<br/>FROM products;</span><br/><br/>This would return something like the following;<br/><br/><table><thead><tr><th>Price</th></tr></thead><tbody><tr><td>408</td></tr></tbody></table><br/><br/>The value would be 408.33 but because we feed the <span class="attribute">AVG()</span> function into the <span class="attribute">ROUND()</span> function we get the rounded version of the figure returned instead.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">GROUP BY</span></td>
                            <td>Grouping blocks of data</td>
                            <td>If we have multiple categories or data that can be grouped together in a certain way (like country for our user examples) then we might want to perform aggregate functions on this data.<br/>For example we might want to count how many users come from a certain country.<br/><br/>Instead of having to write a statement that does this for each country, we can use the <span class="attribute">GROUP BY</span> clause that can group similar data into these categories and then perform the function on that data for us.<br/>This reduces the amount of code we would need to write.<br/><br/><span class="attribute">SELECT country, COUNT(*)<br/>FROM users<br/>GROUP BY country;</span><br/><br/>The above statement would return a results set that would look like the following;<br/><br/><table><thead><tr><th>Country</th><th>COUNT(*)</th></tr></thead><tbody><tr><td>England</td><td>1</td></tr><tr><td>USA</td><td>1</td></tr></tbody></table><br/><br/>Notice how we <span class="attribute">SELECT</span> the <span class="attribute">country</span> column to perform the <span class="attribute">COUNT()</span> function on. This column will be displayed in the results set so we can see all the countries returned. We then <span class="attribute">COUNT()</span> all (<span class="attribute">*</span>) the rows and <span class="attribute">GROUP BY</span> the <span class="attribute">country</span> so for each <span class="attribute">country</span> that is found in the <span class="attribute">country</span> column we add the total number of countries found in our database.<br/>This example is quite small as we only have 2 countries and each 1 has 1 entry, but you can imagine in larger databases we can quickly figure out the most popular country users are from on our database using this simple method.<br/><br/>We can add additional clauses to the statement. For example let say we had a much larger database that also included continent information and we only wanted to return the countries from europe.<br/>The statement would look something like the following;<br/><br/><span class="attribute">SELECT country, COUNT(*)<br/>FROM users<br/>WHERE continent = 'Europe';<br/>GROUP BY country</span><br/><br/>This would result in a table that looked like the following;<br/><br/><table><thead><tr><th>Country</th><th>COUNT(*)</th></tr></thead><tbody><tr><td>England</td><td>753</td></tr><tr><td>France</td><td>382</td></tr><tr><td>Spain</td><td>295</td></tr></tbody></table><br/><br/>Notice how the <span class="attribute">GROUP BY</span> clause stays at the end of the statement and the additional <span class="attribute">WHERE</span> clause comes before.<br/>The <span class="attribute">GROUP BY</span> clause should be at the end to provide the grouping function after all conditions have been processed.<br/>Its important to note that when used in conjunction with <span class="attribute">ORDER BY</span>, the <span class="attribute">ORDER BY</span> should still be at the end.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Grouping multiple blocks of data using multiple categories</td>
                            <td>Lets say we have a database that has multiple categories such as film genres and within those categories is a further level of division such as a rating system.<br/>If we wanted to view the multiple divisions for the multiple categories,we can do this within the <span class="attribute">GROUP BY</span> clause. You simply separate the various columns by a comma in the same way you would do when using the <span class="attribute">SELECT</span> command to select the column to begin with.<br/><br/>The syntax would look something like the following;<br/><br/><span class="attribute">SELECT genre, rating, COUNT(name)<br/>FROM movies<br/>GROUP BY genre, rating;</span><br/><br/>The above could would return a result set that might look something like the following;<br/><br/><table><thead><tr><th>Genre</th><th>Rating</th><th>COUNT(name)</th></tr></thead><tbody><tr><td>Comedy</td><td>4+</td><td>2</td></tr><tr><td>Comedy</td><td>3+</td><td>6</td></tr><tr><td>Comedy</td><td>2+</td><td>8</td></tr><tr><td>Comedy</td><td>1+</td><td>3</td></tr><tr><td>Comedy</td><td>0</td><td>1</td></tr><tr><td>Action</td><td>4+</td><td>7</td></tr><tr><td>Action</td><td>3+</td><td>34</td></tr><tr><td>Action</td><td>2+</td><td>11</td></tr><tr><td>Action</td><td>1+</td><td>6</td></tr><tr><td>Action</td><td>0</td><td>2</td></tr><tr><td>Drama</td><td>4+</td><td>6</td></tr><tr><td>Drama</td><td>3+</td><td>16</td></tr><tr><td>Drama</td><td>2+</td><td>12</td></tr><tr><td>Drama</td><td>1+</td><td>32</td></tr><tr><td>Drama</td><td>0</td><td>8</td></tr></tbody></table><br/><br/>In the above table we show the film <span class="attribute">genres</span> as one column.<br/>They appear multiple times because of the sub division of <span class="attribute">rating</span> we have also chosen to group by.<br/>Finally we also asked for a <span class="attribute">COUNT()</span> to show us how many movies appear with each rating in the original category.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Shorthand for grouping multiple blocks of data using multiple categories</td>
                            <td>In the above example we can use a shorthand method of writing the code.<br/>The syntax currently looks like the following;<br/><br/><span class="attribute">SELECT genre, rating, COUNT(name)<br/>FROM movies<br/>GROUP BY genre, rating;</span><br/><br/>SQL allows for a shorthand to reduce the amount of code that needs to be written as well as reducing possible syntax errors through spelling mistakes or similar.<br/>At the beginning of the statement SQL assigns each column being selected with a number.<br/>This is done in the background but it would look something like the following;<br/><br/><span class="attribute">SELECT genre</span><span class="code">(1)</span><span class="attribute">, rating</span><span class="code">(2)</span><span class="attribute">, COUNT(name</span><span class="code">(3)</span><span class="attribute">)<br/>FROM movies<br/>GROUP BY genre, rating;</span><br/><br/>We can make use of that when adding them in as part of the <span class="attribute">GROUP BY</span> section of the statement.<br/>The refactored code would look something like the following;<br/><br/><span class="attribute">SELECT genre, rating, COUNT(name)<br/>FROM movies<br/>GROUP BY 1, 2;</span><br/><br/>Notice how instead of having to write out the name of the column again we can just used the number.<br/>This allows us to minimise spelling mistakes and similar common problems.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">HAVING</span></td>
                            <td>Filtering groups</td>
                            <td>To build on the previous example of creating groups, we can then use the clause <span class="attribute">HAVING</span> to helps us filter the return data.<br/>For example lets say we only want to return results where there are more than 10 movies.<br/>The syntax might look like the following;<br/><br/><span class="attribute">SELECT genre, rating COUNT(name)<br/>FROM movies<br/>GROUP BY 1, 2<br/>HAVING COUNT(name) > 10;</span><br/><br/>Which would give us a result set that looked like;<br/><br/><table><thead><tr><th>Genre</th><th>Rating</th><th>COUNT(name)</th></tr></thead><tbody><tr><td>Action</td><td>3+</td><td>34</td></tr><tr><td>Action</td><td>2+</td><td>11</td></tr><tr><td>Drama</td><td>3+</td><td>16</td></tr><tr><td>Drama</td><td>2+</td><td>12</td></tr><tr><td>Drama</td><td>1+</td><td>32</td></tr></tbody></table><br/><br/>Notice how now our result set only contains the data where our <span class="attribute">COUNT(name)</span> column is over 10.<br/><br/><span class="attribute">HAVING</span> is very similar to <span class="attribute">WHERE</span> however the <span class="attribute">WHERE</span> clause filters rows and the <span class="attribute">HAVING</span> clause works on groups.<br/><br/>Its also important to note the order in the statement.<br/><span class="attribute">HAVING</span> always comes after the <span class="attribute">GROUP BY</span> clause but before an <span class="attribute">ORDER BY</span> or <span class="attribute">LIMIT</span> clause.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">strftime(parameter, column)</span></td>
                            <td>Return a formatted date</td>
                            <td>Sometimes we might need to work with formatted dates in our database. SQLite has a useful function (<span class="attribute">strftime()</span>) that allows us to select specific parts of a date to help us work with the connected data.<br/><br/>Dates are often formatted in the following fashion;<br/><br/><span class="attribute">2025-04-08T14:44:25Z</span><br/><br/>Ignoring the Z and T elements, the date follows the format of;<br/><br/><span class="attribute">YYY-MM-DD HH:MM:SS</span><br/><br/>Lets demonstrate how this works with the function by looking at the function parameters.<br/><br/>The function itself takes 2 arguments, the first is the section of the date that we wish to use as the selector.<br/>It is always contained within quotes (<span class="attribute">' '</span>) and it always starts with the percentage symbol (<span class="attribute">%</span>). After that the formats are as follows;<br/><br/><span class="attribute">'%Y'</span> - This returns the year section of the date.<br/><span class="attribute">'%m'</span> - This returns the month section of the date.<br/><span class="attribute">'%d'</span> - This returns the day section of the date.<br/><span class="attribute">'%H'</span> - This returns the hours section of the date.<br/><span class="attribute">'%M'</span> - This returns the minutes section of the date.<br/><span class="attribute">'%S'</span> - This returns the seconds section of the date.<br/><br/>The second parameter of the function is simply the column where the date data is, it'll often be something called date or timestamp.<br/><br/>Lets demonstrate this in a query;<br/><br/><span class="attribute">SELECT strftime('%H', date), alarm_set<br/>FROM table;</span><br/><br/>In the above code we use the function as our selector. Within the function we have identified the date column and within that we are using the hour parameter to return information based on the hours of each date element on each row in our table.<br/>In this example we are using it to then see if we have an alarm set for each hour.<br/>The return set might look like the following;<br/><br/><table><thead><tr><th>strftime('%H', date)</th><th>alarm_set</th></tr></thead><tbody><tr><td>01</td><td>No</td></tr><tr><td>02</td><td>No</td></tr><tr><td>03</td><td>Yes</td></tr></tbody></table><br/><br/>We can make use of the <span class="attribute">AS</span> clause to rename the column to something that makes more sense;<br/><br/><span class="attribute">SELECT strftime('%H', date) AS 'Hour of the day', alarm_set<br/>FROM table;</span><br/><br/>This would alter our table to now look like;<br/><br/><table><thead><tr><th>Hour of the day</th><th>alarm_set</th></tr></thead><tbody><tr><td>01</td><td>No</td></tr><tr><td>02</td><td>No</td></tr><tr><td>03</td><td>Yes</td></tr></tbody></table><br/><br/></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="multiple_tables">
                <h2>Multiple Tables</h2>
                <p>This section describes how to work with multiple tables and notes on syntax including general coding principles.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>The purpose of multiple tables</td>
                            <td>Within our app we might need to make use of multiple different tables to store differing pieces of data.<br/>Lets say we are running an online magazine shop.<br/>Within that environment we might need to hold data on numerous different things such as;<br/><br/>Details about orders being made.<br/>Details about the types of magazine subscriptions on offer.<br/>Details about customers who have made orders.<br/><br/>If we held it all in one big table, it might become difficult and slow to find specific pieces of information so we break it into smaller more categorised tables, sort of like slices of state.<br/><br/>The problem that we have with this is that separating elements into different tables can make getting the full picture more challenging.<br/><br/>For example, lets say our magazine shop has 3 separate tables that look like the following;<br/><br/><span class="code">Orders<br/>(a table with information on each magazine purchase)</span><br/><br/><table><thead><tr><th>order_id</th><th>customer_id</th><th>subscription_id</th><th>purchase date</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>2025-01-21</td></tr><tr><td>2</td><td>2</td><td>2</td><td>2025-04-01</td></tr><tr><td>3</td><td>3</td><td>1</td><td>2025-04-14</td></tr></tbody></table><br/><br/><span class="code">Subscriptions<br/>(a table that describes each type of subscription)</span><br/><br/><table><thead><tr><th>subscription_id</th><th>description</th><th>price_per_month</th><th>length</th></tr></thead><tbody><tr><td>1</td><td>Politics Magazine</td><td>5</td><td>12 months</td></tr><tr><td>2</td><td>Fashion Magazine</td><td>10</td><td>6 months</td></tr><tr><td>3</td><td>Sports Magazine</td><td>7</td><td>3 months</td></tr></tbody></table><br/><br/><span class="code">Customers<br/>(a table with customer names and contact information)</span><br/><br/><table><thead><tr><th>customer_id</th><th>customer_name</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>John Smith</td><td>123 Main St</td></tr><tr><td>2</td><td>Jane Doe</td><td>456 Park Ave</td></tr><tr><td>3</td><td>Joe Schmo</td><td>789 Broadway</td></tr></tbody></table><br/><br/>Within the 3 tables there is a logical separation of concerns, which makes it easier to narrow down specific information, however looking at just 1 table doesn't give you enough information about an order.<br/>You need to refer to multiple, sometimes even all, of the tables to get the full picture of an order.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">JOIN</span></td>
                            <td>Joining multiple tables</td>
                            <td>Keeping differing information in separate tables is a good practice for reducing confusion however, as discussed in the above example, it can make getting the full picture of a request or an order difficult.<br/><br/>Within SQL we have clauses that will allow us to combine multiple tables together so that it is easier for us to navigate the data.<br/>An example of the syntax is shown below;<br/><br/><span class="attribute">SELECT *<br/>FROM orders<br/>JOIN customers<br/>ON orders.customer_id = customers.customer_id;</span><br/><br/>The above code combines the orders table and the customers table.<br/>Lets run through how it works and what it produces as a result.<br/><br/>The first 2 lines are the same as any normal query, we use the <span class="attribute">SELECT</span> clause to return every (<span class="attribute">*</span>) column <span class="attribute">FROM</span> the orders table.<br/>The following 2 lines are what we are interested in.<br/>The <span class="attribute">JOIN</span> command tells SQL that we want to join another table to our orders table. That table is our <span class="attribute">subscriptions</span> table.<br/><br/>The next line uses the <span class="attribute">ON</span> command to tell SQL how to combine the 2 tables into 1 larger table.<br/>Its basically saying merge a specific column (<span class="attribute">customer_id</span>) in the first table (<span class="attribute">orders</span>) with a specific column (<span class="attribute">customer_id</span>) in the second table (<span class="attribute">customers</span>).<br/><br/>You'll notice that this is done with dot notation. We use the table name and then with dot notation specify the column name we wish to be targetted for merging.<br/>Its important to note that when tables have been combined dot notation should be used in queries when selecting specific columns to reduce ambiguity.<br/>We might have the same column name in 2 different tables, however if we use dot notation to specifically target a column in a specific table then we reduce the possibility of returning the wrong information.<br/>For example <span class="attribute">SELECT orders.customer_id</span> rather than the more ambiguous <span class="attribute">SELECT customer_id</span>.<br/><br/>With our tables merged we would get a result set that looks like the following;<br/><br/><table><thead><tr><th>order_id</th><th>customer_id</th><th>subscription_id</th><th>purchase date</th><th>customer_name</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>2025-01-21</td><td>Jane Doe</td><td>456 Park Ave</td></tr><tr><td>2</td><td>2</td><td>2</td><td>2025-04-01</td><td>Jane Doe</td><td>456 Park Ave</td></tr><tr><td>3</td><td>3</td><td>1</td><td>2025-04-14</td><td>Joe Schmo</td><td>789 Broadway</td></tr></tbody></table><br/><br/>Notice how now we have a larger combined table that gives us a wider picture of our orders.<br/>We can more easily figure out what customer has recently made a purchase without the need to constantly go back and forth through the tables to try and figure it out.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Inner Join</td>
                            <td>In the previous example of joining tables we assumed that the data in the targetted columns for the join is the same.<br/>However its very important to note that if there are elements that are not the same then these rows are simply not included in the result set.<br/>This is called an inner join.<br/><br/>For example lets use the same example but the target column has different data in one of the rows;<br/><br/><span class="code">Orders<br/>(a table with information on each magazine purchase)</span><br/><br/><table><thead><tr><th>order_id</th><th>customer_id</th><th>subscription_id</th><th>purchase date</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>2025-01-21</td></tr><tr><td>2</td><td>2</td><td>2</td><td>2025-04-01</td></tr><tr><td>3</td><td>3</td><td>1</td><td>2025-04-14</td></tr></tbody></table><br/><br/><span class="code">Customers<br/>(a table with customer names and contact information)</span><br/><br/><table><thead><tr><th>customer_id</th><th>customer_name</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>John Smith</td><td>123 Main St</td></tr><tr><td>3</td><td>Joe Schmo</td><td>789 Broadway</td></tr><tr><td>3</td><td>Joe Schmo</td><td>789 Broadway</td></tr></tbody></table><br/><br/>Notice that in the above tables we have altered the second row in the <span class="attribute">customer_id</span> column so they do not match.<br/>If we joined the tables again in the same way as we did previously;<br/><br/><span class="attribute">SELECT *<br/>FROM orders<br/>JOIN customers<br/>ON orders.customer_id = customers.customer_id;</span><br/><br/> We would get the following result set;<br/><br/><table><thead><tr><th>order_id</th><th>customer_id</th><th>subscription_id</th><th>purchase date</th><th>customer_name</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>2025-01-21</td><td>Jane Doe</td><td>456 Park Ave</td></tr><tr><td>3</td><td>3</td><td>1</td><td>2025-04-14</td><td>Joe Schmo</td><td>789 Broadway</td></tr></tbody></table><br/><br/>Notice how instead of getting the larger table with all 3 results we only get 2 results. This is because the row that does not match in the targetted column is omitted in the result set.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">LEFT JOIN</span></td>
                            <td>Left Join</td>
                            <td>If we have a scenario where we want to keep the unmatched rows for a certain reason, SQL has a clause that allows us to keep data from the first table whilst omitting data from the second table.<br/>We can use the result set to ascertain other information in this way.<br/><br/>For example lets say we have 2 tables that contain subscriber information for each different magazine. One table that contains subscriber information for our Politics magazine and the very same but for our Sports magazine.<br/>They might look like the following;<br/><br/><span class="code">Politics Magazine<br/>(a table containing subscriber information for our politics magazine)</span><br/><br/><table><thead><tr><th>customer_id</th><th>customer_name</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>John Smith</td><td>123 Main St</td></tr><tr><td>2</td><td>Jane Doe</td><td>456 Park Ave</td></tr><tr><td>3</td><td>Joe Schmo</td><td>789 Broadway</td></tr><tr><td>4</td><td>Dave Berry</td><td>34 Union</td></tr><tr><td>5</td><td>Jenny Hall</td><td>134 Long Street</td></tr><tr><td>6</td><td>Tony Blur</td><td>11 Upping Lane</td></tr></tbody></table><br/><br/><span class="code">Sports Magazine<br/>(a table containing subscriber information for our sports magazine)</span><br/><br/><table><thead><tr><th>customer_id</th><th>customer_name</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>John Smith</td><td>123 Main St</td></tr><tr><td>2</td><td>Jane Doe</td><td>456 Park Ave</td></tr><tr><td>4</td><td>Dave Berry</td><td>34 Union</td></tr><tr><td>5</td><td>Jenny Hall</td><td>134 Long Street</td></tr><tr><td>7</td><td>Daniel Cameron</td><td>9 Beaver Hill</td></tr><tr><td>8</td><td>Alfred Pitchfork</td><td>61 Terrace Mews</td></tr></tbody></table><br/><br/>Lets say we wish to combine these 2 tables but we want to keep all of the data in the first table (<span class="attribute">politics</span>) to find out how many of those users also subscribe to the sports magazine.<br/><br/>We can use the <span class="attribute">LEFT JOIN</span> clause when combining the tables to keep all the first table's data, omitting the second table's non-matching rows. This will give us a clear picture of all the users who subscribe to both magazines.<br/>The syntax would look like the following;<br/><br/><span class="attribute">SELECT *<br/>FROM politics<br/>LEFT JOIN sports<br/>ON politics.customer_id = sports.customer_id;</span><br/><br/>This would give us a result set that looks like the following;<br/><br/><table><thead><tr><th>customer_id</th><th>customer_name</th><th>address</th><th>customer_id</th><th>customer_name</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>John Smith</td><td>123 Main St</td><td>1</td><td>John Smith</td><td>123 Main St</td></tr><tr><td>2</td><td>Jane Doe</td><td>456 Park Ave</td><td>2</td><td>Jane Doe</td><td>456 Park Ave</td></tr><tr><td>3</td><td>Joe Schmo</td><td>789 Broadway</td><td>∅</td><td>∅</td><td>∅</td></tr><tr><td>4</td><td>Dave Berry</td><td>34 Union</td><td>4</td><td>Dave Berry</td><td>34 Union</td></tr><tr><td>5</td><td>Jenny Hall</td><td>134 Long Street</td><td>5</td><td>Jenny Hall</td><td>134 Long Street</td></tr><tr><td>6</td><td>Tony Blur</td><td>11 Upping Lane</td><td>∅</td><td>∅</td><td>∅</td></tr></tbody></table><br/><br/>Notice how all of the users from the first table (<span class="attribute">politics</span>) are included on the left hand side and the same users that appear in the second table (<span class="attribute">sports</span>) appear alongside them.<br/>When they do not appear in the second table the row is still included in our result set but the values are NULL showing that they do not subscribe to our sports magazine (because they do not exist in this table).<br/><br/>Any users that do not appear in our first table (<span class="attribute">politics</span>) are omitted entirely.<br/>So <span class="attribute">customer_id</span> <span class="attribute">7</span> & <span class="attribute">8</span> from our sports magazine table do no appear in the result set at all.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Primary Key vs Foreign Key</td>
                            <td>In a table, the primary key is a unique identifier that cannot be NULL.<br/>In most instances it will be something like an index or an id.<br/>It is a single value that will not relate to anything else.<br/>In a table there can only be a single column that works as the primary key.<br/><br/>There is also something called a foreign key.<br/>A foreign key is exactly the same but it's another table's primary key.<br/>This is how you create links to other tables.<br/><br/>Below are the tables for reference;<br/><br/><span class="code">Orders<br/>(a table with information on each magazine purchase)</span><br/><br/><table><thead><tr><th>order_id<br/>(Primary key)</th><th>customer_id<br/>(Foreign Key)</th><th>subscription_id<br/>(Foreign Key)</th><th>purchase date</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>2025-01-21</td></tr><tr><td>2</td><td>2</td><td>2</td><td>2025-04-01</td></tr><tr><td>3</td><td>3</td><td>1</td><td>2025-04-14</td></tr></tbody></table><br/><br/><span class="code">Subscriptions<br/>(a table that describes each type of subscription)</span><br/><br/><table><thead><tr><th>subscription_id<br/>(Primary Key)</th><th>description</th><th>price_per_month</th><th>length</th></tr></thead><tbody><tr><td>1</td><td>Politics Magazine</td><td>5</td><td>12 months</td></tr><tr><td>2</td><td>Fashion Magazine</td><td>10</td><td>6 months</td></tr><tr><td>3</td><td>Sports Magazine</td><td>7</td><td>3 months</td></tr></tbody></table><br/><br/><span class="code">Customers<br/>(a table with customer names and contact information)</span><br/><br/><table><thead><tr><th>customer_id<br/>(Primary Key)</th><th>customer_name</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>John Smith</td><td>123 Main St</td></tr><tr><td>2</td><td>Jane Doe</td><td>456 Park Ave</td></tr><tr><td>3</td><td>Joe Schmo</td><td>789 Broadway</td></tr></tbody></table><br/><br/>In our magazine example we have 3 separate tables. The first table (<span class="attribute">orders</span>) contains its primary key column which is <span class="attribute">order_id</span>, this is a column that contains unique values that can be used to locate a specific row in this table.<br/>Within this table we also have 2 other columns that contain foreign keys (<span class="attribute">customer_id</span> & <span class="attribute">subscription_id</span>).<br/>Now while they are primary keys in their own tables, meaning they cannot be duplicated, when they are a foreign key they can be used many times.<br/>For example in our magazines table, our customer <span class="attribute">Jane Doe</span> has a <span class="attribute">customer_id</span> of <span class="attribute">2</span>. While that will only ever appear once in the <span class="attribute">customers</span> table, it will appear many times in our <span class="attribute">orders</span> table because she has multiple magazine subscriptions.<br/><br/>Another important point to note here is that when joining tables together the columns being used to join may not always have the same corresponding title.<br/>For example the <span class="attribute">customer_id</span> column in our <span class="attribute">customers</span> table might just be called <span class="attribute">id</span> however, it still might be called <span class="attribute">customer_id</span> in our <span class="attribute">orders</span> table.<br/>The reason this is important is because we need to be mindful of the syntax when combining the tables.<br/>The syntax for this would be;<br/><br/><span class="attribute">SELECT *<br/>FROM orders<br/>JOIN customers<br>ON orders.customer_id = customers.id;</span><br/><br/>Notice how in this updated syntax the dot notation references different column names but the important thing to remember here is that we are targetting the correct data to make the table connection.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">CROSS JOIN</span></td>
                            <td>Cross Join</td>
                            <td>If we want to join 2 tables together and not lose any information we can use <span class="attribute">CROSS JOIN</span>.<br/><br/>The syntax is shown below;<br/><br/><span class="attribute">SELECT *<br/>FROM table_1<br/>CROSS JOIN table_2;</span><br/><br/>Notice how with this clause we don't need to use an <span class="attribute">ON</span> because we are not targetting any columns, we are simply joining 2 tables together and keeping all information.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">UNION</span></td>
                            <td>Stacking tables</td>
                            <td>If we have 2 tables that are identical in terms of the number of columns, the order of the columns and the data types and we want to make 1 large table that contained all of that information, we can use the <span class="attribute">UNION</span> clause.<br/><br/>For example let's say we have 2 tables that are essentially the same just with different internal values (the data types for each column are identical).<br/><br/><span class="code">Table 1</span><br/><br/><table><thead><tr><th>Team name</th><th>Home Ground</th></tr></thead><tbody><tr><td>Tottenham Hotspur</td><td>Tottenham Hotspur Stadium</td></tr><tr><td>Manchester United</td><td>Old Trafford</td></tr><tr><td>Peterborough United</td><td>London Road</td></tr></tbody></table><br/><br/><span class="code">Table 2</span><br/><br/><table><thead><tr><th>Team name</th><th>Home Ground</th></tr></thead><tbody><tr><td>Millwall</td><td>The Den</td></tr><tr><td>Arsenal</td><td>The Emirates</td></tr><tr><td>Liverpool</td><td>Anfield</td></tr></tbody></table><br/><br/>We can use the <span class="attribute">UNION</span> clause to combine these together.<br/>The syntax would be;<br/><br/><span class="attribute">SELECT *<br/>FROM table_1<br/>UNION<br/>SELECT *<br/>FROM table_2;</span><br/><br/>This would give us a result set that looked like the following;<br/><br/><table><thead><tr><th>Team name</th><th>Home Ground</th></tr></thead><tbody><tr><td>Tottenham Hotspur</td><td>Tottenham Hotspur Stadium</td></tr><tr><td>Manchester United</td><td>Old Trafford</td></tr><tr><td>Peterborough United</td><td>London Road</td></tr><tr><td>Millwall</td><td>The Den</td></tr><tr><td>Arsenal</td><td>The Emirates</td></tr><tr><td>Liverpool</td><td>Anfield</td></tr></tbody></table><br/><br/>Now we have a large table with all of the information combined together.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">WITH</span></td>
                            <td>Combining a previous query into a new table</td>
                            <td>Sometimes we want to use the result set from one query in another query. The <span class="attribute">WITH</span> clause can help us achieve this.<br/><br/>In our magazine example we have our <span class="attribute">orders</span> table.<br/>We can use a query on this to find out how many subscriptions a person has with us.<br/>That query might look like the following;<br/><br/><span class="attribute">SELECT customer_id, COUNT(subscription_id) AS 'Subscriptions'<br/>FROM orders<br/>GROUP BY customer_id</span><br/><br/>It would return a result set that could look something like the following;<br/><br/><table><thead><tr><th>customer_id</th><th>Subscriptions</th></tr></thead><tbody><tr><td>2</td><td>2</td></tr><tr><td>3</td><td>1</td></tr></tbody></table><br/><br/>While this query does what we wanted, it doesn't tell us the more detailed information about the customer such as their name or any of their details.<br/>At present this information isn't very useful.<br/><br/>If we use the <span class="attribute">WITH</span> clause we can use this result set to feed into another query so that we can fetch the additional information we want.<br/>The syntax is shown below;<br/><br/><span class="attribute">WITH previous_query AS (<br/></span><span class="code">SELECT customer_id,<br/>COUNT(subscription_id) AS 'Subscriptions'<br/>FROM orders<br/>GROUP BY customer_id<br/></span><span class="attribute">)<br/>SELECT customers.customer_name, previous_query.subscriptions<br/>FROM previous_query<br/>JOIN customers<br/>ON previous_query.customer_id = customers.customer_id;</span><br/><br/>The above would give us a return set that looked like the following;<br/><br/><table><thead><tr><th>customer_name</th><th>Subscriptions</th></tr></thead><tbody><tr><td>Jane Doe</td><td>2</td></tr><tr><td>Joe Schmo</td><td>1</td></tr></tbody></table><br/><br/>Let's explain how this code works.<br/>The <span class="attribute">WITH</span> clause basically creates a query and names it <span class="attribute">previous_query</span>. The entire query is contained within the parentheses (highlighted differently for ease of reading).<br/>This is the query highlighted earlier that shows a result set of the <span class="attribute">customer_id</span> and their number of subscriptions.<br/><br/>After the parentheses we start a second query in the usual manner, we use the <span class="attribute">SELECT</span> clause to pick out the columns we want to show.<br/>Notice how when we pick the columns we use dot notation to select specific columns, much in the same way that we do when we've joined tables.<br/>The reason for this is that in this second query we are using the result set created in the first query (which has been given the alias <span class="attribute">previous_query</span>) and we are joining it with one of our other tables (<span class="attribute">customers</span>).<br/>We can access all of the columns from the first query simply by using the alias (<span class="attribute">previous_query</span>) and then using dot notation to then select the desired column.<br/><br/>As we are joining the 2 columns we must target a column to be joined with our <span class="attribute">ON</span> clause in exactly the same way we would if we were joining 2 normal tables.<br/>In this case it is the <span class="attribute">customer_id</span> column, which we know will be the same in both tables, we just ensure that we select the correct column in the correct table by prepending it with either the alias (<span class="attribute">previous_query</span>) or the joined table (<span class="attribute">customers</span>).</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="relational_databases">
                <h2>Relational Databases</h2>
                <p>This section describes how to create relational databases with multiple tables that employ differing relationships with one another. There are notes on principles and syntax including general coding patterns.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">information_schema. key_column_usage</span></td>
                            <td>Using the information schema</td>
                            <td>Within PostgreSQL we have access to the information schema database.<br/>This is best thought of as being similar to a method in Javascript, something that we can use to find out more information on the tables in our database.<br/><br/>The information schema is itself a database that contains meta information about the database, this includes things like whether columns have been assigned as primary keys or not.<br/><br/>An example of the syntax for this is shown below;<br/>Let's say that we have a table named <span class="attribute">recipe</span> and within this table we have an <span class="attribute">id</span> column that we have designated as our primary key.<br/><br/><span class="attribute">SELECT<br/>constraint_name, table_name, column_name<br/>FROM<br/>information_schema.key_column_usage<br/>WHERE<br/>table_name = 'recipe';</span><br/><br/>The above code would return an output that would like the following;<br/><br/><table><thead><tr><th>constraint_name</th><th>table_name</th><th>column_name</th></tr></thead><tbody><tr><td>recipe_pkey</td><td>recipe</td><td>id</td></tr><tr><td>(1 row)</td></tr></tbody></table><br/><br/>Notice how the <span class="attribute">constraint_name</span> value is auto generated to be prefixed with the table name (<span class="attribute">recipe</span>) followed by an underscore and <span class="attribute">pkey</span> indicating that it is a primary key for this table.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">PRIMARY KEY (column_1, column_2)</span></td>
                            <td>Composite Primary Key</td>
                            <td>When creating tables, sometimes it may not be possible to designate a single column as the primary key. This could be because the information contained within the table always has multiple uses or always refers to multiple things.<br/>If this is the case then it might be possible to make use of a combination of columns to create a unique identifying pattern.<br/><br/>For example let's say we have a table named <span class="attribute">popular_books</span> that contains no singular column that holds unique data.<br/>The table columns might look like the below;<br/><br/><table><thead><tr><th>book_title</th><th>author_name</th><th>number_sold</th><th>number_previewed</th></tr></thead></table><br/><br/>In a table like this where each column and row has the potential to contain the same value as another column or row in the same table, we don't have the possibility to create any singular primary key column.<br/>However we can combine 2 columns to create a composite primary key.<br/>In our example table we can use the <span class="attribute">book_title</span> column in combination with the <span class="attribute">author_name</span> column to create a unique identifier for a specific row.<br/>The reasoning here is that an author is not likely to write 2 books with the same title, this is the logic that needs to be employed when creating composite primary keys.<br/><br/>The syntax for designating a composite primary is done when creating the table, an example of this is shown below;<br/><br/><span class="attribute">CREATE TABLE popular_books (<br/>book_title varchar(100),<br/>author_name varchar(50),<br/>number sold integer,<br/>number_previewed integer,<br/>PRIMARY KEY (book_title, author_name)<br/>);</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">REFERENCES</span></td>
                            <td>Foreign Key</td>
                            <td>A foreign key is a key that references a column in another table.<br/>Although we know how to join tables together, if we define the foreign keys when creating a table it enables a clearer picture to be drawn in the schema. This helps us to visualise the relationships between tables and it can be used in the information_schema meta data.<br/><br/>Lets say we have a <span class="attribute">book</span> table and we have an additional <span class="attribute">chapter</span> table, we can create them using the following syntax;<br/><br/><span class="attribute">CREATE TABLE book (<br/>title varchar(100),<br/>isbn varchar(50) PRIMARY KEY,<br/>pages integer,<br/>price money,<br/>description varchar(256),<br/>publisher varchar(100)<br/>);</span><br/><br/><span class="attribute">CREATE TABLE chapter (<br/>id integer PRIMARY KEY,<br/>number integer,<br/>title varchar(50),<br/>content varchar(1024),<br/>book_isbn varchar(50) REFERENCES book(isbn)<br/>);</span><br/><br/>Notice how in both tables we define a <span class="attribute">PRIMARY KEY</span> but in the <span class="attribute">chapter</span> table we use the <span class="attribute">REFERENCES</span> clause to create a foreign key.<br/>After the <span class="attribute">REFERENCES</span> clause we have the table name (<span class="attribute">book</span>) followed by the column we want to create a foreign key relationship with in the parentheses (<span class="attribute">isbn</span>).<br/>This doesn't change anything in terms of the table visually but in the information schema we now have a defined foreign key relationship between the 2 tables.<br/>This can be useful for </td>
                        </tr>
                        <tr>
                            <td><span class="attribute">UNIQUE</span></td>
                            <td>One to One relationships</td>
                            <td>A 1-1 relationship in terms of a database is best described as the following;<br/>A single row in table_a is associated with exactly 1 single row in table_b.<br/><br/>Common examples of this type of relationship are things like a person can only have a single passport number, a car can only have a single VIN number or person may only have one birth date.<br/>All of these things have unique relationships.<br/><br/>We can enforce 1-1 relationships in our database through the use of the <span class="attribute">UNIQUE</span> clause.<br/>An example of how we might do this is shown below;<br/><br/>Using the book database we have been using previously, lets say we want to create 2 tables, a <span class="attribute">book</span> table that contains information about many different books and then lets say we want to create another table called <span class="attribute">book_details</span> that has supplementary information that might bog down the first table such as user ratings and keyword tags or even the different languages it is written in.<br/><br/>To connect the 2 tables we need a <span class="attribute">PRIMARY KEY</span> and <span class="attribute">FOREIGN KEY</span> relationship to be created between the 2 tables.<br/>To ensure the 1-1 relationship is created we append the <span class="attribute">UNIQUE</span> clause to end of the <span class="attribute">FOREIGN KEY</span> when we create the table.<br/>The syntax would be as follows;<br/><br/><span class="attribute">CREATE TABLE book (<br/>title varchar(100),<br/>isbn varchar(50) PRIMARY KEY,<br/>pages integer,<br/>price money,<br/>description varchar(256),<br/>publisher varchar(100)<br/>);<br/><br/>CREATE TABLE book_details (<br/>id integer PRIMARY KEY,<br/>book_isbn varchar(50) REFERENCES book(isbn) UNIQUE,<br/>rating decimal,<br/>language varchar(10),<br/>keywords text[],<br/>date_published date<br/>);</span><br/><br/>Notice how in the creation of the <span class="attribute">book_details</span> table we define the <span class="attribute">FOREIGN KEY</span> by using the <span class="attribute">REFERENCES</span> clause and refer back to the <span class="attribute">book</span> table using the <span class="attribute">isbn</span> column as the argument as this is the <span class="attribute">book</span> table's <span class="attribute">PRIMARY KEY</span>.<br/>We then append the <span class="attribute">UNIQUE</span> clause to the end of this. This enforces the 1-1 relationship.<br/>What this means is that within that column there is now a <span class="attribute">UNIQUE</span> constraint that will prevent duplicate information being entered into any other row within that column.<br/><br/>For example lets say we have an isbn number on row 58 of <span class="attribute">'123456789'</span>, if we tried to insert another value into row 58 with that same value we would get an error message and the entry would not be created.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>One to Many relationships</td>
                            <td>A 1-Many relationship in terms of a database is best described as the following;<br/>A single row in table_a is associated with multiple rows in table_b.<br/>It could also have connections to multiple rows in table_c but SQL would define this as being a separate 1-Many relationship for the sake of clarity.<br/><br/>Common examples of this type of relationship are things like a person can have many children or a car can have multiple tyres.<br/>The important thing is that 1 can have many of the other but the others cannot have many of the 1, so a tyre cannot have multiple cars.<br/><br/>We've already explored how this is set up through the use of <span class="attribute">FOREIGN KEYS</span>.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Many to Many relationships</td>
                            <td>Many-Many relationships in databases can be quite complex, however a simple analogy on how the relationship works is that a student can have many classes but also a class can have many students.<br/>So how do we connect them without issue?<br/><br/>Many to many relationships in databases will require a minimum of 3 tables.<br/>Using the student analogy, we have our first table (<span class="attribute">student</span>) that contains various columns including its own <span class="attribute">PRIMARY KEY</span> such as an <span class="attribute">id</span> column.<br/><br/>We then also have a second table (<span class="attribute">class</span>) that also contains various columns including its own <span class="attribute">PRIMARY KEY</span> such as an <span class="attribute">id</span> column.<br/><br/>Finally we have a third table (<span class="attribute">schedule</span>) that will allow us to organise and create these complex relationships.<br/>This third table will contain separate columns for both of our <span class="attribute">student</span> and <span class="attribute">class</span> <span class="attribute">PRIMARY KEY</span>'s but in this table they will be <span class="attribute">FOREIGN KEYS</span>. However we then need to combine them in this table to be a composite primary key.<br/>The syntax for our cross reference table might look like the following;<br/><br/><span class="attribute">CREATE TABLE schedule (<br/>student_id varchar(50) REFERENCES student(id),<br/>class_id varchar(20) REFERENCES class(id),<br/>PRIMARY KEY (student_id, class_id)<br/>);</span><br/><br/>With our table created we can write a query to see some of the information using the composite key.<br/>The query might look like the following;<br/>(Note that in this query we will define the columns to have alias names)<br/><br/><span class="attribute">SELECT student.name AS student_name, class.subject AS subject<br/>FROM schedule<br/>JOIN student<br/>ON schedule.student_id = student.id<br/>JOIN class<br/>ON schedule.class_id = class.id;</span><br/><br/>Notice how we have selected the columns we wish to view from the relevant tables but joined them together using the cross reference <span class="attribute">schedule</span> table using their respective <span class="attribute">PRIMARY KEY</span>'s.<br/>the resulting table might look something like the following;<br/><br/><table><thead><tr><th>student_name</th><th>subject</th></tr></thead><tbody><tr><td>John</td><td>English</td></tr><tr><td>John</td><td>Science</td></tr><tr><td>John</td><td>Maths</td></tr><tr><td>Kelly</td><td>English</td></tr><tr><td>Kelly</td><td>Science</td></tr><tr><td>Kelly</td><td>Maths</td></tr></tbody></table><br/><br/>Notice how we have multiple rows for each student and each class, this is the many to many relationship that is being managed by the cross reference table, allowing for these relationships to exist without issue.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="triggers">
                <h2>Triggers</h2>
                <p>This section describes database triggers. There are notes on principles and syntax including general coding patterns.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>What are triggers?</td>
                            <td>Within databases, triggers are best explained as being a small section of code that is executed in response to something else happening with the database.<br/><br/>For example lets say we have a user database and we want a value to automatically update within our database every time a new user account is created.<br/>A trigger can be made to automatically do that.<br/><br/>Triggers take up computing power however they can also reduce the amount of code that is being written for other queries and things within our database.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>How are triggers activated?</td>
                            <td>The basic coding pattern for a trigger is as follows;<br/>(NOTE: in newer versions of PostgreSQL <span class="attribute">EXECUTE FUNCTION</span> might be used instead of <span class="attribute">EXECUTE PROCEDURE</span>)<br/><br/><span class="attribute">CREATE TRIGGER</span> <span class="code">&lt;trigger_name&gt;</span><br/><span class="attribute">BEFORE UPDATE ON</span> <span class="code">&lt;table_name&gt;</span><br/><span class="attribute">FOR EACH ROW<br/>EXECUTE PROCEDURE</span> <span class="code">&lt;trigger_function&gt;</span><br/><br/>So in the above code block we create a trigger and give it a name. Then we define which table it is going to refer to, we also define that whatever it is going to do will be done for every row in that table. Finally we define that the trigger will execute a certain function.<br/><br/>Lets look at a practical example;<br/><br/><span class="attribute">CREATE TRIGGER increase_user_count<br/>BEFORE UPDATE ON  users<br/>FOR EACH ROW<br/>EXECUTE PROCEDURE increase_user_count()</span><br/><br/>In the above example we want to create a trigger called <span class="attribute">increase_user_count</span>.<br/>We assign this trigger to the <span class="attribute">users</span> table and define that it happens before a update and that it does whatever it is doing for each row.<br/>Finally we execute the function <span class="attribute">increase_user_count()</span> which is potentially counting the number of users. (the purpose of the function here is not important as we are focusing on how triggers work)<br/><br/>While the above example activates the trigger <span class="attribute">BEFORE UPDATE ON</span> we can actually make it so the trigger happens <span class="attribute">AFTER UPDATE ON</span>.<br/>The case use for this is obviously dependant on what you want to achieve with the trigger, however its important to note that we can manipulate the timing of the triggers.<br/><br/>An example of the syntax for this is shown below;<br/><br/><span class="attribute">CREATE TRIGGER increase_user_count<br/>AFTER UPDATE ON  users<br/>FOR EACH ROW<br/>EXECUTE PROCEDURE increase_user_count()</span><br/><br/>The above code would need to have another <span class="attribute">SELECT</span> statement run after it to see any changes as the trigger runs <span class="attribute">AFTER</span> the update query.<br/><br/>Another point to note here is that we can also manipulate how many times a trigger is executed.<br/>the above statements all activate the trigger <span class="attribute">FOR EACH ROW</span> which, depending on what the statement is doing, can end up being quite costly in computing time if it is not necessary to do it for every row.<br/>We can alter this to be <span class="attribute">FOR EACH STATEMENT</span> for example if we wanted to be quite specific with our trigger and have it execute once for a specific statement we make then we could do that;<br/><br/><span class="attribute">CREATE TRIGGER increase_user_count<br/>AFTER UPDATE ON  users<br/>FOR EACH STATEMENT<br/>EXECUTE PROCEDURE increase_user_count()</span><br/><br/>The above trigger would only be executed once as we dictate this with the <span class="attribute">FOR EACH STATEMENT</span> clause.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">WHEN</span></td>
                            <td>Focusing triggers</td>
                            <td>The <span class="attribute"> WHEN</span> clause adds in a layer of filtering to triggers in a similar fashion to <span class="attribute">WHERE</span> clauses in queries.<br/><br/>Lets look at 2 examples below;<br/><br/><span class="attribute">CREATE TRIGGER update_trigger_high<br/>BEFORE UPDATE ON clients<br/>FOR EACH ROW<br/>WHEN (NEW.total_spent >= 1000)<br/>EXECUTE PROCEDURE set_high_spender();<br/><br/>CREATE TRIGGER update_trigger_low<br/>BEFORE UPDATE ON clients<br/>FOR EACH ROW<br/>WHEN (NEW.total_spent < 1000)<br/>EXECUTE PROCEDURE set_low_spender();</span><br/><br/>In the above examples we have 2 triggers, both work on the same principle.<br/>They are activated when a value in a column (<span class="attribute">total_spent</span>) on the specified table (<span class="attribute">clients</span>) reaches either above or below a threshold.<br/><br/>In either case the trigger activates a function which in this case sets a boolean value in another column to be either true or false.<br/>(The logic is held in the trigger function, again this is not relevant in this example as we're focusing on how the triggers work)</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Ordering triggers</td>
                            <td>A very important thing to note about triggers is that they run in alphabetical order based on their trigger name.<br/>It doesn't matter about the order they were coded but if you have several triggers that are set to fire on an event, they will execute one after the other in alphabetical order.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">.triggers</span></td>
                            <td>Using the information schema to identify triggers</td>
                            <td>The <span class="attribute">information_schema</span> clause we used to find out information of column usage can be used and appended with <span class="attribute">.triggers</span> to provide a readout of the available triggers on a specific table.<br/><br/>The following syntax will display all triggers available;<br/><br/><span class="attribute">SELECT * FROM information_schema.triggers;</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">DROP</span></td>
                            <td>Removing triggers</td>
                            <td>If you need to remove a trigger the following code template is demonstrative of the correct syntax;<br/><br/><span class="attribute">DROP TRIGGER</span> <span class="code">&lt;trigger_name&gt;</span> <span class="attribute">ON</span> <span class="code">&lt;table_name&gt;;</span><br/><br/></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="constraints">
                <h2>Constraints</h2>
                <p>This section describes database constraints. There are notes on principles and syntax including general coding patterns.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">NOT NULL</span></td>
                            <td>Null constraints</td>
                            <td>A null constraint is something we can introduce into our tables when we create them to prevent any column from accepting <span class="attribute">NULL</span> as a value.<br/><br/>The correct syntax is shown below;<br/><br/><span class="attribute">CREATE TABLE talks (<br/>id integer,<br/>title varchar NOT NULL,<br/>speaker_id integer NOT NULL,<br/>length integer,<br/>session_timeslot timestamp NOT NULL<br/>);</span><br/><br/>In the above example we have created 3 columns that each will not accept a <span class="attribute">NULL</span> value.<br/>If a <span class="attribute">NULL</span> value is attempted to be inserted into either of these columns, the statement will be rejected and no data will be created in the database as it violates the constraint placed on the column.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Altering existing  columns and Placeholders</td>
                            <td>Existing columns can be altered to have constraints put on them if so desired.<br/><br/><span class="attribute">ALTER TABLE talks<br/>ALTER COLUMN title SET NOT NULL</span><br/><br/>The above code block puts a <span class="attribute">NOT NULL</span> constraint on the <span class="attribute">title</span> column.<br/>We can remove constraints in a similar way;<br/><br/><span class="attribute">ALTER TABLE talks<br/> ALTER COLUMN title DROP NOT NULL</span><br/><br/>An important thing to note when altering existing columns is that if all of the values in the column do not abide by the constraint already when attempting to place that constraint on the column, then PostgreSQL will reject the constraint placement and it will not be put onto the column.<br/>When this happens we need to ensure that all values abide by the constraint. In the event of null values we can use the following code to insert placeholders;<br/><br/><span class="attribute">UPDATE talks<br/>SET title = 'TBD'<br/>WHERE title IS NULL;</span><br/><br/>The above code will insert the text <span class="attribute">'TBD'</span> into all the <span class="attribute">NULL</span> values, then allowing us to place the constraint on the column to prevent the inclusion of null values in the future.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">ADD CHECK (...)</span></td>
                            <td>Adding checks</td>
                            <td>In addition to adding constraints and data types on columns we can introduce more complex logic to ensure that values are complying with rules we would like to set.<br/>We do this through the use of the <span class="attribute">ADD CHECK (...)</span> clause.<br/><br/>Let's say we wish to place several constraints on a column.<br/>We have a column in a table that we require to be an integer, not null and a positive number.<br/><br/>The integer and not null aspects of this are fairly simple, we can cover these in either the creation or by altering the table in manners we've already explained.<br/>To ensure that the values are positive requires more complex logic and this is where the <span class="attribute">ADD CHECK (...)</span> clause comes in.<br/><br/>The <span class="attribute">ADD CHECK (...)</span> clause works by placing the logic within the parentheses.<br/>So for example when we create a table we can include this after the data type section of the clause;<br/><br/><span class="attribute">CREATE TABLE talks (<br/>length_of_talk integer NOT NULL<br/>ADD CHECK (length_of_talk > 0)<br/>);</span><br/><br/>Notice how we define the column name, the data type and place a <span class="attribute">NOT NULL</span> constraint on it, then we follow this with the <span class="attribute">ADD CHECK (...)</span> clause.<br/>The <span class="attribute">ADD CHECK (...)</span> in this example specifically ensures that the column <span class="attribute">length_of_talk</span> will always hold a value greater than <span class="attribute">0</span>.<br/><br/>We can retroactively add checks onto columns using the following syntax;<br/><br/><span class="attribute">ALTER TABLE talks<br/>ADD CHECK (length_of_talk > 0);</span><br/><br/>Notice how we make use of the <span class="attribute">ALTER TABLE</span> clause to add a check on the <span class="attribute">length_of_talk</span> column.<br/>The column is defined within the clauses parentheses.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Complex checks</td>
                            <td>When adding a check to a column we can include many different SQL syntax to create complex checking patterns.<br/>Generally, any logic that can be used within a <span class="attribute">WHERE</span> statement can be applied here.<br/><br/><span class="attribute">ALTER TABLE talks<br/>ADD CHECK (length_of_talk > 0 AND length_of_talk < 120);</span><br/><br/>Notice how we make use of the <span class="attribute">AND</span> clause to string 2 differing checks together to create an acceptable range.<br/><br/>We can even do maths with differing columns to provide checking.<br/>For example lets say we have a table that looks like the following;<br/><br/><table><thead><tr><th>talk_id</th><th>length_of_talk</th><th>standard_guests</th><th>vip_guests</th><th>total_guests</th></tr></thead><tbody><tr><td>1</td><td>30</td><td>31</td><td>7</td><td>38</td></tr><tr><td>2</td><td>45</td><td>23</td><td>5</td><td>28</td></tr><tr><td>3</td><td>45</td><td>56</td><td>14</td><td>70</td></tr></tbody></table><br/><br/>We can then place a check on the 3 guests columns to ensure that the values all coordinate with one another.<br/>the syntax would look like the following;<br/><br/><span class="attribute">ALTER TABLE talks<br/>ADD CHECK (standard_guests + vip_guests = total_guests);</span><br/><br/>Notice how we use the values of the columns to dictate the check here rather than hardcoding any number.<br/>This allows us to keep our code flexible and responsive.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">UNIQUE</span></td>
                            <td>Adding multiple columns to provide a single constraint</td>
                            <td>PostgreSQL also allows the tools to create a constraint that relies on the values of 2 columns.<br/>How is this useful?<br/>Let's say we are creating a schedule and we want to ensure that nobody is ever double booked. We can create a <span class="attribute">UNIQUE</span> constraint that takes in 2 columns to ensure that that specific combination of person and timeslot are unique thereby preventing any double booking.<br/><br/>The syntax for this when creating a table would look like the following;<br/><br/><span class="attribute">CREATE TABLE schedule (<br/>attendee_id integer NOT NULL,<br/>session_timeslot timestamp NOT NULL,<br/>UNIQUE (attendee_id, session_timeslot)<br/>);</span><br/><br/>The syntax for providing this constraint on an existing table would look like the following;<br/><br/><span class="attribute">ALTER TABLE schedule<br/>ADD UNIQUE (attendee_id, session_timeslot);</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">PRIMARY KEY</span> & <span class="attribute">FOREIGN KEY</span></td>
                            <td>Adding primary and foreign keys to existing tables</td>
                            <td>Sometimes we might encounter a scenario where a table may not have its primary and foreign keys defined when it was created.<br/>We can add these in later using the following syntax.<br/><br/><span class="attribute">ALTER TABLE talks<br/>ADD PRIMARY KEY (id);</span><br/><br/>The above creates a <span class="attribute">PRIMARY KEY</span> on the <span class="attribute">talks</span> table.<br/><br/><span class="attribute">ALTER TABLE schedule<br/>ADD FOREIGN KEY (talk_id) REFERENCES talks(id);</span><br/><br/>The above creates a <span class="attribute">FOREIGN KEY</span> on the <span class="attribute">schedule</span> table.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">RESTRICT</span></td>
                            <td>Preventing parent tables from being updated if information is referenced in a child table</td>
                            <td>PostgreSQL has a default behaviour of preventing any parent table row from being deleted or updated if the value is being referenced in a child table.<br/>This forces anyone doing a delete or update to consider the impact and make suitable alterations before potentially causing serious database issues.<br/><br/>This behaviour can also be explicitly included when creating a column.<br/>The syntax would look like the following;<br/><br/><span class="attribute">CREATE TABLE child (<br/>parent_id REFERENCES parent(id) ON DELETE RESTRICT OR REFERENCES parent(id) ON UPDATE RESTRICT<br/>);</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">CASCADE</span></td>
                            <td>Cascading changes</td>
                            <td>In the complete opposite behaviour to <span class="attribute">RESTRICT</span> we have the <span class="attribute">CASCADE</span> clause which allows us to auto delete or update the referenced values in a child table.<br/><br/>Lets work through an example of how this might work in a practical situation.<br/>Let's assume we have 2 tables <span class="attribute">schedule</span> and <span class="attribute">talks</span>.<br/>We can set up our <span class="attribute">schedule</span> table to unregister any attendees if a talk gets cancelled using the following syntax;<br/><br/><span class="attribute">ALTER TABLE schedule<br/>ADD FOREIGN KEY (talk_id)<br/>REFERENCES talks (id) ON DELETE CASCADE;</span><br/><br/>We can include the <span class="attribute">ON DELETE CASCADE</span> statement when creating a table in the same way we did in the <span class="attribute">RESTRICT</span> clause.<br/><br/>Now if we run a <span class="attribute">DELETE</span> query on our <span class="attribute">talks</span> table like so;<br/><br/><span class="attribute">DELETE FROM talks<br/>WHERE id = 1;</span><br/><br/>All of the talks in the <span class="attribute">talks</span> table with the <span class="attribute">id</span> of <span class="attribute">1</span> will be deleted and because we added the <span class="attribute">CASCADE</span> clause to the column, all rows for that talk with the matching id in child tables will also be deleted.<br/>This means that anyone who had the matching talk in their schedule will have it automatically removed.<br/><br/>Its very important to carefully consider when to use this clause because if the <span class="attribute">CASCADE</span> clause is applied <span class="attribute">ON UPDATE</span> rather than <span class="attribute">ON DELETE</span>, any changes could potentially create clashes that could seriously impact the database integrity.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="security_permissions">
                <h2>Security & Permissions</h2>
                <p>This section describes security and database permissions. There are notes on principles and syntax including general coding patterns.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Tag/Expression</th>
                            <th>Name</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="attribute">superuser</span></td>
                            <td>Database permissions</td>
                            <td>When you create a new PostgreSQL database server there will be a single database and a single user (both usually named <span class="attribute">postgres</span>) available.<br/><br/>The <span class="attribute">postgres</span> user (or any initial user) has the ability to create new databases, tables, users, etc. In PostgreSQL, the term for a user with these types of permissions is <span class="attribute">superuser</span>. A <span class="attribute">superuser</span> bypasses all permission checks that other users face before being allowed to perform an action.<br/><br/><span class="attribute">superuser</span> privileges are not restricted to a single user. In fact, the <span class="attribute">superuser</span> designation can be passed along to any number of other users in the database. However, the <span class="attribute">superuser</span> designation is a dangerous privilege and should be used sparingly. In computing, there is a rule called the principle of least privilege that suggests all applications and users should have only the minimum permissions required for their function.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">current_user</span></td>
                            <td>How to inspect the current user</td>
                            <td>The following command will allow you to inspect the current user's details.<br/><br/><span class="attribute">SELECT current_user;</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">pg_catalog.pg_roles</span></td>
                            <td>How to investigate users</td>
                            <td>PostgreSQL provides us with the functionality to list out all the users of a database and supply select details of some of their abilities in relation to the database.<br/><br/>The following code will return a table listing out all users and various details related to that account;<br/><br/><span class="attribute">SELECT * FROM pg_catalog.pg_roles;</span><br/><br/></td>
                        </tr>
                        <tr>
                            <td><span class="attribute">information_schema.table_privileges</span></td>
                            <td>How to inspect what a specific user can do within a database</td>
                            <td>Once we know a user's name on the database we can investigate further to see what permissions they have.<br/><br/><span class="attribute">SELECT *<br/>FROM information_schema.table_privileges<br/>WHERE grantee = '&lt;username&gt;';</span><br/><br/>The above code returns a table that lists all the permission details retained by <span class="attribute">&lt;username&gt;</span>.<br/>The table itself might look something like the following;<br/><br/><table><thead><tr><th>grantor</th><th>grantee</th><th>table_catalog</th><th>table_schema</th><th>table_name</th><th>privilege_type</th><th>is_grantable</th><th>with_hierarchy</th></tr></thead><tbody><tr><td>superuser</td><td>dave</td><td>superuser</td><td>cc_user</td><td>event_log</td><td>SELECT</td><td>NO</td><td>YES</td></tr><tr><td>superuser</td><td>dave</td><td>superuser</td><td>cc_user</td><td>event_log</td><td>INSERT</td><td>NO</td><td>YES</td></tr><tr><td>superuser</td><td>dave</td><td>superuser</td><td>cc_user</td><td>event_log</td><td>UPDATE</td><td>NO</td><td>YES</td></tr></tbody></table><br/><br/>Notice how each individual action is listed, giving a clear breakdown of what that user can do and in what specific table it refers to.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">SET ROLE</span></td>
                            <td>Testing privileges</td>
                            <td>PostgreSQL also provides the functionality to test out the permissions of other users through the <span class="attribute">SET ROLE</span> clause.<br/><br/><span class="attribute">SET ROLE &lt;username&gt;</span><br/><br/>The code above can be used by a <span class="attribute">superuser</span> to temporarily switch to the selected profile (<span class="attribute">&lt;username&gt;</span>) to then run queries and test out the role's functionality if needed.<br/>If errors are thrown then additional privileges can be granted to enhance the user's abilities as required.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">RESET ROLE</span></td>
                            <td>Resetting privileges</td>
                            <td>If you've been testing out other roles PostgreSQL provides the functionality to rest this temporary status and return to your original role that you logged in as.<br/><br/><span class="attribute">RESET ROLE;</span><br/><br/>The code above resets your role back to the original one you logged in with, restoring all privileges.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">session_user</span></td>
                            <td>Original log in profile</td>
                            <td>If you've been testing out other roles and cannot remember whether you've reset the role or not you can run a simple query to determine what the current role is and what the role that you originally logged in as.<br/><br/><span class="attribute">SELECT current_user, session_user;</span><br/><br/>The code above returns the name of the <span class="attribute">current_user</span> profile you are acting as, <span class="attribute">session_user</span> returns the original username you logged in as.<br/><br/>This is a quick way to determine who you are acting as and who you logged in as.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">CREATE ROLE</span> & <span class="attribute">ALTER ROLE</span></td>
                            <td>Creating and modifying roles</td>
                            <td>As a superuser you have the ability to create and alter supplementary roles and define the privileges they have.<br/>The boilerplate for his is shown below;<br/><br/><span class="attribute">CREATE ROLE &lt;user_name&gt; WITH &lt;privilege_1&gt; &lt;privilege_2&gt;;</span><br/><br/>Notice how there is no comma between each individual privilege.<br/>A list of the definable privileges can be found <a href="https://www.postgresql.org/docs/10/sql-createrole.html">here</a>.<br/><br/>Below is a practical example;<br/><br/><span class="attribute">CREATE ROLE analyst WITH NOSUPERUSER LOGIN;</span><br/><br/>In the above code we create a new role (<span class="attribute">analyst</span>) and provide 2 privileges, the first ensuring that this role is NOT a superuser by stating <span class="attribute">NOSUPERUSER</span> and we follow this up with <span class="attribute">LOGIN</span> which allows the user to login to the database.<br/><br/>We can further alter this role after its been created in the following way;<br/><br/><span class="attribute">ALTER ROLE analyst WITH CREATEDB;</span><br/><br/>The above code adds further privileges to the <span class="attribute">analyst</span> role by now allowing them to create databases with the <span class="attribute">CREATEDB</span> privilege.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">GRANT</span>, <span class="attribute">USAGE</span> & <span class="attribute">ON SCHEMA</span></td>
                            <td>Granting permissions to roles for table interaction</td>
                            <td>Once a role has been created or altered, that role will then need to be given permissions to interact with tables, either viewing or editing, even creating and deleting.<br/>The pattern to be followed to allow this involves first granting permissions to a role for the schema, then once this has been granted you can be quite selective over what elements of the schema you wish that role to have access to and how it can interact.<br/><br/>Let's work through the boilerplate below;<br/><br/><span class="attribute">GRANT USAGE ON SCHEMA &lt;schema_name&gt; TO &lt;role_name&gt;;</span><br/><br/>In the above code we are granting usage to the entire schema to a specified role. We need to do this first to allow the role access to the schema before we then be selective about what tables and subsequent interactions that role can have.<br/>It is in this stage that we can also provide higher level privileges like <span class="attribute">CREATE</span> that would allow the role to create new tables on the schema. To do this you would simply add a comma after the <span class="attribute">USAGE</span> clause and then add in the <span class="attribute">CREATE</span> keyword.<br/><br/>Once high level usage permissions are granted we then need to add additional permissions before any queries can be run on any table.<br/>Let's explore how this can be done;<br/><br/><span class="attribute">GRANT SELECT, UPDATE ON &lt;schema.table_name&gt; TO &lt;role_name&gt;;</span><br/><br/>In the above code we are granting <span class="attribute">SELECT</span> and <span class="attribute">UPDATE</span> privileges to the role on a specified table.<br/>Notice how we specify the table using the notation of <span class="attribute">schema.table_name</span>.<br/><br/>We can use this template to provide <span class="attribute">INSERT</span> privileges and others including <span class="attribute">DELETE</span>.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">REVOKE</span> & <span class="attribute">FROM</span></td>
                            <td>Revoking permissions to roles for table interaction</td>
                            <td>Revoking permissions follows a similar pattern to granting permissions.<br/>The code below demonstrates this;<br/><br/><span class="attribute">REVOKE UPDATE ON &lt;schema.table_name&gt; FROM &lt;role_name&gt;;</span><br/><br/>You can chain removing multiple privileges in much the same way you would when granting them.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">ALTER DEFAULT PRIVILEGES</span>, <span class="attribute">IN SCHEMA</span> & <span class="attribute">IN DATABASE</span></td>
                            <td>Granting default permissions</td>
                            <td>PostgreSQL has a function that allows us to set default privileges to a role.<br/>This is particularly useful because it means that every time a new table is created we won't have to manually grant permissions to each role, it will be done automatically as a default state.<br/><br/>For example lets say we have 2 tables and a role (<span class="attribute">analyst</span>) that has <span class="attribute">SELECT</span>, <span class="attribute">INSERT</span> and <span class="attribute">UPDATE</span> privileges on those tables.<br/>We want to create more tables but don't want to keep having to manually grant these privileges to the <span class="attribute">analyst</span> role.<br/><br/>We can alter the default privileges to let these be auto assigned whenever a new table is created using the following statement;<br/><br/><span class="attribute">ALTER DEFAULT PRIVILEGES IN SCHEMA &lt;schema_name&gt;<br/>GRANT SELECT, INSERT, UPDATE ON TABLES TO analyst;</span><br/><br/>The above statement will now auto assign the <span class="attribute">SELECT</span>, <span class="attribute">INSERT</span> & <span class="attribute">UPDATE</span> privileges to the <span class="attribute">analyst</span> role on any new table that is created.<br/><br/>We can swap out the <span class="attribute">IN SCHEMA</span> clause in the statement to read <span class="attribute">IN DATABASE</span> if we wanted this default behaviour to be replicated through the entire database rather than just this specific schema.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Groups</td>
                            <td>So far we have been defining individual roles, this is useful and fine for small databases, however once the database starts to scale up and large numbers of users become involved, manually managing the permissions of each individual account can be inefficient and overwhelming.<br/><br/>Groups can be given privileges and then individual user roles can be assigned to these groups, which in turn inherit those privileges.<br/>This makes management of the database much easier.<br/><br/>There are several ways that groups can be created and users subsequently assigned to them.<br/><br/><span class="attribute">CREATE ROLE &lt;group_name&gt; WITH NOLOGIN CREATEDB;<br/><br/>GRANT &lt;group_name&gt; TO &lt;user_name_1&gt;;</span><br/><br/>The statement above is the basic syntax used for creating a group and then assigning users to that group.<br/>Notice how when assigning multiple privileges there is no comma.<br/><br/><span class="attribute">CREATE ROLE &lt;group_name&gt; WITH NOLOGIN ROLE &lt;user_name_1&gt;, &lt;user_name_2&gt;;</span><br/><br/>The above statement creates a group and assigns several users to that group all in one statement.<br/>This is a more condensed version than the first option we explored.<br/><br/><span class="attribute">CREATE ROLE &lt;user_name_3&gt; WITH LOGIN IN ROLE &lt;group_name_1&gt;, &lt;group_name_2&gt;;</span><br/><br/>The final statement here is how we can auto assign a new user role into a group upon creation of that user.<br/>Notice how in this last one we assign the user into 2 separate groups, this is because different groups can have different privileges and users can be in more than one group dependant on their role requirements.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">NOLOGIN</span> & <span class="attribute">LOGIN</span></td>
                            <td>The use case for login</td>
                            <td>What is the difference between these privileges and what are they used for?<br/><br/><span class="attribute">LOGIN</span> roles are for individual roles, people that need to connect to the database to write queries, they have usernames and potentially passwords.<br/><br/><span class="attribute">NOLOGIN</span> roles are for groups, they don't need to connect to the database but they are used to bundle up privileges for individual users to then inherit and make use of in queries.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute"></span></td>
                            <td>Column level security</td>
                            <td>Tables can often contain sensitive information in certain columns. We could split these columns into another table that people do not have access to however that is quite long winded and inefficient.<br/>PostgreSQL has the ability to restrict access to columns.<br/>So for example lets say we grant a group the permissions to a table that contains this sensitive information, we can specify which columns they have access to.<br/><br/>The syntax for this is shown below;<br/><br/><span class="attribute">GRANT SELECT, INSERT, UPDATE (project_name, project_timeline, project_status)<br/>ON projects TO employees;</span><br/><br/>In the above statement we <span class="attribute">GRANT</span> several privileges to the group <span class="attribute">employees</span> for the table <span class="attribute">projects</span>, however notice that within the statement we contain all of the columns we want them to have access to in the parentheses, any other columns not included within this clause will not be included in the permission.<br/>Therefore any member of the <span class="attribute">employees</span> group trying to query additional columns will be thrown an error.<br/><br/>It's important to note here that queries that include <span class="attribute">*</span> as the selector here will also throw an error because that is also trying to access columns the group does not have access to.</td>
                        </tr>
                        <tr>
                            <td><span class="attribute">CREATE POLICY</span></td>
                            <td>Row level security</td>
                            <td>Row level security is slightly more complex than column level in that you need to <span class="attribute">CREATE POLICY</span> and then apply this to the table for it to be in effect.<br/><br/>Let's run through an example to explain;<br/><br/>We have a group role called <span class="attribute">sales</span> that includes multiple users who all have inherited privileges on the table <span class="attribute">contracts</span>.<br/>At present any one salesperson can potentially view and edit the data that belongs to another salesperson.<br/>The entire table might look something like the following;<br/><br/><table><thead><tr><th>salesperson</th><th>client</th><th>contract_start</th><th>contract_end</th><th>contract_value</th></tr></thead><tbody><tr><td>Joe</td><td>Big Stuff Inc.</td><td>2025-01-21</td><td>2025-03-21</td><td>25000</td></tr><tr><td>Joe</td><td>Things Ltd</td><td>2025-05-07</td><td>2025-06-28</td><td>12000</td></tr><tr><td>Fred</td><td>Corp plc.</td><td>2025-08-01</td><td>2025-09-01</td><td>17500</td></tr><tr><td>Billy</td><td>Liman Bros.</td><td>2024-02-16</td><td>2025-10-26</td><td>92750</td></tr></tbody></table><br/><br/>To implement row level security we would write a statement using the following boilerplate;<br/><br/><span class="attribute">CREATE POLICY &lt;policy_name&gt; ON &lt;table_name&gt; FOR SELECT, UPDATE<br/>TO &lt;group_name&gt; USING (salesperson=current_user);</span><br/><br/>Which in our example would look like;<br/><br/><span class="attribute">CREATE POLICY rls_policy ON contracts FOR SELECT, UPDATE<br/>TO sales USING (salesperson=current_user);</span><br/><br/>The above statement does the following;<br/><br/>Creates a row level security policy on a table and specifies the permissions type the applies to.<br/><br/>Specifies the role this policy applies to using the role name (which is the group in this example).<br/><br/>Specifies the condition to check before permitting a user to carry out an action. In this example the <span class="attribute">current_user</span> must equal the value in the <span class="attribute">salesperson</span> column.<br/><br/>Once this is written it needs to be implemented onto the table.<br/>We do this with the following statement;<br/><br/><span class="attribute">ALTER TABLE contracts ENABLE ROW LEVEL SECURITY;</span><br/><br/>With this now implemented if <span class="attribute">Joe</span> wrote a <span class="attribute">SELECT * FROM contracts;</span> statement, he would see the following table;<br/><br/><table><thead><tr><th>salesperson</th><th>client</th><th>contract_start</th><th>contract_end</th><th>contract_value</th></tr></thead><tbody><tr><td>Joe</td><td>Big Stuff Inc.</td><td>2025-01-21</td><td>2025-03-21</td><td>25000</td></tr><tr><td>Joe</td><td>Things Ltd</td><td>2025-05-07</td><td>2025-06-28</td><td>12000</td></tr></tbody></table><br/><br/>Notice how it now only shows his contracts and not anyone else's.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>For additional clauses see the <a href="https://www.postgresql.org/docs/10/index.html" target="_blank">PostgreSQL documentation website</a> for more info.</p>
        </div>
    </body>
    <footer>

    </footer>
</html>


<!-- Template for nested tables in notes

∅

<table>
    <thead>
        <tr>
            <th>order_id</th>
            <th>customer_id</th>
            <th>subscription_id</th>
            <th>purchase date</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1</td>
            <td>2</td>
            <td>3</td>
            <td>2025-01-21</td>
        </tr>
        <tr>
            <td>2</td>
            <td>2</td>
            <td>2</td>
            <td>2025-04-01</td>
        </tr>
        <tr>
            <td>3</td>
            <td>3</td>
            <td>1</td>
            <td>2025-04-14</td>
        </tr>
    </tbody>
</table>

-->